'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reason = require('reason');
var CssTree = require('css-tree');
var Graphql = require('graphql');
var Typescript = require('typescript');

function caml_array_sub(x, offset, len) {
  var result = new Array(len);
  var j = 0;
  var i = offset;
  while(j < len) {
    result[j] = x[i];
    j = j + 1 | 0;
    i = i + 1 | 0;
  }  return result;
}

function len(_acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    if (!l) {
      return acc;
    }
    _l = l.tl;
    _acc = l.hd.length + acc | 0;
    continue ;
  }}

function fill(arr, _i, _l) {
  while(true) {
    var l = _l;
    var i = _i;
    if (!l) {
      return ;
    }
    var x = l.hd;
    var l$1 = x.length;
    var k = i;
    var j = 0;
    while(j < l$1) {
      arr[k] = x[j];
      k = k + 1 | 0;
      j = j + 1 | 0;
    }    _l = l.tl;
    _i = k;
    continue ;
  }}

function caml_array_concat(l) {
  var v = len(0, l);
  var result = new Array(v);
  fill(result, 0, l);
  return result;
}

function set(xs, index, newval) {
  if (index < 0 || index >= xs.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  xs[index] = newval;
  
}

function get(xs, index) {
  if (index < 0 || index >= xs.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  return xs[index];
}

function caml_make_vect(len, init) {
  var b = new Array(len);
  for(var i = 0; i < len; ++i){
    b[i] = init;
  }
  return b;
}

function caml_make_float_vect(len) {
  var b = new Array(len);
  for(var i = 0; i < len; ++i){
    b[i] = 0;
  }
  return b;
}

function caml_array_blit(a1, i1, a2, i2, len) {
  if (i2 <= i1) {
    for(var j = 0; j < len; ++j){
      a2[j + i2 | 0] = a1[j + i1 | 0];
    }
    return ;
  }
  for(var j$1 = len - 1 | 0; j$1 >= 0; --j$1){
    a2[j$1 + i2 | 0] = a1[j$1 + i1 | 0];
  }
  
}

function caml_array_dup(prim) {
  return prim.slice(0);
}

var caml_array_dup_1 = caml_array_dup;
var caml_array_sub_1 = caml_array_sub;
var caml_array_concat_1 = caml_array_concat;
var caml_make_vect_1 = caml_make_vect;
var caml_make_float_vect_1 = caml_make_float_vect;
var caml_array_blit_1 = caml_array_blit;
var get_1 = get;
var set_1 = set;
/* No side effect */

var caml_array = {
	caml_array_dup: caml_array_dup_1,
	caml_array_sub: caml_array_sub_1,
	caml_array_concat: caml_array_concat_1,
	caml_make_vect: caml_make_vect_1,
	caml_make_float_vect: caml_make_float_vect_1,
	caml_array_blit: caml_array_blit_1,
	get: get_1,
	set: set_1
};

function app(_f, _args) {
  while(true) {
    var args = _args;
    var f = _f;
    var init_arity = f.length;
    var arity = init_arity === 0 ? 1 : init_arity;
    var len = args.length;
    var d = arity - len | 0;
    if (d === 0) {
      return f.apply(null, args);
    }
    if (d >= 0) {
      return (function(f,args){
      return function (x) {
        return app(f, args.concat([x]));
      }
      }(f,args));
    }
    _args = caml_array.caml_array_sub(args, arity, -d | 0);
    _f = f.apply(null, caml_array.caml_array_sub(args, 0, arity));
    continue ;
  }}

function _1(o, a0) {
  var arity = o.length;
  if (arity === 1) {
    return o(a0);
  } else {
    switch (arity) {
      case 1 :
          return o(a0);
      case 2 :
          return function (param) {
            return o(a0, param);
          };
      case 3 :
          return function (param, param$1) {
            return o(a0, param, param$1);
          };
      case 4 :
          return function (param, param$1, param$2) {
            return o(a0, param, param$1, param$2);
          };
      case 5 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, param, param$1, param$2, param$3);
          };
      case 6 :
          return function (param, param$1, param$2, param$3, param$4) {
            return o(a0, param, param$1, param$2, param$3, param$4);
          };
      case 7 :
          return function (param, param$1, param$2, param$3, param$4, param$5) {
            return o(a0, param, param$1, param$2, param$3, param$4, param$5);
          };
      default:
        return app(o, [a0]);
    }
  }
}

function __1(o) {
  var arity = o.length;
  if (arity === 1) {
    return o;
  } else {
    return function (a0) {
      return _1(o, a0);
    };
  }
}

function _2(o, a0, a1) {
  var arity = o.length;
  if (arity === 2) {
    return o(a0, a1);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [a1]);
      case 2 :
          return o(a0, a1);
      case 3 :
          return function (param) {
            return o(a0, a1, param);
          };
      case 4 :
          return function (param, param$1) {
            return o(a0, a1, param, param$1);
          };
      case 5 :
          return function (param, param$1, param$2) {
            return o(a0, a1, param, param$1, param$2);
          };
      case 6 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, a1, param, param$1, param$2, param$3);
          };
      case 7 :
          return function (param, param$1, param$2, param$3, param$4) {
            return o(a0, a1, param, param$1, param$2, param$3, param$4);
          };
      default:
        return app(o, [
                    a0,
                    a1
                  ]);
    }
  }
}

function __2(o) {
  var arity = o.length;
  if (arity === 2) {
    return o;
  } else {
    return function (a0, a1) {
      return _2(o, a0, a1);
    };
  }
}

function _3(o, a0, a1, a2) {
  var arity = o.length;
  if (arity === 3) {
    return o(a0, a1, a2);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2
                    ]);
      case 2 :
          return app(o(a0, a1), [a2]);
      case 3 :
          return o(a0, a1, a2);
      case 4 :
          return function (param) {
            return o(a0, a1, a2, param);
          };
      case 5 :
          return function (param, param$1) {
            return o(a0, a1, a2, param, param$1);
          };
      case 6 :
          return function (param, param$1, param$2) {
            return o(a0, a1, a2, param, param$1, param$2);
          };
      case 7 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, a1, a2, param, param$1, param$2, param$3);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2
                  ]);
    }
  }
}

function __3(o) {
  var arity = o.length;
  if (arity === 3) {
    return o;
  } else {
    return function (a0, a1, a2) {
      return _3(o, a0, a1, a2);
    };
  }
}

function _4(o, a0, a1, a2, a3) {
  var arity = o.length;
  if (arity === 4) {
    return o(a0, a1, a2, a3);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [a3]);
      case 4 :
          return o(a0, a1, a2, a3);
      case 5 :
          return function (param) {
            return o(a0, a1, a2, a3, param);
          };
      case 6 :
          return function (param, param$1) {
            return o(a0, a1, a2, a3, param, param$1);
          };
      case 7 :
          return function (param, param$1, param$2) {
            return o(a0, a1, a2, a3, param, param$1, param$2);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3
                  ]);
    }
  }
}

function __4(o) {
  var arity = o.length;
  if (arity === 4) {
    return o;
  } else {
    return function (a0, a1, a2, a3) {
      return _4(o, a0, a1, a2, a3);
    };
  }
}

function _5(o, a0, a1, a2, a3, a4) {
  var arity = o.length;
  if (arity === 5) {
    return o(a0, a1, a2, a3, a4);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [a4]);
      case 5 :
          return o(a0, a1, a2, a3, a4);
      case 6 :
          return function (param) {
            return o(a0, a1, a2, a3, a4, param);
          };
      case 7 :
          return function (param, param$1) {
            return o(a0, a1, a2, a3, a4, param, param$1);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4
                  ]);
    }
  }
}

function __5(o) {
  var arity = o.length;
  if (arity === 5) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4) {
      return _5(o, a0, a1, a2, a3, a4);
    };
  }
}

function _6(o, a0, a1, a2, a3, a4, a5) {
  var arity = o.length;
  if (arity === 6) {
    return o(a0, a1, a2, a3, a4, a5);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [a5]);
      case 6 :
          return o(a0, a1, a2, a3, a4, a5);
      case 7 :
          return function (param) {
            return o(a0, a1, a2, a3, a4, a5, param);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5
                  ]);
    }
  }
}

function __6(o) {
  var arity = o.length;
  if (arity === 6) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5) {
      return _6(o, a0, a1, a2, a3, a4, a5);
    };
  }
}

function _7(o, a0, a1, a2, a3, a4, a5, a6) {
  var arity = o.length;
  if (arity === 7) {
    return o(a0, a1, a2, a3, a4, a5, a6);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5,
                      a6
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [
                      a5,
                      a6
                    ]);
      case 6 :
          return app(o(a0, a1, a2, a3, a4, a5), [a6]);
      case 7 :
          return o(a0, a1, a2, a3, a4, a5, a6);
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6
                  ]);
    }
  }
}

function __7(o) {
  var arity = o.length;
  if (arity === 7) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5, a6) {
      return _7(o, a0, a1, a2, a3, a4, a5, a6);
    };
  }
}

function _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {
  var arity = o.length;
  if (arity === 8) {
    return o(a0, a1, a2, a3, a4, a5, a6, a7);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [
                      a5,
                      a6,
                      a7
                    ]);
      case 6 :
          return app(o(a0, a1, a2, a3, a4, a5), [
                      a6,
                      a7
                    ]);
      case 7 :
          return app(o(a0, a1, a2, a3, a4, a5, a6), [a7]);
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7
                  ]);
    }
  }
}

function __8(o) {
  var arity = o.length;
  if (arity === 8) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5, a6, a7) {
      return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);
    };
  }
}

var app_1 = app;
var _1_1 = _1;
var __1_1 = __1;
var _2_1 = _2;
var __2_1 = __2;
var _3_1 = _3;
var __3_1 = __3;
var _4_1 = _4;
var __4_1 = __4;
var _5_1 = _5;
var __5_1 = __5;
var _6_1 = _6;
var __6_1 = __6;
var _7_1 = _7;
var __7_1 = __7;
var _8_1 = _8;
var __8_1 = __8;
/* No side effect */

var curry = {
	app: app_1,
	_1: _1_1,
	__1: __1_1,
	_2: _2_1,
	__2: __2_1,
	_3: _3_1,
	__3: __3_1,
	_4: _4_1,
	__4: __4_1,
	_5: _5_1,
	__5: __5_1,
	_6: _6_1,
	__6: __6_1,
	_7: _7_1,
	__7: __7_1,
	_8: _8_1,
	__8: __8_1
};

function caml_int_compare(x, y) {
  if (x < y) {
    return -1;
  } else if (x === y) {
    return 0;
  } else {
    return 1;
  }
}

function caml_bool_compare(x, y) {
  if (x) {
    if (y) {
      return 0;
    } else {
      return 1;
    }
  } else if (y) {
    return -1;
  } else {
    return 0;
  }
}

function caml_float_compare(x, y) {
  if (x === y) {
    return 0;
  } else if (x < y) {
    return -1;
  } else if (x > y || x === x) {
    return 1;
  } else if (y === y) {
    return -1;
  } else {
    return 0;
  }
}

function caml_string_compare(s1, s2) {
  if (s1 === s2) {
    return 0;
  } else if (s1 < s2) {
    return -1;
  } else {
    return 1;
  }
}

function caml_bool_min(x, y) {
  if (x) {
    return y;
  } else {
    return x;
  }
}

function caml_int_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_float_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_string_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_nativeint_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_int32_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_bool_max(x, y) {
  if (x) {
    return x;
  } else {
    return y;
  }
}

function caml_int_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_float_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_string_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_nativeint_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_int32_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

var caml_nativeint_compare = caml_int_compare;

var caml_int32_compare = caml_int_compare;

var caml_int_compare_1 = caml_int_compare;
var caml_bool_compare_1 = caml_bool_compare;
var caml_float_compare_1 = caml_float_compare;
var caml_nativeint_compare_1 = caml_nativeint_compare;
var caml_string_compare_1 = caml_string_compare;
var caml_int32_compare_1 = caml_int32_compare;
var caml_bool_min_1 = caml_bool_min;
var caml_int_min_1 = caml_int_min;
var caml_float_min_1 = caml_float_min;
var caml_string_min_1 = caml_string_min;
var caml_nativeint_min_1 = caml_nativeint_min;
var caml_int32_min_1 = caml_int32_min;
var caml_bool_max_1 = caml_bool_max;
var caml_int_max_1 = caml_int_max;
var caml_float_max_1 = caml_float_max;
var caml_string_max_1 = caml_string_max;
var caml_nativeint_max_1 = caml_nativeint_max;
var caml_int32_max_1 = caml_int32_max;
/* No side effect */

var caml_primitive = {
	caml_int_compare: caml_int_compare_1,
	caml_bool_compare: caml_bool_compare_1,
	caml_float_compare: caml_float_compare_1,
	caml_nativeint_compare: caml_nativeint_compare_1,
	caml_string_compare: caml_string_compare_1,
	caml_int32_compare: caml_int32_compare_1,
	caml_bool_min: caml_bool_min_1,
	caml_int_min: caml_int_min_1,
	caml_float_min: caml_float_min_1,
	caml_string_min: caml_string_min_1,
	caml_nativeint_min: caml_nativeint_min_1,
	caml_int32_min: caml_int32_min_1,
	caml_bool_max: caml_bool_max_1,
	caml_int_max: caml_int_max_1,
	caml_float_max: caml_float_max_1,
	caml_string_max: caml_string_max_1,
	caml_nativeint_max: caml_nativeint_max_1,
	caml_int32_max: caml_int32_max_1
};

var for_in = (function(o,foo){
        for (var x in o) { foo(x); }});

var caml_obj_dup = (function(x){
  if(Array.isArray(x)){
    var len = x.length;  
    var v = new Array(len);
    for(var i = 0 ; i < len ; ++i){
      v[i] = x[i];
    }
    if(x.TAG !== undefined){
      v.TAG = x.TAG; // TODO this can be removed eventually
    }  
    return v 
  } 
  return Object.assign({},x)    
});

var update_dummy = (function(x,y){
  var k;  
  if(Array.isArray(y)){
    for(k = 0; k < y.length ; ++k){
      x[k] = y[k];
    }
    if(y.TAG !== undefined){
      x.TAG = y.TAG;
    }
  } else {
    for (var k in y){
      x[k] = y[k];
    }
  }
});

function caml_compare(a, b) {
  if (a === b) {
    return 0;
  }
  var a_type = typeof a;
  var b_type = typeof b;
  switch (a_type) {
    case "boolean" :
        if (b_type === "boolean") {
          return caml_primitive.caml_bool_compare(a, b);
        }
        break;
    case "function" :
        if (b_type === "function") {
          throw {
                RE_EXN_ID: "Invalid_argument",
                _1: "compare: functional value",
                Error: new Error()
              };
        }
        break;
    case "number" :
        if (b_type === "number") {
          return caml_primitive.caml_int_compare(a, b);
        }
        break;
    case "string" :
        if (b_type === "string") {
          return caml_primitive.caml_string_compare(a, b);
        } else {
          return 1;
        }
    case "undefined" :
        return -1;
      
  }
  switch (b_type) {
    case "string" :
        return -1;
    case "undefined" :
        return 1;
    default:
      if (a_type === "boolean") {
        return 1;
      }
      if (b_type === "boolean") {
        return -1;
      }
      if (a_type === "function") {
        return 1;
      }
      if (b_type === "function") {
        return -1;
      }
      if (a_type === "number") {
        if (b === null || b.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return 1;
        } else {
          return -1;
        }
      }
      if (b_type === "number") {
        if (a === null || a.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return -1;
        } else {
          return 1;
        }
      }
      if (a === null) {
        if (b.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return 1;
        } else {
          return -1;
        }
      }
      if (b === null) {
        if (a.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return -1;
        } else {
          return 1;
        }
      }
      if (a.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
        if (b.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return aux_obj_compare(a, b);
        } else {
          return -1;
        }
      }
      var tag_a = a.TAG | 0;
      var tag_b = b.TAG | 0;
      if (tag_a === 248) {
        return caml_primitive.caml_int_compare(a[1], b[1]);
      }
      if (tag_a === 251) {
        throw {
              RE_EXN_ID: "Invalid_argument",
              _1: "equal: abstract value",
              Error: new Error()
            };
      }
      if (tag_a !== tag_b) {
        if (tag_a < tag_b) {
          return -1;
        } else {
          return 1;
        }
      }
      var len_a = a.length | 0;
      var len_b = b.length | 0;
      if (len_a === len_b) {
        if (Array.isArray(a)) {
          var _i = 0;
          while(true) {
            var i = _i;
            if (i === len_a) {
              return 0;
            }
            var res = caml_compare(a[i], b[i]);
            if (res !== 0) {
              return res;
            }
            _i = i + 1 | 0;
            continue ;
          }        } else if ((a instanceof Date && b instanceof Date)) {
          return (a - b);
        } else {
          return aux_obj_compare(a, b);
        }
      } else if (len_a < len_b) {
        var _i$1 = 0;
        while(true) {
          var i$1 = _i$1;
          if (i$1 === len_a) {
            return -1;
          }
          var res$1 = caml_compare(a[i$1], b[i$1]);
          if (res$1 !== 0) {
            return res$1;
          }
          _i$1 = i$1 + 1 | 0;
          continue ;
        }      } else {
        var _i$2 = 0;
        while(true) {
          var i$2 = _i$2;
          if (i$2 === len_b) {
            return 1;
          }
          var res$2 = caml_compare(a[i$2], b[i$2]);
          if (res$2 !== 0) {
            return res$2;
          }
          _i$2 = i$2 + 1 | 0;
          continue ;
        }      }
  }
}

function aux_obj_compare(a, b) {
  var min_key_lhs = {
    contents: undefined
  };
  var min_key_rhs = {
    contents: undefined
  };
  var do_key = function (param, key) {
    var min_key = param[2];
    var b = param[1];
    if (!(!b.hasOwnProperty(key) || caml_compare(param[0][key], b[key]) > 0)) {
      return ;
    }
    var mk = min_key.contents;
    if (mk !== undefined && key >= mk) {
      return ;
    } else {
      min_key.contents = key;
      return ;
    }
  };
  var partial_arg = [
    a,
    b,
    min_key_rhs
  ];
  var do_key_a = function (param) {
    return do_key(partial_arg, param);
  };
  var partial_arg$1 = [
    b,
    a,
    min_key_lhs
  ];
  var do_key_b = function (param) {
    return do_key(partial_arg$1, param);
  };
  for_in(a, do_key_a);
  for_in(b, do_key_b);
  var match = min_key_lhs.contents;
  var match$1 = min_key_rhs.contents;
  if (match !== undefined) {
    if (match$1 !== undefined) {
      return caml_primitive.caml_string_compare(match, match$1);
    } else {
      return -1;
    }
  } else if (match$1 !== undefined) {
    return 1;
  } else {
    return 0;
  }
}

function caml_equal(a, b) {
  if (a === b) {
    return true;
  }
  var a_type = typeof a;
  if (a_type === "string" || a_type === "number" || a_type === "boolean" || a_type === "undefined" || a === null) {
    return false;
  }
  var b_type = typeof b;
  if (a_type === "function" || b_type === "function") {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "equal: functional value",
          Error: new Error()
        };
  }
  if (b_type === "number" || b_type === "undefined" || b === null) {
    return false;
  }
  var tag_a = a.TAG | 0;
  var tag_b = b.TAG | 0;
  if (tag_a === 248) {
    return a[1] === b[1];
  }
  if (tag_a === 251) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "equal: abstract value",
          Error: new Error()
        };
  }
  if (tag_a !== tag_b) {
    return false;
  }
  var len_a = a.length | 0;
  var len_b = b.length | 0;
  if (len_a === len_b) {
    if (Array.isArray(a)) {
      var _i = 0;
      while(true) {
        var i = _i;
        if (i === len_a) {
          return true;
        }
        if (!caml_equal(a[i], b[i])) {
          return false;
        }
        _i = i + 1 | 0;
        continue ;
      }    } else if ((a instanceof Date && b instanceof Date)) {
      return !(a > b || a < b);
    } else {
      var result = {
        contents: true
      };
      var do_key_a = function (key) {
        if (!b.hasOwnProperty(key)) {
          result.contents = false;
          return ;
        }
        
      };
      var do_key_b = function (key) {
        if (!a.hasOwnProperty(key) || !caml_equal(b[key], a[key])) {
          result.contents = false;
          return ;
        }
        
      };
      for_in(a, do_key_a);
      if (result.contents) {
        for_in(b, do_key_b);
      }
      return result.contents;
    }
  } else {
    return false;
  }
}

function caml_equal_null(x, y) {
  if (y !== null) {
    return caml_equal(x, y);
  } else {
    return x === y;
  }
}

function caml_equal_undefined(x, y) {
  if (y !== undefined) {
    return caml_equal(x, y);
  } else {
    return x === y;
  }
}

function caml_equal_nullable(x, y) {
  if (y == null) {
    return x === y;
  } else {
    return caml_equal(x, y);
  }
}

function caml_notequal(a, b) {
  return !caml_equal(a, b);
}

function caml_greaterequal(a, b) {
  return caml_compare(a, b) >= 0;
}

function caml_greaterthan(a, b) {
  return caml_compare(a, b) > 0;
}

function caml_lessequal(a, b) {
  return caml_compare(a, b) <= 0;
}

function caml_lessthan(a, b) {
  return caml_compare(a, b) < 0;
}

function caml_min(x, y) {
  if (caml_compare(x, y) <= 0) {
    return x;
  } else {
    return y;
  }
}

function caml_max(x, y) {
  if (caml_compare(x, y) >= 0) {
    return x;
  } else {
    return y;
  }
}

var caml_obj_dup_1 = caml_obj_dup;
var update_dummy_1 = update_dummy;
var caml_compare_1 = caml_compare;
var caml_equal_1 = caml_equal;
var caml_equal_null_1 = caml_equal_null;
var caml_equal_undefined_1 = caml_equal_undefined;
var caml_equal_nullable_1 = caml_equal_nullable;
var caml_notequal_1 = caml_notequal;
var caml_greaterequal_1 = caml_greaterequal;
var caml_greaterthan_1 = caml_greaterthan;
var caml_lessthan_1 = caml_lessthan;
var caml_lessequal_1 = caml_lessequal;
var caml_min_1 = caml_min;
var caml_max_1 = caml_max;
/* No side effect */

var caml_obj = {
	caml_obj_dup: caml_obj_dup_1,
	update_dummy: update_dummy_1,
	caml_compare: caml_compare_1,
	caml_equal: caml_equal_1,
	caml_equal_null: caml_equal_null_1,
	caml_equal_undefined: caml_equal_undefined_1,
	caml_equal_nullable: caml_equal_nullable_1,
	caml_notequal: caml_notequal_1,
	caml_greaterequal: caml_greaterequal_1,
	caml_greaterthan: caml_greaterthan_1,
	caml_lessthan: caml_lessthan_1,
	caml_lessequal: caml_lessequal_1,
	caml_min: caml_min_1,
	caml_max: caml_max_1
};

var stdout = {
  buffer: "",
  output: (function (param, s) {
      var v = s.length - 1 | 0;
      if (((typeof process !== "undefined") && process.stdout && process.stdout.write)) {
        return process.stdout.write(s);
      } else {
        if (s[v] === "\n") {
          console.log(s.slice(0, v));
        } else {
          console.log(s);
        }
        return ;
      }
    })
};

var stderr = {
  buffer: "",
  output: (function (param, s) {
      var v = s.length - 1 | 0;
      if (s[v] === "\n") {
        console.log(s.slice(0, v));
      } else {
        console.log(s);
      }
      
    })
};

function caml_ml_flush(oc) {
  if (oc.buffer !== "") {
    oc.output(oc, oc.buffer);
    oc.buffer = "";
    return ;
  }
  
}

function caml_ml_output(oc, str, offset, len) {
  var str$1 = offset === 0 && len === str.length ? str : str.slice(offset, len);
  if (((typeof process !== "undefined") && process.stdout && process.stdout.write) && oc === stdout) {
    return process.stdout.write(str$1);
  }
  var id = str$1.lastIndexOf("\n");
  if (id < 0) {
    oc.buffer = oc.buffer + str$1;
  } else {
    oc.buffer = oc.buffer + str$1.slice(0, id + 1 | 0);
    caml_ml_flush(oc);
    oc.buffer = oc.buffer + str$1.slice(id + 1 | 0);
  }
  
}

function caml_ml_output_char(oc, $$char) {
  return caml_ml_output(oc, String.fromCharCode($$char), 0, 1);
}

function caml_ml_out_channels_list(param) {
  return {
          hd: stdout,
          tl: {
            hd: stderr,
            tl: /* [] */0
          }
        };
}

var stdin;

var stdin_1 = stdin;
var stdout_1 = stdout;
var stderr_1 = stderr;
var caml_ml_flush_1 = caml_ml_flush;
var caml_ml_output_1 = caml_ml_output;
var caml_ml_output_char_1 = caml_ml_output_char;
var caml_ml_out_channels_list_1 = caml_ml_out_channels_list;
/* No side effect */

var caml_io = {
	stdin: stdin_1,
	stdout: stdout_1,
	stderr: stderr_1,
	caml_ml_flush: caml_ml_flush_1,
	caml_ml_output: caml_ml_output_1,
	caml_ml_output_char: caml_ml_output_char_1,
	caml_ml_out_channels_list: caml_ml_out_channels_list_1
};

function caml_sys_getenv(s) {
  if (typeof process === "undefined" || process.env === undefined) {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  var x = process.env[s];
  if (x !== undefined) {
    return x;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

var os_type = (function(_){
  if(typeof process !== 'undefined' && process.platform === 'win32'){
        return "Win32"    
  }
  else {
    return "Unix"
  }
});

function caml_sys_time(param) {
  if (typeof process === "undefined" || process.uptime === undefined) {
    return -1;
  } else {
    return process.uptime();
  }
}

function caml_sys_system_command(_cmd) {
  return 127;
}

var caml_sys_getcwd = (function(param){
    if (typeof process === "undefined" || process.cwd === undefined){
      return "/"  
    }
    return process.cwd()
  });

function caml_sys_get_argv(param) {
  if (typeof process === "undefined") {
    return [
            "",
            [""]
          ];
  }
  var argv = process.argv;
  if (argv == null) {
    return [
            "",
            [""]
          ];
  } else {
    return [
            argv[0],
            argv
          ];
  }
}

function caml_sys_exit(exit_code) {
  if (typeof process !== "undefined") {
    return process.exit(exit_code);
  }
  
}

function caml_sys_is_directory(_s) {
  throw {
        RE_EXN_ID: "Failure",
        _1: "caml_sys_is_directory not implemented",
        Error: new Error()
      };
}

function caml_sys_file_exists(_s) {
  throw {
        RE_EXN_ID: "Failure",
        _1: "caml_sys_file_exists not implemented",
        Error: new Error()
      };
}

var caml_sys_getenv_1 = caml_sys_getenv;
var caml_sys_time_1 = caml_sys_time;
var os_type_1 = os_type;
var caml_sys_system_command_1 = caml_sys_system_command;
var caml_sys_getcwd_1 = caml_sys_getcwd;
var caml_sys_get_argv_1 = caml_sys_get_argv;
var caml_sys_exit_1 = caml_sys_exit;
var caml_sys_is_directory_1 = caml_sys_is_directory;
var caml_sys_file_exists_1 = caml_sys_file_exists;
/* No side effect */

var caml_sys = {
	caml_sys_getenv: caml_sys_getenv_1,
	caml_sys_time: caml_sys_time_1,
	os_type: os_type_1,
	caml_sys_system_command: caml_sys_system_command_1,
	caml_sys_getcwd: caml_sys_getcwd_1,
	caml_sys_get_argv: caml_sys_get_argv_1,
	caml_sys_exit: caml_sys_exit_1,
	caml_sys_is_directory: caml_sys_is_directory_1,
	caml_sys_file_exists: caml_sys_file_exists_1
};

function set$1(s, i, ch) {
  if (i < 0 || i >= s.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  s[i] = ch;
  
}

function get$1(s, i) {
  if (i < 0 || i >= s.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  return s[i];
}

function caml_fill_bytes(s, i, l, c) {
  if (l <= 0) {
    return ;
  }
  for(var k = i ,k_finish = l + i | 0; k < k_finish; ++k){
    s[k] = c;
  }
  
}

function caml_create_bytes(len) {
  if (len < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.create",
          Error: new Error()
        };
  }
  var result = new Array(len);
  for(var i = 0; i < len; ++i){
    result[i] = /* "\000" */0;
  }
  return result;
}

function caml_blit_bytes(s1, i1, s2, i2, len) {
  if (len <= 0) {
    return ;
  }
  if (s1 === s2) {
    if (i1 < i2) {
      var range_a = (s1.length - i2 | 0) - 1 | 0;
      var range_b = len - 1 | 0;
      var range = range_a > range_b ? range_b : range_a;
      for(var j = range; j >= 0; --j){
        s1[i2 + j | 0] = s1[i1 + j | 0];
      }
      return ;
    }
    if (i1 <= i2) {
      return ;
    }
    var range_a$1 = (s1.length - i1 | 0) - 1 | 0;
    var range_b$1 = len - 1 | 0;
    var range$1 = range_a$1 > range_b$1 ? range_b$1 : range_a$1;
    for(var k = 0; k <= range$1; ++k){
      s1[i2 + k | 0] = s1[i1 + k | 0];
    }
    return ;
  }
  var off1 = s1.length - i1 | 0;
  if (len <= off1) {
    for(var i = 0; i < len; ++i){
      s2[i2 + i | 0] = s1[i1 + i | 0];
    }
    return ;
  }
  for(var i$1 = 0; i$1 < off1; ++i$1){
    s2[i2 + i$1 | 0] = s1[i1 + i$1 | 0];
  }
  for(var i$2 = off1; i$2 < len; ++i$2){
    s2[i2 + i$2 | 0] = /* "\000" */0;
  }
  
}

function bytes_to_string(a) {
  var len = a.length;
  var s = "";
  var s_len = len;
  if ( len <= 4096 && len === a.length) {
    return String.fromCharCode.apply(null, a);
  }
  var offset = 0;
  while(s_len > 0) {
    var next = s_len < 1024 ? s_len : 1024;
    var tmp_bytes = new Array(next);
    for(var k = 0; k < next; ++k){
      tmp_bytes[k] = a[k + offset | 0];
    }
    s = s + String.fromCharCode.apply(null, tmp_bytes);
    s_len = s_len - next | 0;
    offset = offset + next | 0;
  }  return s;
}

function caml_blit_string(s1, i1, s2, i2, len) {
  if (len <= 0) {
    return ;
  }
  var off1 = s1.length - i1 | 0;
  if (len <= off1) {
    for(var i = 0; i < len; ++i){
      s2[i2 + i | 0] = s1.charCodeAt(i1 + i | 0);
    }
    return ;
  }
  for(var i$1 = 0; i$1 < off1; ++i$1){
    s2[i2 + i$1 | 0] = s1.charCodeAt(i1 + i$1 | 0);
  }
  for(var i$2 = off1; i$2 < len; ++i$2){
    s2[i2 + i$2 | 0] = /* "\000" */0;
  }
  
}

function bytes_of_string(s) {
  var len = s.length;
  var res = new Array(len);
  for(var i = 0; i < len; ++i){
    res[i] = s.charCodeAt(i);
  }
  return res;
}

function caml_bytes_compare_aux(s1, s2, _off, len, def) {
  while(true) {
    var off = _off;
    if (off >= len) {
      return def;
    }
    var a = s1[off];
    var b = s2[off];
    if (a > b) {
      return 1;
    }
    if (a < b) {
      return -1;
    }
    _off = off + 1 | 0;
    continue ;
  }}

function caml_bytes_compare(s1, s2) {
  var len1 = s1.length;
  var len2 = s2.length;
  if (len1 === len2) {
    return caml_bytes_compare_aux(s1, s2, 0, len1, 0);
  } else if (len1 < len2) {
    return caml_bytes_compare_aux(s1, s2, 0, len1, -1);
  } else {
    return caml_bytes_compare_aux(s1, s2, 0, len2, 1);
  }
}

function caml_bytes_equal(s1, s2) {
  var len1 = s1.length;
  var len2 = s2.length;
  if (len1 === len2) {
    var _off = 0;
    while(true) {
      var off = _off;
      if (off === len1) {
        return true;
      }
      var a = s1[off];
      var b = s2[off];
      if (a !== b) {
        return false;
      }
      _off = off + 1 | 0;
      continue ;
    }  } else {
    return false;
  }
}

function caml_bytes_greaterthan(s1, s2) {
  return caml_bytes_compare(s1, s2) > 0;
}

function caml_bytes_greaterequal(s1, s2) {
  return caml_bytes_compare(s1, s2) >= 0;
}

function caml_bytes_lessthan(s1, s2) {
  return caml_bytes_compare(s1, s2) < 0;
}

function caml_bytes_lessequal(s1, s2) {
  return caml_bytes_compare(s1, s2) <= 0;
}

var caml_create_bytes_1 = caml_create_bytes;
var caml_fill_bytes_1 = caml_fill_bytes;
var get_1$1 = get$1;
var set_1$1 = set$1;
var bytes_to_string_1 = bytes_to_string;
var caml_blit_bytes_1 = caml_blit_bytes;
var caml_blit_string_1 = caml_blit_string;
var bytes_of_string_1 = bytes_of_string;
var caml_bytes_compare_1 = caml_bytes_compare;
var caml_bytes_greaterthan_1 = caml_bytes_greaterthan;
var caml_bytes_greaterequal_1 = caml_bytes_greaterequal;
var caml_bytes_lessthan_1 = caml_bytes_lessthan;
var caml_bytes_lessequal_1 = caml_bytes_lessequal;
var caml_bytes_equal_1 = caml_bytes_equal;
/* No side effect */

var caml_bytes = {
	caml_create_bytes: caml_create_bytes_1,
	caml_fill_bytes: caml_fill_bytes_1,
	get: get_1$1,
	set: set_1$1,
	bytes_to_string: bytes_to_string_1,
	caml_blit_bytes: caml_blit_bytes_1,
	caml_blit_string: caml_blit_string_1,
	bytes_of_string: bytes_of_string_1,
	caml_bytes_compare: caml_bytes_compare_1,
	caml_bytes_greaterthan: caml_bytes_greaterthan_1,
	caml_bytes_greaterequal: caml_bytes_greaterequal_1,
	caml_bytes_lessthan: caml_bytes_lessthan_1,
	caml_bytes_lessequal: caml_bytes_lessequal_1,
	caml_bytes_equal: caml_bytes_equal_1
};

function mk(lo, hi) {
  return [
          hi,
          (lo >>> 0)
        ];
}

var min_int = [
  -2147483648,
  0
];

var max_int = [
  2147483647,
  4294967295
];

var one = [
  0,
  1
];

var zero = [
  0,
  0
];

var neg_one = [
  -1,
  4294967295
];

function neg_signed(x) {
  return (x & 2147483648) !== 0;
}

function non_neg_signed(x) {
  return (x & 2147483648) === 0;
}

function succ(param) {
  var x_lo = param[1];
  var x_hi = param[0];
  var lo = x_lo + 1 | 0;
  return mk(lo, x_hi + (
              lo === 0 ? 1 : 0
            ) | 0);
}

function neg(param) {
  var other_lo = (param[1] ^ -1) + 1 | 0;
  return mk(other_lo, (param[0] ^ -1) + (
              other_lo === 0 ? 1 : 0
            ) | 0);
}

function add_aux(param, y_lo, y_hi) {
  var x_lo = param[1];
  var lo = x_lo + y_lo | 0;
  var overflow = neg_signed(x_lo) && (neg_signed(y_lo) || non_neg_signed(lo)) || neg_signed(y_lo) && non_neg_signed(lo) ? 1 : 0;
  return mk(lo, param[0] + y_hi + overflow | 0);
}

function add(self, param) {
  return add_aux(self, param[1], param[0]);
}

function eq(x, y) {
  if (x[0] === y[0]) {
    return x[1] === y[1];
  } else {
    return false;
  }
}

function equal_null(x, y) {
  if (y !== null) {
    return eq(x, y);
  } else {
    return false;
  }
}

function equal_undefined(x, y) {
  if (y !== undefined) {
    return eq(x, y);
  } else {
    return false;
  }
}

function equal_nullable(x, y) {
  if (y == null) {
    return false;
  } else {
    return eq(x, y);
  }
}

function sub_aux(x, lo, hi) {
  var y_lo = ((lo ^ -1) + 1 >>> 0);
  var y_hi = (hi ^ -1) + (
    y_lo === 0 ? 1 : 0
  ) | 0;
  return add_aux(x, y_lo, y_hi);
}

function sub(self, param) {
  return sub_aux(self, param[1], param[0]);
}

function lsl_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  var lo = x[1];
  if (numBits >= 32) {
    return mk(0, (lo << (numBits - 32 | 0)));
  } else {
    return mk((lo << numBits), (lo >>> (32 - numBits | 0)) | (x[0] << numBits));
  }
}

function lsr_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  var hi = x[0];
  var offset = numBits - 32 | 0;
  if (offset === 0) {
    return mk(hi, 0);
  } else if (offset > 0) {
    return mk((hi >>> offset), 0);
  } else {
    return mk((hi << (-offset | 0)) | (x[1] >>> numBits), (hi >>> numBits));
  }
}

function asr_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  var hi = x[0];
  if (numBits < 32) {
    return mk((hi << (32 - numBits | 0)) | (x[1] >>> numBits), (hi >> numBits));
  } else {
    return mk((hi >> (numBits - 32 | 0)), hi >= 0 ? 0 : -1);
  }
}

function is_zero(param) {
  if (param[0] !== 0 || param[1] !== 0) {
    return false;
  } else {
    return true;
  }
}

function mul(_this, _other) {
  while(true) {
    var other = _other;
    var $$this = _this;
    var lo;
    var this_hi = $$this[0];
    var exit = 0;
    var exit$1 = 0;
    var exit$2 = 0;
    if (this_hi !== 0) {
      exit$2 = 4;
    } else {
      if ($$this[1] === 0) {
        return zero;
      }
      exit$2 = 4;
    }
    if (exit$2 === 4) {
      if (other[0] !== 0) {
        exit$1 = 3;
      } else {
        if (other[1] === 0) {
          return zero;
        }
        exit$1 = 3;
      }
    }
    if (exit$1 === 3) {
      if (this_hi !== -2147483648 || $$this[1] !== 0) {
        exit = 2;
      } else {
        lo = other[1];
      }
    }
    if (exit === 2) {
      var other_hi = other[0];
      var lo$1 = $$this[1];
      var exit$3 = 0;
      if (other_hi !== -2147483648 || other[1] !== 0) {
        exit$3 = 3;
      } else {
        lo = lo$1;
      }
      if (exit$3 === 3) {
        var other_lo = other[1];
        if (this_hi < 0) {
          if (other_hi >= 0) {
            return neg(mul(neg($$this), other));
          }
          _other = neg(other);
          _this = neg($$this);
          continue ;
        }
        if (other_hi < 0) {
          return neg(mul($$this, neg(other)));
        }
        var a48 = (this_hi >>> 16);
        var a32 = this_hi & 65535;
        var a16 = (lo$1 >>> 16);
        var a00 = lo$1 & 65535;
        var b48 = (other_hi >>> 16);
        var b32 = other_hi & 65535;
        var b16 = (other_lo >>> 16);
        var b00 = other_lo & 65535;
        var c48 = 0;
        var c32 = 0;
        var c16 = 0;
        var c00 = a00 * b00;
        c16 = (c00 >>> 16) + a16 * b00;
        c32 = (c16 >>> 16);
        c16 = (c16 & 65535) + a00 * b16;
        c32 = c32 + (c16 >>> 16) + a32 * b00;
        c48 = (c32 >>> 16);
        c32 = (c32 & 65535) + a16 * b16;
        c48 = c48 + (c32 >>> 16);
        c32 = (c32 & 65535) + a00 * b32;
        c48 = c48 + (c32 >>> 16);
        c32 = c32 & 65535;
        c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;
        return mk(c00 & 65535 | ((c16 & 65535) << 16), c32 | (c48 << 16));
      }
      
    }
    if ((lo & 1) === 0) {
      return zero;
    } else {
      return min_int;
    }
  }}

function xor(param, param$1) {
  return mk(param[1] ^ param$1[1], param[0] ^ param$1[0]);
}

function or_(param, param$1) {
  return mk(param[1] | param$1[1], param[0] | param$1[0]);
}

function and_(param, param$1) {
  return mk(param[1] & param$1[1], param[0] & param$1[0]);
}

function ge(param, param$1) {
  var other_hi = param$1[0];
  var hi = param[0];
  if (hi > other_hi) {
    return true;
  } else if (hi < other_hi) {
    return false;
  } else {
    return param[1] >= param$1[1];
  }
}

function neq(x, y) {
  return !eq(x, y);
}

function lt(x, y) {
  return !ge(x, y);
}

function gt(x, y) {
  if (x[0] > y[0]) {
    return true;
  } else if (x[0] < y[0]) {
    return false;
  } else {
    return x[1] > y[1];
  }
}

function le(x, y) {
  return !gt(x, y);
}

function min(x, y) {
  if (ge(x, y)) {
    return y;
  } else {
    return x;
  }
}

function max(x, y) {
  if (gt(x, y)) {
    return x;
  } else {
    return y;
  }
}

function to_float(param) {
  return param[0] * 0x100000000 + param[1];
}

function of_float(x) {
  if (isNaN(x) || !isFinite(x)) {
    return zero;
  } else if (x <= -9.22337203685477581e+18) {
    return min_int;
  } else if (x + 1 >= 9.22337203685477581e+18) {
    return max_int;
  } else if (x < 0) {
    return neg(of_float(-x));
  } else {
    return mk(x % 4294967296 | 0, x / 4294967296 | 0);
  }
}

function isSafeInteger(param) {
  var hi = param[0];
  var top11Bits = (hi >> 21);
  if (top11Bits === 0) {
    return true;
  } else if (top11Bits === -1) {
    return !(param[1] === 0 && hi === (4292870144 | 0));
  } else {
    return false;
  }
}

function to_string(self) {
  if (isSafeInteger(self)) {
    return String(to_float(self));
  }
  if (self[0] < 0) {
    if (eq(self, min_int)) {
      return "-9223372036854775808";
    } else {
      return "-" + to_string(neg(self));
    }
  }
  var approx_div1 = of_float(Math.floor(to_float(self) / 10));
  var lo = approx_div1[1];
  var hi = approx_div1[0];
  var match = sub_aux(sub_aux(self, (lo << 3), (lo >>> 29) | (hi << 3)), (lo << 1), (lo >>> 31) | (hi << 1));
  var rem_lo = match[1];
  var rem_hi = match[0];
  if (rem_lo === 0 && rem_hi === 0) {
    return to_string(approx_div1) + "0";
  }
  if (rem_hi < 0) {
    var rem_lo$1 = ((rem_lo ^ -1) + 1 >>> 0);
    var delta = Math.ceil(rem_lo$1 / 10);
    var remainder = 10 * delta - rem_lo$1;
    return to_string(sub_aux(approx_div1, delta | 0, 0)) + String(remainder | 0);
  }
  var rem_lo$2 = rem_lo;
  var delta$1 = Math.floor(rem_lo$2 / 10);
  var remainder$1 = rem_lo$2 - 10 * delta$1;
  return to_string(add_aux(approx_div1, delta$1 | 0, 0)) + String(remainder$1 | 0);
}

function div(_self, _other) {
  while(true) {
    var other = _other;
    var self = _self;
    var self_hi = self[0];
    var exit = 0;
    var exit$1 = 0;
    if (other[0] !== 0 || other[1] !== 0) {
      exit$1 = 2;
    } else {
      throw {
            RE_EXN_ID: "Division_by_zero",
            Error: new Error()
          };
    }
    if (exit$1 === 2) {
      if (self_hi !== -2147483648) {
        if (self_hi !== 0) {
          exit = 1;
        } else {
          if (self[1] === 0) {
            return zero;
          }
          exit = 1;
        }
      } else if (self[1] !== 0) {
        exit = 1;
      } else {
        if (eq(other, one) || eq(other, neg_one)) {
          return self;
        }
        if (eq(other, min_int)) {
          return one;
        }
        var half_this = asr_(self, 1);
        var approx = lsl_(div(half_this, other), 1);
        var exit$2 = 0;
        if (approx[0] !== 0) {
          exit$2 = 3;
        } else {
          if (approx[1] === 0) {
            if (other[0] < 0) {
              return one;
            } else {
              return neg(one);
            }
          }
          exit$2 = 3;
        }
        if (exit$2 === 3) {
          var rem = sub(self, mul(other, approx));
          return add(approx, div(rem, other));
        }
        
      }
    }
    if (exit === 1) {
      var other_hi = other[0];
      var exit$3 = 0;
      if (other_hi !== -2147483648) {
        exit$3 = 2;
      } else {
        if (other[1] === 0) {
          return zero;
        }
        exit$3 = 2;
      }
      if (exit$3 === 2) {
        if (self_hi < 0) {
          if (other_hi >= 0) {
            return neg(div(neg(self), other));
          }
          _other = neg(other);
          _self = neg(self);
          continue ;
        }
        if (other_hi < 0) {
          return neg(div(self, neg(other)));
        }
        var res = zero;
        var rem$1 = self;
        while(ge(rem$1, other)) {
          var approx$1 = caml_primitive.caml_float_max(1, Math.floor(to_float(rem$1) / to_float(other)));
          var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);
          var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
          var approxRes = of_float(approx$1);
          var approxRem = mul(approxRes, other);
          while(approxRem[0] < 0 || gt(approxRem, rem$1)) {
            approx$1 = approx$1 - delta;
            approxRes = of_float(approx$1);
            approxRem = mul(approxRes, other);
          }          if (is_zero(approxRes)) {
            approxRes = one;
          }
          res = add(res, approxRes);
          rem$1 = sub(rem$1, approxRem);
        }        return res;
      }
      
    }
    
  }}

function mod_(self, other) {
  return sub(self, mul(div(self, other), other));
}

function div_mod(self, other) {
  var quotient = div(self, other);
  return [
          quotient,
          sub(self, mul(quotient, other))
        ];
}

function compare(self, other) {
  var v = caml_primitive.caml_nativeint_compare(self[0], other[0]);
  if (v === 0) {
    return caml_primitive.caml_nativeint_compare(self[1], other[1]);
  } else {
    return v;
  }
}

function of_int32(lo) {
  return mk(lo, lo < 0 ? -1 : 0);
}

function to_int32(x) {
  return x[1] | 0;
}

function to_hex(x) {
  var x_lo = x[1];
  var x_hi = x[0];
  var aux = function (v) {
    return (v >>> 0).toString(16);
  };
  if (x_hi === 0 && x_lo === 0) {
    return "0";
  }
  if (x_lo === 0) {
    return aux(x_hi) + "00000000";
  }
  if (x_hi === 0) {
    return aux(x_lo);
  }
  var lo = aux(x_lo);
  var pad = 8 - lo.length | 0;
  if (pad <= 0) {
    return aux(x_hi) + lo;
  } else {
    return aux(x_hi) + ("0".repeat(pad) + lo);
  }
}

function discard_sign(x) {
  return [
          2147483647 & x[0],
          x[1]
        ];
}

function float_of_bits(x) {
  return (function(lo,hi){ return (new Float64Array(new Int32Array([lo,hi]).buffer))[0]})(x[1], x[0]);
}

function bits_of_float(x) {
  var match = (function(x){return new Int32Array(new Float64Array([x]).buffer)})(x);
  return mk(match[0], match[1]);
}

var mk_1 = mk;
var succ_1 = succ;
var min_int_1 = min_int;
var max_int_1 = max_int;
var one_1 = one;
var zero_1 = zero;
var neg_one_1 = neg_one;
var of_int32_1 = of_int32;
var to_int32_1 = to_int32;
var add_1 = add;
var neg_1 = neg;
var sub_1 = sub;
var lsl__1 = lsl_;
var lsr__1 = lsr_;
var asr__1 = asr_;
var is_zero_1 = is_zero;
var mul_1 = mul;
var xor_1 = xor;
var or__1 = or_;
var and__1 = and_;
var ge_1 = ge;
var eq_1 = eq;
var neq_1 = neq;
var lt_1 = lt;
var gt_1 = gt;
var le_1 = le;
var equal_null_1 = equal_null;
var equal_undefined_1 = equal_undefined;
var equal_nullable_1 = equal_nullable;
var min_1 = min;
var max_1 = max;
var to_float_1 = to_float;
var of_float_1 = of_float;
var div_1 = div;
var mod__1 = mod_;
var compare_1 = compare;
var float_of_bits_1 = float_of_bits;
var bits_of_float_1 = bits_of_float;
var div_mod_1 = div_mod;
var to_hex_1 = to_hex;
var discard_sign_1 = discard_sign;
var to_string_1 = to_string;
/* No side effect */

var caml_int64 = {
	mk: mk_1,
	succ: succ_1,
	min_int: min_int_1,
	max_int: max_int_1,
	one: one_1,
	zero: zero_1,
	neg_one: neg_one_1,
	of_int32: of_int32_1,
	to_int32: to_int32_1,
	add: add_1,
	neg: neg_1,
	sub: sub_1,
	lsl_: lsl__1,
	lsr_: lsr__1,
	asr_: asr__1,
	is_zero: is_zero_1,
	mul: mul_1,
	xor: xor_1,
	or_: or__1,
	and_: and__1,
	ge: ge_1,
	eq: eq_1,
	neq: neq_1,
	lt: lt_1,
	gt: gt_1,
	le: le_1,
	equal_null: equal_null_1,
	equal_undefined: equal_undefined_1,
	equal_nullable: equal_nullable_1,
	min: min_1,
	max: max_1,
	to_float: to_float_1,
	of_float: of_float_1,
	div: div_1,
	mod_: mod__1,
	compare: compare_1,
	float_of_bits: float_of_bits_1,
	bits_of_float: bits_of_float_1,
	div_mod: div_mod_1,
	to_hex: to_hex_1,
	discard_sign: discard_sign_1,
	to_string: to_string_1
};

function parse_digit(c) {
  if (c >= 65) {
    if (c >= 97) {
      if (c >= 123) {
        return -1;
      } else {
        return c - 87 | 0;
      }
    } else if (c >= 91) {
      return -1;
    } else {
      return c - 55 | 0;
    }
  } else if (c > 57 || c < 48) {
    return -1;
  } else {
    return c - /* "0" */48 | 0;
  }
}

function int_of_string_base(param) {
  switch (param) {
    case /* Oct */0 :
        return 8;
    case /* Hex */1 :
        return 16;
    case /* Dec */2 :
        return 10;
    case /* Bin */3 :
        return 2;
    
  }
}

function parse_sign_and_base(s) {
  var sign = 1;
  var base = /* Dec */2;
  var i = 0;
  var match = s.charCodeAt(i);
  switch (match) {
    case 43 :
        i = i + 1 | 0;
        break;
    case 44 :
        break;
    case 45 :
        sign = -1;
        i = i + 1 | 0;
        break;
      
  }
  if (s[i] === "0") {
    var match$1 = s.charCodeAt(i + 1 | 0);
    if (match$1 >= 89) {
      if (match$1 >= 111) {
        if (match$1 < 121) {
          switch (match$1 - 111 | 0) {
            case 0 :
                base = /* Oct */0;
                i = i + 2 | 0;
                break;
            case 6 :
                i = i + 2 | 0;
                break;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 7 :
            case 8 :
                break;
            case 9 :
                base = /* Hex */1;
                i = i + 2 | 0;
                break;
            
          }
        }
        
      } else if (match$1 === 98) {
        base = /* Bin */3;
        i = i + 2 | 0;
      }
      
    } else if (match$1 !== 66) {
      if (match$1 >= 79) {
        switch (match$1 - 79 | 0) {
          case 0 :
              base = /* Oct */0;
              i = i + 2 | 0;
              break;
          case 6 :
              i = i + 2 | 0;
              break;
          case 1 :
          case 2 :
          case 3 :
          case 4 :
          case 5 :
          case 7 :
          case 8 :
              break;
          case 9 :
              base = /* Hex */1;
              i = i + 2 | 0;
              break;
          
        }
      }
      
    } else {
      base = /* Bin */3;
      i = i + 2 | 0;
    }
  }
  return [
          i,
          sign,
          base
        ];
}

function caml_int_of_string(s) {
  var match = parse_sign_and_base(s);
  var i = match[0];
  var base = int_of_string_base(match[2]);
  var threshold = 4294967295;
  var len = s.length;
  var c = i < len ? s.charCodeAt(i) : /* "\000" */0;
  var d = parse_digit(c);
  if (d < 0 || d >= base) {
    throw {
          RE_EXN_ID: "Failure",
          _1: "int_of_string",
          Error: new Error()
        };
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      }
      var a = s.charCodeAt(k);
      if (a === /* "_" */95) {
        _k = k + 1 | 0;
        continue ;
      }
      var v = parse_digit(a);
      if (v < 0 || v >= base) {
        throw {
              RE_EXN_ID: "Failure",
              _1: "int_of_string",
              Error: new Error()
            };
      }
      var acc$1 = base * acc + v;
      if (acc$1 > threshold) {
        throw {
              RE_EXN_ID: "Failure",
              _1: "int_of_string",
              Error: new Error()
            };
      }
      _k = k + 1 | 0;
      _acc = acc$1;
      continue ;
    }  };
  var res = match[1] * aux(d, i + 1 | 0);
  var or_res = res | 0;
  if (base === 10 && res !== or_res) {
    throw {
          RE_EXN_ID: "Failure",
          _1: "int_of_string",
          Error: new Error()
        };
  }
  return or_res;
}

function caml_int64_of_string(s) {
  var match = parse_sign_and_base(s);
  var hbase = match[2];
  var i = match[0];
  var base = caml_int64.of_int32(int_of_string_base(hbase));
  var sign = caml_int64.of_int32(match[1]);
  var threshold;
  switch (hbase) {
    case /* Oct */0 :
        threshold = caml_int64.mk(-1, 536870911);
        break;
    case /* Hex */1 :
        threshold = caml_int64.mk(-1, 268435455);
        break;
    case /* Dec */2 :
        threshold = caml_int64.mk(-1717986919, 429496729);
        break;
    case /* Bin */3 :
        threshold = caml_int64.max_int;
        break;
    
  }
  var len = s.length;
  var c = i < len ? s.charCodeAt(i) : /* "\000" */0;
  var d = caml_int64.of_int32(parse_digit(c));
  if (caml_int64.lt(d, caml_int64.zero) || caml_int64.ge(d, base)) {
    throw {
          RE_EXN_ID: "Failure",
          _1: "int64_of_string",
          Error: new Error()
        };
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      }
      var a = s.charCodeAt(k);
      if (a === /* "_" */95) {
        _k = k + 1 | 0;
        continue ;
      }
      var v = caml_int64.of_int32(parse_digit(a));
      if (caml_int64.lt(v, caml_int64.zero) || caml_int64.ge(v, base) || caml_int64.gt(acc, threshold)) {
        throw {
              RE_EXN_ID: "Failure",
              _1: "int64_of_string",
              Error: new Error()
            };
      }
      var acc$1 = caml_int64.add(caml_int64.mul(base, acc), v);
      _k = k + 1 | 0;
      _acc = acc$1;
      continue ;
    }  };
  var res = caml_int64.mul(sign, aux(d, i + 1 | 0));
  var or_res = caml_int64.or_(res, caml_int64.zero);
  if (caml_int64.eq(base, caml_int64.mk(10, 0)) && caml_int64.neq(res, or_res)) {
    throw {
          RE_EXN_ID: "Failure",
          _1: "int64_of_string",
          Error: new Error()
        };
  }
  return or_res;
}

function int_of_base(param) {
  switch (param) {
    case /* Oct */0 :
        return 8;
    case /* Hex */1 :
        return 16;
    case /* Dec */2 :
        return 10;
    
  }
}

function lowercase(c) {
  if (c >= /* "A" */65 && c <= /* "Z" */90 || c >= /* "\192" */192 && c <= /* "\214" */214 || c >= /* "\216" */216 && c <= /* "\222" */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function parse_format(fmt) {
  var len = fmt.length;
  if (len > 31) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "format_int: format too long",
          Error: new Error()
        };
  }
  var f = {
    justify: "+",
    signstyle: "-",
    filter: " ",
    alternate: false,
    base: /* Dec */2,
    signedconv: false,
    width: 0,
    uppercase: false,
    sign: 1,
    prec: -1,
    conv: "f"
  };
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= len) {
      return f;
    }
    var c = fmt.charCodeAt(i);
    var exit = 0;
    if (c >= 69) {
      if (c >= 88) {
        if (c >= 121) {
          exit = 1;
        } else {
          switch (c - 88 | 0) {
            case 0 :
                f.base = /* Hex */1;
                f.uppercase = true;
                _i = i + 1 | 0;
                continue ;
            case 13 :
            case 14 :
            case 15 :
                exit = 5;
                break;
            case 12 :
            case 17 :
                exit = 4;
                break;
            case 23 :
                f.base = /* Oct */0;
                _i = i + 1 | 0;
                continue ;
            case 29 :
                f.base = /* Dec */2;
                _i = i + 1 | 0;
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 8 :
            case 9 :
            case 10 :
            case 11 :
            case 16 :
            case 18 :
            case 19 :
            case 20 :
            case 21 :
            case 22 :
            case 24 :
            case 25 :
            case 26 :
            case 27 :
            case 28 :
            case 30 :
            case 31 :
                exit = 1;
                break;
            case 32 :
                f.base = /* Hex */1;
                _i = i + 1 | 0;
                continue ;
            
          }
        }
      } else if (c >= 72) {
        exit = 1;
      } else {
        f.signedconv = true;
        f.uppercase = true;
        f.conv = String.fromCharCode(lowercase(c));
        _i = i + 1 | 0;
        continue ;
      }
    } else {
      switch (c) {
        case 35 :
            f.alternate = true;
            _i = i + 1 | 0;
            continue ;
        case 32 :
        case 43 :
            exit = 2;
            break;
        case 45 :
            f.justify = "-";
            _i = i + 1 | 0;
            continue ;
        case 46 :
            f.prec = 0;
            var j = i + 1 | 0;
            while((function(j){
                return function () {
                  var w = fmt.charCodeAt(j) - /* "0" */48 | 0;
                  return w >= 0 && w <= 9;
                }
                }(j))()) {
              f.prec = (Math.imul(f.prec, 10) + fmt.charCodeAt(j) | 0) - /* "0" */48 | 0;
              j = j + 1 | 0;
            }            _i = j;
            continue ;
        case 33 :
        case 34 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 40 :
        case 41 :
        case 42 :
        case 44 :
        case 47 :
            exit = 1;
            break;
        case 48 :
            f.filter = "0";
            _i = i + 1 | 0;
            continue ;
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
            exit = 3;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          _i = i + 1 | 0;
          continue ;
      case 2 :
          f.signstyle = String.fromCharCode(c);
          _i = i + 1 | 0;
          continue ;
      case 3 :
          f.width = 0;
          var j$1 = i;
          while((function(j$1){
              return function () {
                var w = fmt.charCodeAt(j$1) - /* "0" */48 | 0;
                return w >= 0 && w <= 9;
              }
              }(j$1))()) {
            f.width = (Math.imul(f.width, 10) + fmt.charCodeAt(j$1) | 0) - /* "0" */48 | 0;
            j$1 = j$1 + 1 | 0;
          }          _i = j$1;
          continue ;
      case 4 :
          f.signedconv = true;
          f.base = /* Dec */2;
          _i = i + 1 | 0;
          continue ;
      case 5 :
          f.signedconv = true;
          f.conv = String.fromCharCode(c);
          _i = i + 1 | 0;
          continue ;
      
    }
  }}

function finish_formatting(config, rawbuffer) {
  var justify = config.justify;
  var signstyle = config.signstyle;
  var filter = config.filter;
  var alternate = config.alternate;
  var base = config.base;
  var signedconv = config.signedconv;
  var width = config.width;
  var uppercase = config.uppercase;
  var sign = config.sign;
  var len = rawbuffer.length;
  if (signedconv && (sign < 0 || signstyle !== "-")) {
    len = len + 1 | 0;
  }
  if (alternate) {
    if (base === /* Oct */0) {
      len = len + 1 | 0;
    } else if (base === /* Hex */1) {
      len = len + 2 | 0;
    }
    
  }
  var buffer = "";
  if (justify === "+" && filter === " ") {
    for(var _for = len; _for < width; ++_for){
      buffer = buffer + filter;
    }
  }
  if (signedconv) {
    if (sign < 0) {
      buffer = buffer + "-";
    } else if (signstyle !== "-") {
      buffer = buffer + signstyle;
    }
    
  }
  if (alternate && base === /* Oct */0) {
    buffer = buffer + "0";
  }
  if (alternate && base === /* Hex */1) {
    buffer = buffer + "0x";
  }
  if (justify === "+" && filter === "0") {
    for(var _for$1 = len; _for$1 < width; ++_for$1){
      buffer = buffer + filter;
    }
  }
  buffer = uppercase ? buffer + rawbuffer.toUpperCase() : buffer + rawbuffer;
  if (justify === "-") {
    for(var _for$2 = len; _for$2 < width; ++_for$2){
      buffer = buffer + " ";
    }
  }
  return buffer;
}

function caml_format_int(fmt, i) {
  if (fmt === "%d") {
    return String(i);
  }
  var f = parse_format(fmt);
  var i$1 = i < 0 ? (
      f.signedconv ? (f.sign = -1, -i) : (i >>> 0)
    ) : i;
  var s = i$1.toString(int_of_base(f.base));
  if (f.prec >= 0) {
    f.filter = " ";
    var n = f.prec - s.length | 0;
    if (n > 0) {
      s = "0".repeat(n) + s;
    }
    
  }
  return finish_formatting(f, s);
}

function dec_of_pos_int64(x) {
  if (!caml_int64.lt(x, caml_int64.zero)) {
    return caml_int64.to_string(x);
  }
  var wbase = caml_int64.mk(10, 0);
  var y = caml_int64.discard_sign(x);
  var match = caml_int64.div_mod(y, wbase);
  var match$1 = caml_int64.div_mod(caml_int64.add(caml_int64.mk(8, 0), match[1]), wbase);
  var quotient = caml_int64.add(caml_int64.add(caml_int64.mk(-858993460, 214748364), match[0]), match$1[0]);
  return caml_int64.to_string(quotient) + "0123456789"[caml_int64.to_int32(match$1[1])];
}

function oct_of_int64(x) {
  var s = "";
  var wbase = caml_int64.mk(8, 0);
  var cvtbl = "01234567";
  if (caml_int64.lt(x, caml_int64.zero)) {
    var y = caml_int64.discard_sign(x);
    var match = caml_int64.div_mod(y, wbase);
    var quotient = caml_int64.add(caml_int64.mk(0, 268435456), match[0]);
    var modulus = match[1];
    s = cvtbl[caml_int64.to_int32(modulus)] + s;
    while(caml_int64.neq(quotient, caml_int64.zero)) {
      var match$1 = caml_int64.div_mod(quotient, wbase);
      quotient = match$1[0];
      modulus = match$1[1];
      s = cvtbl[caml_int64.to_int32(modulus)] + s;
    }  } else {
    var match$2 = caml_int64.div_mod(x, wbase);
    var quotient$1 = match$2[0];
    var modulus$1 = match$2[1];
    s = cvtbl[caml_int64.to_int32(modulus$1)] + s;
    while(caml_int64.neq(quotient$1, caml_int64.zero)) {
      var match$3 = caml_int64.div_mod(quotient$1, wbase);
      quotient$1 = match$3[0];
      modulus$1 = match$3[1];
      s = cvtbl[caml_int64.to_int32(modulus$1)] + s;
    }  }
  return s;
}

function caml_int64_format(fmt, x) {
  if (fmt === "%d") {
    return caml_int64.to_string(x);
  }
  var f = parse_format(fmt);
  var x$1 = f.signedconv && caml_int64.lt(x, caml_int64.zero) ? (f.sign = -1, caml_int64.neg(x)) : x;
  var match = f.base;
  var s;
  switch (match) {
    case /* Oct */0 :
        s = oct_of_int64(x$1);
        break;
    case /* Hex */1 :
        s = caml_int64.to_hex(x$1);
        break;
    case /* Dec */2 :
        s = dec_of_pos_int64(x$1);
        break;
    
  }
  var fill_s;
  if (f.prec >= 0) {
    f.filter = " ";
    var n = f.prec - s.length | 0;
    fill_s = n > 0 ? "0".repeat(n) + s : s;
  } else {
    fill_s = s;
  }
  return finish_formatting(f, fill_s);
}

function caml_format_float(fmt, x) {
  var f = parse_format(fmt);
  var prec = f.prec < 0 ? 6 : f.prec;
  var x$1 = x < 0 ? (f.sign = -1, -x) : x;
  var s = "";
  if (isNaN(x$1)) {
    s = "nan";
    f.filter = " ";
  } else if (isFinite(x$1)) {
    var match = f.conv;
    switch (match) {
      case "e" :
          s = x$1.toExponential(prec);
          var i = s.length;
          if (s[i - 3 | 0] === "e") {
            s = s.slice(0, i - 1 | 0) + ("0" + s.slice(i - 1 | 0));
          }
          break;
      case "f" :
          s = x$1.toFixed(prec);
          break;
      case "g" :
          var prec$1 = prec !== 0 ? prec : 1;
          s = x$1.toExponential(prec$1 - 1 | 0);
          var j = s.indexOf("e");
          var exp = Number(s.slice(j + 1 | 0)) | 0;
          if (exp < -4 || x$1 >= 1e21 || x$1.toFixed().length > prec$1) {
            var i$1 = j - 1 | 0;
            while(s[i$1] === "0") {
              i$1 = i$1 - 1 | 0;
            }            if (s[i$1] === ".") {
              i$1 = i$1 - 1 | 0;
            }
            s = s.slice(0, i$1 + 1 | 0) + s.slice(j);
            var i$2 = s.length;
            if (s[i$2 - 3 | 0] === "e") {
              s = s.slice(0, i$2 - 1 | 0) + ("0" + s.slice(i$2 - 1 | 0));
            }
            
          } else {
            var p = prec$1;
            if (exp < 0) {
              p = p - (exp + 1 | 0) | 0;
              s = x$1.toFixed(p);
            } else {
              while((function () {
                      s = x$1.toFixed(p);
                      return s.length > (prec$1 + 1 | 0);
                    })()) {
                p = p - 1 | 0;
              }            }
            if (p !== 0) {
              var k = s.length - 1 | 0;
              while(s[k] === "0") {
                k = k - 1 | 0;
              }              if (s[k] === ".") {
                k = k - 1 | 0;
              }
              s = s.slice(0, k + 1 | 0);
            }
            
          }
          break;
        
    }
  } else {
    s = "inf";
    f.filter = " ";
  }
  return finish_formatting(f, s);
}

var caml_hexstring_of_float = (function(x,prec,style){
  if (!isFinite(x)) {
    if (isNaN(x)) return "nan";
    return x > 0 ? "infinity":"-infinity";
  }
  var sign = (x==0 && 1/x == -Infinity)?1:(x>=0)?0:1;
  if(sign) x = -x;
  var exp = 0;
  if (x == 0) ;
  else if (x < 1) {
    while (x < 1 && exp > -1022)  { x *= 2; exp--; }
  } else {
    while (x >= 2) { x /= 2; exp++; }
  }
  var exp_sign = exp < 0 ? '' : '+';
  var sign_str = '';
  if (sign) sign_str = '-';
  else {
    switch(style){
    case 43 /* '+' */: sign_str = '+'; break;
    case 32 /* ' ' */: sign_str = ' '; break;
    }
  }
  if (prec >= 0 && prec < 13) {
    /* If a precision is given, and is small, round mantissa accordingly */
      var cst = Math.pow(2,prec * 4);
      x = Math.round(x * cst) / cst;
  }
  var x_str = x.toString(16);
  if(prec >= 0){
      var idx = x_str.indexOf('.');
    if(idx<0) {
      x_str += '.' +  '0'.repeat(prec);
    }
    else {
      var size = idx+1+prec;
      if(x_str.length < size)
        x_str += '0'.repeat(size - x_str.length);
      else
        x_str = x_str.substr(0,size);
    }
  }
  return  (sign_str + '0x' + x_str + 'p' + exp_sign + exp.toString(10));
});

var float_of_string = (function(s,exn){

    var res = +s;
    if ((s.length > 0) && (res === res))
        return res;
    s = s.replace(/_/g, "");
    res = +s;
    if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) {
        return res;
    }    var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
    //            1        2             3           4
    if(m){
        var m3 = m[3].replace(/0+$/,'');
        var mantissa = parseInt(m[1] + m[2] + m3, 16);
        var exponent = (m[4]|0) - 4*m3.length;
        res = mantissa * Math.pow(2, exponent);
        return res;
    }
    if (/^\+?inf(inity)?$/i.test(s))
        return Infinity;
    if (/^-inf(inity)?$/i.test(s))
        return -Infinity;
    throw exn;
});

function caml_float_of_string(s) {
  return float_of_string(s, {
              RE_EXN_ID: "Failure",
              _1: "float_of_string"
            });
}

var caml_nativeint_format = caml_format_int;

var caml_int32_format = caml_format_int;

var caml_int32_of_string = caml_int_of_string;

var caml_nativeint_of_string = caml_int_of_string;

var caml_format_float_1 = caml_format_float;
var caml_hexstring_of_float_1 = caml_hexstring_of_float;
var caml_format_int_1 = caml_format_int;
var caml_nativeint_format_1 = caml_nativeint_format;
var caml_int32_format_1 = caml_int32_format;
var caml_float_of_string_1 = caml_float_of_string;
var caml_int64_format_1 = caml_int64_format;
var caml_int_of_string_1 = caml_int_of_string;
var caml_int32_of_string_1 = caml_int32_of_string;
var caml_int64_of_string_1 = caml_int64_of_string;
var caml_nativeint_of_string_1 = caml_nativeint_of_string;
/* No side effect */

var caml_format = {
	caml_format_float: caml_format_float_1,
	caml_hexstring_of_float: caml_hexstring_of_float_1,
	caml_format_int: caml_format_int_1,
	caml_nativeint_format: caml_nativeint_format_1,
	caml_int32_format: caml_int32_format_1,
	caml_float_of_string: caml_float_of_string_1,
	caml_int64_format: caml_int64_format_1,
	caml_int_of_string: caml_int_of_string_1,
	caml_int32_of_string: caml_int32_of_string_1,
	caml_int64_of_string: caml_int64_of_string_1,
	caml_nativeint_of_string: caml_nativeint_of_string_1
};

function get$2(s, i) {
  if (i >= s.length || i < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  return s.charCodeAt(i);
}

function make(n, ch) {
  return String.fromCharCode(ch).repeat(n);
}

var get_1$2 = get$2;
var make_1 = make;
/* No side effect */

var caml_string = {
	get: get_1$2,
	make: make_1
};

var id = {
  contents: 0
};

function create(str) {
  id.contents = id.contents + 1 | 0;
  return str + ("/" + id.contents);
}

function caml_is_extension(e) {
  if (e == null) {
    return false;
  } else {
    return typeof e.RE_EXN_ID === "string";
  }
}

function caml_exn_slot_name(x) {
  return x.RE_EXN_ID;
}

var id_1 = id;
var create_1 = create;
var caml_is_extension_1 = caml_is_extension;
var caml_exn_slot_name_1 = caml_exn_slot_name;
/* No side effect */

var caml_exceptions = {
	id: id_1,
	create: create_1,
	caml_is_extension: caml_is_extension_1,
	caml_exn_slot_name: caml_exn_slot_name_1
};

function isNested(x) {
  return x.BS_PRIVATE_NESTED_SOME_NONE !== undefined;
}

function some(x) {
  if (x === undefined) {
    return {
            BS_PRIVATE_NESTED_SOME_NONE: 0
          };
  } else if (x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {
    return {
            BS_PRIVATE_NESTED_SOME_NONE: x.BS_PRIVATE_NESTED_SOME_NONE + 1 | 0
          };
  } else {
    return x;
  }
}

function nullable_to_opt(x) {
  if (x == null) {
    return ;
  } else {
    return some(x);
  }
}

function undefined_to_opt(x) {
  if (x === undefined) {
    return ;
  } else {
    return some(x);
  }
}

function null_to_opt(x) {
  if (x === null) {
    return ;
  } else {
    return some(x);
  }
}

function valFromOption(x) {
  if (!(x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined)) {
    return x;
  }
  var depth = x.BS_PRIVATE_NESTED_SOME_NONE;
  if (depth === 0) {
    return ;
  } else {
    return {
            BS_PRIVATE_NESTED_SOME_NONE: depth - 1 | 0
          };
  }
}

function option_get(x) {
  if (x === undefined) {
    return ;
  } else {
    return valFromOption(x);
  }
}

function option_unwrap(x) {
  if (x !== undefined) {
    return x.VAL;
  } else {
    return x;
  }
}

var nullable_to_opt_1 = nullable_to_opt;
var undefined_to_opt_1 = undefined_to_opt;
var null_to_opt_1 = null_to_opt;
var valFromOption_1 = valFromOption;
var some_1 = some;
var isNested_1 = isNested;
var option_get_1 = option_get;
var option_unwrap_1 = option_unwrap;
/* No side effect */

var caml_option = {
	nullable_to_opt: nullable_to_opt_1,
	undefined_to_opt: undefined_to_opt_1,
	null_to_opt: null_to_opt_1,
	valFromOption: valFromOption_1,
	some: some_1,
	isNested: isNested_1,
	option_get: option_get_1,
	option_unwrap: option_unwrap_1
};

var $$Error = caml_exceptions.create("Caml_js_exceptions.Error");

function internalToOCamlException(e) {
  if (caml_exceptions.caml_is_extension(e)) {
    return e;
  } else {
    return {
            RE_EXN_ID: $$Error,
            _1: e
          };
  }
}

function caml_as_js_exn(exn) {
  if (exn.RE_EXN_ID === $$Error) {
    return caml_option.some(exn._1);
  }
  
}

var $$Error_1 = $$Error;
var internalToOCamlException_1 = internalToOCamlException;
var caml_as_js_exn_1 = caml_as_js_exn;
/* No side effect */

var caml_js_exceptions = {
	$$Error: $$Error_1,
	internalToOCamlException: internalToOCamlException_1,
	caml_as_js_exn: caml_as_js_exn_1
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var getGlobalThis = (function(){
  if (typeof globalThis !== 'undefined') return globalThis;
	if (typeof self !== 'undefined') return self;
	if (typeof window !== 'undefined') return window;
	if (typeof commonjsGlobal !== 'undefined') return commonjsGlobal;
	if (typeof this !== 'undefined') return this;
	throw new Error('Unable to locate global `this`');
});

var resolve = (function(s){
  var myGlobal = getGlobalThis();
  if (myGlobal[s] === undefined){
    throw new Error(s + " not polyfilled by BuckleScript yet\n")
  }
  return myGlobal[s]
});

var register = (function(s,fn){
  var myGlobal = getGlobalThis();
  myGlobal[s] = fn; 
  return 0
});

var getGlobalThis_1 = getGlobalThis;
var resolve_1 = resolve;
var register_1 = register;
/* No side effect */

var caml_external_polyfill = {
	getGlobalThis: getGlobalThis_1,
	resolve: resolve_1,
	register: register_1
};

function failwith(s) {
  throw {
        RE_EXN_ID: "Failure",
        _1: s,
        Error: new Error()
      };
}

function invalid_arg(s) {
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: s,
        Error: new Error()
      };
}

var Exit = caml_exceptions.create("Pervasives.Exit");

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

function lnot(x) {
  return x ^ -1;
}

var min_int$1 = -2147483648;

function classify_float(x) {
  if (isFinite(x)) {
    if (Math.abs(x) >= 2.22507385850720138e-308) {
      return /* FP_normal */0;
    } else if (x !== 0) {
      return /* FP_subnormal */1;
    } else {
      return /* FP_zero */2;
    }
  } else if (isNaN(x)) {
    return /* FP_nan */4;
  } else {
    return /* FP_infinite */3;
  }
}

function char_of_int(n) {
  if (n < 0 || n > 255) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "char_of_int",
          Error: new Error()
        };
  }
  return n;
}

function string_of_bool(b) {
  if (b) {
    return "true";
  } else {
    return "false";
  }
}

function bool_of_string(param) {
  switch (param) {
    case "false" :
        return false;
    case "true" :
        return true;
    default:
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "bool_of_string",
            Error: new Error()
          };
  }
}

function bool_of_string_opt(param) {
  switch (param) {
    case "false" :
        return false;
    case "true" :
        return true;
    default:
      return ;
  }
}

function int_of_string_opt(s) {
  try {
    return caml_format.caml_int_of_string(s);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return ;
    }
    throw exn;
  }
}

function valid_float_lexem(s) {
  var l = s.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= l) {
      return s + ".";
    }
    var match = caml_string.get(s, i);
    if (match >= 48) {
      if (match >= 58) {
        return s;
      }
      _i = i + 1 | 0;
      continue ;
    }
    if (match !== 45) {
      return s;
    }
    _i = i + 1 | 0;
    continue ;
  }}

function string_of_float(f) {
  return valid_float_lexem(caml_format.caml_format_float("%.12g", f));
}

function float_of_string_opt(s) {
  try {
    return caml_format.caml_float_of_string(s);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return ;
    }
    throw exn;
  }
}

function $at(l1, l2) {
  if (l1) {
    return {
            hd: l1.hd,
            tl: $at(l1.tl, l2)
          };
  } else {
    return l2;
  }
}

var stdin$1 = caml_io.stdin;

var stdout$1 = caml_io.stdout;

var stderr$1 = caml_io.stderr;

function open_out_gen(mode, perm, name) {
  var c = caml_external_polyfill.resolve("caml_ml_open_descriptor_out")(caml_external_polyfill.resolve("caml_sys_open")(name, mode, perm));
  caml_external_polyfill.resolve("caml_ml_set_channel_name")(c, name);
  return c;
}

function open_out(name) {
  return open_out_gen({
              hd: /* Open_wronly */1,
              tl: {
                hd: /* Open_creat */3,
                tl: {
                  hd: /* Open_trunc */4,
                  tl: {
                    hd: /* Open_text */7,
                    tl: /* [] */0
                  }
                }
              }
            }, 438, name);
}

function open_out_bin(name) {
  return open_out_gen({
              hd: /* Open_wronly */1,
              tl: {
                hd: /* Open_creat */3,
                tl: {
                  hd: /* Open_trunc */4,
                  tl: {
                    hd: /* Open_binary */6,
                    tl: /* [] */0
                  }
                }
              }
            }, 438, name);
}

function flush_all(param) {
  var _param = caml_io.caml_ml_out_channels_list(undefined);
  while(true) {
    var param$1 = _param;
    if (!param$1) {
      return ;
    }
    try {
      caml_io.caml_ml_flush(param$1.hd);
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID !== "Sys_error") {
        throw exn;
      }
      
    }
    _param = param$1.tl;
    continue ;
  }}

function output_bytes(oc, s) {
  return caml_external_polyfill.resolve("caml_ml_output_bytes")(oc, s, 0, s.length);
}

function output_string(oc, s) {
  return caml_io.caml_ml_output(oc, s, 0, s.length);
}

function output(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "output",
          Error: new Error()
        };
  }
  return caml_external_polyfill.resolve("caml_ml_output_bytes")(oc, s, ofs, len);
}

function output_substring(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "output_substring",
          Error: new Error()
        };
  }
  return caml_io.caml_ml_output(oc, s, ofs, len);
}

function output_value(chan, v) {
  return caml_external_polyfill.resolve("caml_output_value")(chan, v, /* [] */0);
}

function close_out(oc) {
  caml_io.caml_ml_flush(oc);
  return caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function close_out_noerr(oc) {
  try {
    caml_io.caml_ml_flush(oc);
  }
  catch (exn){
    
  }
  try {
    return caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
  }
  catch (exn$1){
    return ;
  }
}

function open_in_gen(mode, perm, name) {
  var c = caml_external_polyfill.resolve("caml_ml_open_descriptor_in")(caml_external_polyfill.resolve("caml_sys_open")(name, mode, perm));
  caml_external_polyfill.resolve("caml_ml_set_channel_name")(c, name);
  return c;
}

function open_in(name) {
  return open_in_gen({
              hd: /* Open_rdonly */0,
              tl: {
                hd: /* Open_text */7,
                tl: /* [] */0
              }
            }, 0, name);
}

function open_in_bin(name) {
  return open_in_gen({
              hd: /* Open_rdonly */0,
              tl: {
                hd: /* Open_binary */6,
                tl: /* [] */0
              }
            }, 0, name);
}

function input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "input",
          Error: new Error()
        };
  }
  return caml_external_polyfill.resolve("caml_ml_input")(ic, s, ofs, len);
}

function unsafe_really_input(ic, s, _ofs, _len) {
  while(true) {
    var len = _len;
    var ofs = _ofs;
    if (len <= 0) {
      return ;
    }
    var r = caml_external_polyfill.resolve("caml_ml_input")(ic, s, ofs, len);
    if (r === 0) {
      throw {
            RE_EXN_ID: "End_of_file",
            Error: new Error()
          };
    }
    _len = len - r | 0;
    _ofs = ofs + r | 0;
    continue ;
  }}

function really_input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "really_input",
          Error: new Error()
        };
  }
  return unsafe_really_input(ic, s, ofs, len);
}

function really_input_string(ic, len) {
  var s = caml_bytes.caml_create_bytes(len);
  really_input(ic, s, 0, len);
  return caml_bytes.bytes_to_string(s);
}

function input_line(chan) {
  var build_result = function (buf, _pos, _param) {
    while(true) {
      var param = _param;
      var pos = _pos;
      if (!param) {
        return buf;
      }
      var hd = param.hd;
      var len = hd.length;
      caml_bytes.caml_blit_bytes(hd, 0, buf, pos - len | 0, len);
      _param = param.tl;
      _pos = pos - len | 0;
      continue ;
    }  };
  var scan = function (_accu, _len) {
    while(true) {
      var len = _len;
      var accu = _accu;
      var n = caml_external_polyfill.resolve("caml_ml_input_scan_line")(chan);
      if (n === 0) {
        if (accu) {
          return build_result(caml_bytes.caml_create_bytes(len), len, accu);
        }
        throw {
              RE_EXN_ID: "End_of_file",
              Error: new Error()
            };
      }
      if (n > 0) {
        var res = caml_bytes.caml_create_bytes(n - 1 | 0);
        caml_external_polyfill.resolve("caml_ml_input")(chan, res, 0, n - 1 | 0);
        caml_external_polyfill.resolve("caml_ml_input_char")(chan);
        if (!accu) {
          return res;
        }
        var len$1 = (len + n | 0) - 1 | 0;
        return build_result(caml_bytes.caml_create_bytes(len$1), len$1, {
                    hd: res,
                    tl: accu
                  });
      }
      var beg = caml_bytes.caml_create_bytes(-n | 0);
      caml_external_polyfill.resolve("caml_ml_input")(chan, beg, 0, -n | 0);
      _len = len - n | 0;
      _accu = {
        hd: beg,
        tl: accu
      };
      continue ;
    }  };
  return caml_bytes.bytes_to_string(scan(/* [] */0, 0));
}

function close_in_noerr(ic) {
  try {
    return caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  }
  catch (exn){
    return ;
  }
}

function print_char(c) {
  return caml_io.caml_ml_output_char(stdout$1, c);
}

function print_string(s) {
  return output_string(stdout$1, s);
}

function print_bytes(s) {
  return output_bytes(stdout$1, s);
}

function print_int(i) {
  return output_string(stdout$1, String(i));
}

function print_float(f) {
  return output_string(stdout$1, valid_float_lexem(caml_format.caml_format_float("%.12g", f)));
}

function print_newline(param) {
  caml_io.caml_ml_output_char(stdout$1, /* "\n" */10);
  return caml_io.caml_ml_flush(stdout$1);
}

function prerr_char(c) {
  return caml_io.caml_ml_output_char(stderr$1, c);
}

function prerr_string(s) {
  return output_string(stderr$1, s);
}

function prerr_bytes(s) {
  return output_bytes(stderr$1, s);
}

function prerr_int(i) {
  return output_string(stderr$1, String(i));
}

function prerr_float(f) {
  return output_string(stderr$1, valid_float_lexem(caml_format.caml_format_float("%.12g", f)));
}

function prerr_newline(param) {
  caml_io.caml_ml_output_char(stderr$1, /* "\n" */10);
  return caml_io.caml_ml_flush(stderr$1);
}

function read_line(param) {
  caml_io.caml_ml_flush(stdout$1);
  return input_line(stdin$1);
}

function read_int(param) {
  return caml_format.caml_int_of_string((caml_io.caml_ml_flush(stdout$1), input_line(stdin$1)));
}

function read_int_opt(param) {
  return int_of_string_opt((caml_io.caml_ml_flush(stdout$1), input_line(stdin$1)));
}

function read_float(param) {
  return caml_format.caml_float_of_string((caml_io.caml_ml_flush(stdout$1), input_line(stdin$1)));
}

function read_float_opt(param) {
  return float_of_string_opt((caml_io.caml_ml_flush(stdout$1), input_line(stdin$1)));
}

function string_of_format(param) {
  return param._1;
}

var exit_function = {
  contents: flush_all
};

function at_exit(f) {
  var g = exit_function.contents;
  exit_function.contents = (function (param) {
      curry._1(f, undefined);
      return curry._1(g, undefined);
    });
  
}

function do_at_exit(param) {
  return curry._1(exit_function.contents, undefined);
}

function exit(retcode) {
  do_at_exit();
  return caml_sys.caml_sys_exit(retcode);
}

var max_int$1 = 2147483647;

var infinity = Infinity;

var neg_infinity = -Infinity;

var max_float = 1.79769313486231571e+308;

var min_float = 2.22507385850720138e-308;

var epsilon_float = 2.22044604925031308e-16;

var flush = caml_io.caml_ml_flush;

var output_char = caml_io.caml_ml_output_char;

var output_byte = caml_io.caml_ml_output_char;

function output_binary_int(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_output_int")(prim, prim$1);
}

function seek_out(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_seek_out")(prim, prim$1);
}

function pos_out(prim) {
  return caml_external_polyfill.resolve("caml_ml_pos_out")(prim);
}

function out_channel_length(prim) {
  return caml_external_polyfill.resolve("caml_ml_channel_size")(prim);
}

function set_binary_mode_out(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_set_binary_mode")(prim, prim$1);
}

function input_char(prim) {
  return caml_external_polyfill.resolve("caml_ml_input_char")(prim);
}

function input_byte(prim) {
  return caml_external_polyfill.resolve("caml_ml_input_char")(prim);
}

function input_binary_int(prim) {
  return caml_external_polyfill.resolve("caml_ml_input_int")(prim);
}

function input_value(prim) {
  return caml_external_polyfill.resolve("caml_input_value")(prim);
}

function seek_in(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_seek_in")(prim, prim$1);
}

function pos_in(prim) {
  return caml_external_polyfill.resolve("caml_ml_pos_in")(prim);
}

function in_channel_length(prim) {
  return caml_external_polyfill.resolve("caml_ml_channel_size")(prim);
}

function close_in(prim) {
  return caml_external_polyfill.resolve("caml_ml_close_channel")(prim);
}

function set_binary_mode_in(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_set_binary_mode")(prim, prim$1);
}

function LargeFile_seek_out(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_seek_out_64")(prim, prim$1);
}

function LargeFile_pos_out(prim) {
  return caml_external_polyfill.resolve("caml_ml_pos_out_64")(prim);
}

function LargeFile_out_channel_length(prim) {
  return caml_external_polyfill.resolve("caml_ml_channel_size_64")(prim);
}

function LargeFile_seek_in(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_seek_in_64")(prim, prim$1);
}

function LargeFile_pos_in(prim) {
  return caml_external_polyfill.resolve("caml_ml_pos_in_64")(prim);
}

function LargeFile_in_channel_length(prim) {
  return caml_external_polyfill.resolve("caml_ml_channel_size_64")(prim);
}

var LargeFile = {
  seek_out: LargeFile_seek_out,
  pos_out: LargeFile_pos_out,
  out_channel_length: LargeFile_out_channel_length,
  seek_in: LargeFile_seek_in,
  pos_in: LargeFile_pos_in,
  in_channel_length: LargeFile_in_channel_length
};

var invalid_arg_1 = invalid_arg;
var failwith_1 = failwith;
var Exit_1 = Exit;
var abs_1 = abs;
var max_int_1$1 = max_int$1;
var min_int_1$1 = min_int$1;
var lnot_1 = lnot;
var infinity_1 = infinity;
var neg_infinity_1 = neg_infinity;
var max_float_1 = max_float;
var min_float_1 = min_float;
var epsilon_float_1 = epsilon_float;
var classify_float_1 = classify_float;
var char_of_int_1 = char_of_int;
var string_of_bool_1 = string_of_bool;
var bool_of_string_1 = bool_of_string;
var bool_of_string_opt_1 = bool_of_string_opt;
var int_of_string_opt_1 = int_of_string_opt;
var string_of_float_1 = string_of_float;
var float_of_string_opt_1 = float_of_string_opt;
var $at_1 = $at;
var stdin_1$1 = stdin$1;
var stdout_1$1 = stdout$1;
var stderr_1$1 = stderr$1;
var print_char_1 = print_char;
var print_string_1 = print_string;
var print_bytes_1 = print_bytes;
var print_int_1 = print_int;
var print_float_1 = print_float;
var print_newline_1 = print_newline;
var prerr_char_1 = prerr_char;
var prerr_string_1 = prerr_string;
var prerr_bytes_1 = prerr_bytes;
var prerr_int_1 = prerr_int;
var prerr_float_1 = prerr_float;
var prerr_newline_1 = prerr_newline;
var read_line_1 = read_line;
var read_int_1 = read_int;
var read_int_opt_1 = read_int_opt;
var read_float_1 = read_float;
var read_float_opt_1 = read_float_opt;
var open_out_1 = open_out;
var open_out_bin_1 = open_out_bin;
var open_out_gen_1 = open_out_gen;
var flush_1 = flush;
var flush_all_1 = flush_all;
var output_char_1 = output_char;
var output_string_1 = output_string;
var output_bytes_1 = output_bytes;
var output_1 = output;
var output_substring_1 = output_substring;
var output_byte_1 = output_byte;
var output_binary_int_1 = output_binary_int;
var output_value_1 = output_value;
var seek_out_1 = seek_out;
var pos_out_1 = pos_out;
var out_channel_length_1 = out_channel_length;
var close_out_1 = close_out;
var close_out_noerr_1 = close_out_noerr;
var set_binary_mode_out_1 = set_binary_mode_out;
var open_in_1 = open_in;
var open_in_bin_1 = open_in_bin;
var open_in_gen_1 = open_in_gen;
var input_char_1 = input_char;
var input_line_1 = input_line;
var input_1 = input;
var really_input_1 = really_input;
var really_input_string_1 = really_input_string;
var input_byte_1 = input_byte;
var input_binary_int_1 = input_binary_int;
var input_value_1 = input_value;
var seek_in_1 = seek_in;
var pos_in_1 = pos_in;
var in_channel_length_1 = in_channel_length;
var close_in_1 = close_in;
var close_in_noerr_1 = close_in_noerr;
var set_binary_mode_in_1 = set_binary_mode_in;
var LargeFile_1 = LargeFile;
var string_of_format_1 = string_of_format;
var exit_1 = exit;
var at_exit_1 = at_exit;
var valid_float_lexem_1 = valid_float_lexem;
var unsafe_really_input_1 = unsafe_really_input;
var do_at_exit_1 = do_at_exit;
/* No side effect */

var pervasives = {
	invalid_arg: invalid_arg_1,
	failwith: failwith_1,
	Exit: Exit_1,
	abs: abs_1,
	max_int: max_int_1$1,
	min_int: min_int_1$1,
	lnot: lnot_1,
	infinity: infinity_1,
	neg_infinity: neg_infinity_1,
	max_float: max_float_1,
	min_float: min_float_1,
	epsilon_float: epsilon_float_1,
	classify_float: classify_float_1,
	char_of_int: char_of_int_1,
	string_of_bool: string_of_bool_1,
	bool_of_string: bool_of_string_1,
	bool_of_string_opt: bool_of_string_opt_1,
	int_of_string_opt: int_of_string_opt_1,
	string_of_float: string_of_float_1,
	float_of_string_opt: float_of_string_opt_1,
	$at: $at_1,
	stdin: stdin_1$1,
	stdout: stdout_1$1,
	stderr: stderr_1$1,
	print_char: print_char_1,
	print_string: print_string_1,
	print_bytes: print_bytes_1,
	print_int: print_int_1,
	print_float: print_float_1,
	print_newline: print_newline_1,
	prerr_char: prerr_char_1,
	prerr_string: prerr_string_1,
	prerr_bytes: prerr_bytes_1,
	prerr_int: prerr_int_1,
	prerr_float: prerr_float_1,
	prerr_newline: prerr_newline_1,
	read_line: read_line_1,
	read_int: read_int_1,
	read_int_opt: read_int_opt_1,
	read_float: read_float_1,
	read_float_opt: read_float_opt_1,
	open_out: open_out_1,
	open_out_bin: open_out_bin_1,
	open_out_gen: open_out_gen_1,
	flush: flush_1,
	flush_all: flush_all_1,
	output_char: output_char_1,
	output_string: output_string_1,
	output_bytes: output_bytes_1,
	output: output_1,
	output_substring: output_substring_1,
	output_byte: output_byte_1,
	output_binary_int: output_binary_int_1,
	output_value: output_value_1,
	seek_out: seek_out_1,
	pos_out: pos_out_1,
	out_channel_length: out_channel_length_1,
	close_out: close_out_1,
	close_out_noerr: close_out_noerr_1,
	set_binary_mode_out: set_binary_mode_out_1,
	open_in: open_in_1,
	open_in_bin: open_in_bin_1,
	open_in_gen: open_in_gen_1,
	input_char: input_char_1,
	input_line: input_line_1,
	input: input_1,
	really_input: really_input_1,
	really_input_string: really_input_string_1,
	input_byte: input_byte_1,
	input_binary_int: input_binary_int_1,
	input_value: input_value_1,
	seek_in: seek_in_1,
	pos_in: pos_in_1,
	in_channel_length: in_channel_length_1,
	close_in: close_in_1,
	close_in_noerr: close_in_noerr_1,
	set_binary_mode_in: set_binary_mode_in_1,
	LargeFile: LargeFile_1,
	string_of_format: string_of_format_1,
	exit: exit_1,
	at_exit: at_exit_1,
	valid_float_lexem: valid_float_lexem_1,
	unsafe_really_input: unsafe_really_input_1,
	do_at_exit: do_at_exit_1
};

function length(l) {
  var _len = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var len = _len;
    if (!param) {
      return len;
    }
    _param = param.tl;
    _len = len + 1 | 0;
    continue ;
  }}

function cons(a, l) {
  return {
          hd: a,
          tl: l
        };
}

function hd(param) {
  if (param) {
    return param.hd;
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "hd",
        Error: new Error()
      };
}

function tl(param) {
  if (param) {
    return param.tl;
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "tl",
        Error: new Error()
      };
}

function nth(l, n) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.nth",
          Error: new Error()
        };
  }
  var _l = l;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var l$1 = _l;
    if (l$1) {
      if (n$1 === 0) {
        return l$1.hd;
      }
      _n = n$1 - 1 | 0;
      _l = l$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Failure",
          _1: "nth",
          Error: new Error()
        };
  }}

function nth_opt(l, n) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.nth",
          Error: new Error()
        };
  }
  var _l = l;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var l$1 = _l;
    if (!l$1) {
      return ;
    }
    if (n$1 === 0) {
      return caml_option.some(l$1.hd);
    }
    _n = n$1 - 1 | 0;
    _l = l$1.tl;
    continue ;
  }}

function rev_append(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: l1.hd,
      tl: l2
    };
    _l1 = l1.tl;
    continue ;
  }}

function rev(l) {
  return rev_append(l, /* [] */0);
}

function init_tailrec_aux(_acc, _i, n, f) {
  while(true) {
    var i = _i;
    var acc = _acc;
    if (i >= n) {
      return acc;
    }
    _i = i + 1 | 0;
    _acc = {
      hd: curry._1(f, i),
      tl: acc
    };
    continue ;
  }}

function init_aux(i, n, f) {
  if (i >= n) {
    return /* [] */0;
  }
  var r = curry._1(f, i);
  return {
          hd: r,
          tl: init_aux(i + 1 | 0, n, f)
        };
}

function init(len, f) {
  if (len < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.init",
          Error: new Error()
        };
  }
  if (len > 10000) {
    return rev_append(init_tailrec_aux(/* [] */0, 0, len, f), /* [] */0);
  } else {
    return init_aux(0, len, f);
  }
}

function flatten(param) {
  if (param) {
    return pervasives.$at(param.hd, flatten(param.tl));
  } else {
    return /* [] */0;
  }
}

function map(f, param) {
  if (!param) {
    return /* [] */0;
  }
  var r = curry._1(f, param.hd);
  return {
          hd: r,
          tl: map(f, param.tl)
        };
}

function mapi(i, f, param) {
  if (!param) {
    return /* [] */0;
  }
  var r = curry._2(f, i, param.hd);
  return {
          hd: r,
          tl: mapi(i + 1 | 0, f, param.tl)
        };
}

function mapi$1(f, l) {
  return mapi(0, f, l);
}

function rev_map(f, l) {
  var _accu = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = {
      hd: curry._1(f, param.hd),
      tl: accu
    };
    continue ;
  }}

function iter(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    curry._1(f, param.hd);
    _param = param.tl;
    continue ;
  }}

function iteri(f, l) {
  var _i = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return ;
    }
    curry._2(f, i, param.hd);
    _param = param.tl;
    _i = i + 1 | 0;
    continue ;
  }}

function fold_left(f, _accu, _l) {
  while(true) {
    var l = _l;
    var accu = _accu;
    if (!l) {
      return accu;
    }
    _l = l.tl;
    _accu = curry._2(f, accu, l.hd);
    continue ;
  }}

function fold_right(f, l, accu) {
  if (l) {
    return curry._2(f, l.hd, fold_right(f, l.tl, accu));
  } else {
    return accu;
  }
}

function map2(f, l1, l2) {
  if (l1) {
    if (l2) {
      var r = curry._2(f, l1.hd, l2.hd);
      return {
              hd: r,
              tl: map2(f, l1.tl, l2.tl)
            };
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.map2",
          Error: new Error()
        };
  }
  if (!l2) {
    return /* [] */0;
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "List.map2",
        Error: new Error()
      };
}

function rev_map2(f, l1, l2) {
  var _accu = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var accu = _accu;
    if (l1$1) {
      if (l2$1) {
        _l2 = l2$1.tl;
        _l1 = l1$1.tl;
        _accu = {
          hd: curry._2(f, l1$1.hd, l2$1.hd),
          tl: accu
        };
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.rev_map2",
            Error: new Error()
          };
    }
    if (l2$1) {
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.rev_map2",
            Error: new Error()
          };
    }
    return accu;
  }}

function iter2(f, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        curry._2(f, l1.hd, l2.hd);
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.iter2",
            Error: new Error()
          };
    }
    if (!l2) {
      return ;
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.iter2",
          Error: new Error()
        };
  }}

function fold_left2(f, _accu, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var accu = _accu;
    if (l1) {
      if (l2) {
        _l2 = l2.tl;
        _l1 = l1.tl;
        _accu = curry._3(f, accu, l1.hd, l2.hd);
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.fold_left2",
            Error: new Error()
          };
    }
    if (l2) {
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.fold_left2",
            Error: new Error()
          };
    }
    return accu;
  }}

function fold_right2(f, l1, l2, accu) {
  if (l1) {
    if (l2) {
      return curry._3(f, l1.hd, l2.hd, fold_right2(f, l1.tl, l2.tl, accu));
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.fold_right2",
          Error: new Error()
        };
  }
  if (l2) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.fold_right2",
          Error: new Error()
        };
  }
  return accu;
}

function for_all(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return true;
    }
    if (!curry._1(p, param.hd)) {
      return false;
    }
    _param = param.tl;
    continue ;
  }}

function exists(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (curry._1(p, param.hd)) {
      return true;
    }
    _param = param.tl;
    continue ;
  }}

function for_all2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (!curry._2(p, l1.hd, l2.hd)) {
          return false;
        }
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.for_all2",
            Error: new Error()
          };
    }
    if (!l2) {
      return true;
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.for_all2",
          Error: new Error()
        };
  }}

function exists2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (curry._2(p, l1.hd, l2.hd)) {
          return true;
        }
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "List.exists2",
            Error: new Error()
          };
    }
    if (!l2) {
      return false;
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.exists2",
          Error: new Error()
        };
  }}

function mem(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (caml_obj.caml_equal(param.hd, x)) {
      return true;
    }
    _param = param.tl;
    continue ;
  }}

function memq(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (param.hd === x) {
      return true;
    }
    _param = param.tl;
    continue ;
  }}

function assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param.hd;
      if (caml_obj.caml_equal(match[0], x)) {
        return match[1];
      }
      _param = param.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }}

function assoc_opt(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var match = param.hd;
    if (caml_obj.caml_equal(match[0], x)) {
      return caml_option.some(match[1]);
    }
    _param = param.tl;
    continue ;
  }}

function assq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param.hd;
      if (match[0] === x) {
        return match[1];
      }
      _param = param.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }}

function assq_opt(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var match = param.hd;
    if (match[0] === x) {
      return caml_option.some(match[1]);
    }
    _param = param.tl;
    continue ;
  }}

function mem_assoc(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (caml_obj.caml_equal(param.hd[0], x)) {
      return true;
    }
    _param = param.tl;
    continue ;
  }}

function mem_assq(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (param.hd[0] === x) {
      return true;
    }
    _param = param.tl;
    continue ;
  }}

function remove_assoc(x, param) {
  if (!param) {
    return /* [] */0;
  }
  var l = param.tl;
  var pair = param.hd;
  if (caml_obj.caml_equal(pair[0], x)) {
    return l;
  } else {
    return {
            hd: pair,
            tl: remove_assoc(x, l)
          };
  }
}

function remove_assq(x, param) {
  if (!param) {
    return /* [] */0;
  }
  var l = param.tl;
  var pair = param.hd;
  if (pair[0] === x) {
    return l;
  } else {
    return {
            hd: pair,
            tl: remove_assq(x, l)
          };
  }
}

function find(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var x = param.hd;
      if (curry._1(p, x)) {
        return x;
      }
      _param = param.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }}

function find_opt(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var x = param.hd;
    if (curry._1(p, x)) {
      return caml_option.some(x);
    }
    _param = param.tl;
    continue ;
  }}

function find_all(p) {
  return function (param) {
    var _accu = /* [] */0;
    var _param = param;
    while(true) {
      var param$1 = _param;
      var accu = _accu;
      if (!param$1) {
        return rev_append(accu, /* [] */0);
      }
      var l = param$1.tl;
      var x = param$1.hd;
      if (curry._1(p, x)) {
        _param = l;
        _accu = {
          hd: x,
          tl: accu
        };
        continue ;
      }
      _param = l;
      continue ;
    }  };
}

function partition(p, l) {
  var _yes = /* [] */0;
  var _no = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var no = _no;
    var yes = _yes;
    if (!param) {
      return [
              rev_append(yes, /* [] */0),
              rev_append(no, /* [] */0)
            ];
    }
    var l$1 = param.tl;
    var x = param.hd;
    if (curry._1(p, x)) {
      _param = l$1;
      _yes = {
        hd: x,
        tl: yes
      };
      continue ;
    }
    _param = l$1;
    _no = {
      hd: x,
      tl: no
    };
    continue ;
  }}

function split(param) {
  if (!param) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var match = param.hd;
  var match$1 = split(param.tl);
  return [
          {
            hd: match[0],
            tl: match$1[0]
          },
          {
            hd: match[1],
            tl: match$1[1]
          }
        ];
}

function combine(l1, l2) {
  if (l1) {
    if (l2) {
      return {
              hd: [
                l1.hd,
                l2.hd
              ],
              tl: combine(l1.tl, l2.tl)
            };
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "List.combine",
          Error: new Error()
        };
  }
  if (!l2) {
    return /* [] */0;
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "List.combine",
        Error: new Error()
      };
}

function merge(cmp, l1, l2) {
  if (!l1) {
    return l2;
  }
  if (!l2) {
    return l1;
  }
  var h2 = l2.hd;
  var h1 = l1.hd;
  if (curry._2(cmp, h1, h2) <= 0) {
    return {
            hd: h1,
            tl: merge(cmp, l1.tl, l2)
          };
  } else {
    return {
            hd: h2,
            tl: merge(cmp, l1, l2.tl)
          };
  }
}

function chop(_k, _l) {
  while(true) {
    var l = _l;
    var k = _k;
    if (k === 0) {
      return l;
    }
    if (l) {
      _l = l.tl;
      _k = k - 1 | 0;
      continue ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "list.ml",
            262,
            11
          ],
          Error: new Error()
        };
  }}

function stable_sort(cmp, l) {
  var sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            if (curry._2(cmp, x1, x2) <= 0) {
              if (curry._2(cmp, x2, x3) <= 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: /* [] */0
                          }
                        }
                      };
              } else if (curry._2(cmp, x1, x3) <= 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              }
            } else if (curry._2(cmp, x1, x3) <= 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    };
            } else if (curry._2(cmp, x2, x3) <= 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            } else {
              return {
                      hd: x3,
                      tl: {
                        hd: x2,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        if (curry._2(cmp, x1$1, x2$1) <= 0) {
          return {
                  hd: x1$1,
                  tl: {
                    hd: x2$1,
                    tl: /* [] */0
                  }
                };
        } else {
          return {
                  hd: x2$1,
                  tl: {
                    hd: x1$1,
                    tl: /* [] */0
                  }
                };
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = rev_sort(n1, l);
    var s2 = rev_sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2$1, accu);
      }
      if (!l2$1) {
        return rev_append(l1, accu);
      }
      var h2 = l2$1.hd;
      var h1 = l1.hd;
      if (curry._2(cmp, h1, h2) > 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = l1.tl;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = l2$1.tl;
      continue ;
    }  };
  var rev_sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            if (curry._2(cmp, x1, x2) > 0) {
              if (curry._2(cmp, x2, x3) > 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: /* [] */0
                          }
                        }
                      };
              } else if (curry._2(cmp, x1, x3) > 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              }
            } else if (curry._2(cmp, x1, x3) > 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    };
            } else if (curry._2(cmp, x2, x3) > 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            } else {
              return {
                      hd: x3,
                      tl: {
                        hd: x2,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        if (curry._2(cmp, x1$1, x2$1) > 0) {
          return {
                  hd: x1$1,
                  tl: {
                    hd: x2$1,
                    tl: /* [] */0
                  }
                };
        } else {
          return {
                  hd: x2$1,
                  tl: {
                    hd: x1$1,
                    tl: /* [] */0
                  }
                };
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = sort(n1, l);
    var s2 = sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2$1, accu);
      }
      if (!l2$1) {
        return rev_append(l1, accu);
      }
      var h2 = l2$1.hd;
      var h1 = l1.hd;
      if (curry._2(cmp, h1, h2) <= 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = l1.tl;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = l2$1.tl;
      continue ;
    }  };
  var len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l);
  }
}

function sort_uniq(cmp, l) {
  var sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            var c = curry._2(cmp, x1, x2);
            if (c === 0) {
              var c$1 = curry._2(cmp, x2, x3);
              if (c$1 === 0) {
                return {
                        hd: x2,
                        tl: /* [] */0
                      };
              } else if (c$1 < 0) {
                return {
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              }
            }
            if (c < 0) {
              var c$2 = curry._2(cmp, x2, x3);
              if (c$2 === 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              }
              if (c$2 < 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: /* [] */0
                          }
                        }
                      };
              }
              var c$3 = curry._2(cmp, x1, x3);
              if (c$3 === 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              } else if (c$3 < 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              }
            }
            var c$4 = curry._2(cmp, x1, x3);
            if (c$4 === 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: /* [] */0
                      }
                    };
            }
            if (c$4 < 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    };
            }
            var c$5 = curry._2(cmp, x2, x3);
            if (c$5 === 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: /* [] */0
                      }
                    };
            } else if (c$5 < 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            } else {
              return {
                      hd: x3,
                      tl: {
                        hd: x2,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        var c$6 = curry._2(cmp, x1$1, x2$1);
        if (c$6 === 0) {
          return {
                  hd: x1$1,
                  tl: /* [] */0
                };
        } else if (c$6 < 0) {
          return {
                  hd: x1$1,
                  tl: {
                    hd: x2$1,
                    tl: /* [] */0
                  }
                };
        } else {
          return {
                  hd: x2$1,
                  tl: {
                    hd: x1$1,
                    tl: /* [] */0
                  }
                };
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = rev_sort(n1, l);
    var s2 = rev_sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2$1, accu);
      }
      if (!l2$1) {
        return rev_append(l1, accu);
      }
      var t2 = l2$1.tl;
      var h2 = l2$1.hd;
      var t1 = l1.tl;
      var h1 = l1.hd;
      var c$7 = curry._2(cmp, h1, h2);
      if (c$7 === 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l2 = t2;
        _l1 = t1;
        continue ;
      }
      if (c$7 > 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = t1;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = t2;
      continue ;
    }  };
  var rev_sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            var c = curry._2(cmp, x1, x2);
            if (c === 0) {
              var c$1 = curry._2(cmp, x2, x3);
              if (c$1 === 0) {
                return {
                        hd: x2,
                        tl: /* [] */0
                      };
              } else if (c$1 > 0) {
                return {
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              }
            }
            if (c > 0) {
              var c$2 = curry._2(cmp, x2, x3);
              if (c$2 === 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              }
              if (c$2 > 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: /* [] */0
                          }
                        }
                      };
              }
              var c$3 = curry._2(cmp, x1, x3);
              if (c$3 === 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      };
              } else if (c$3 > 0) {
                return {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              } else {
                return {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: {
                            hd: x2,
                            tl: /* [] */0
                          }
                        }
                      };
              }
            }
            var c$4 = curry._2(cmp, x1, x3);
            if (c$4 === 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: /* [] */0
                      }
                    };
            }
            if (c$4 > 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    };
            }
            var c$5 = curry._2(cmp, x2, x3);
            if (c$5 === 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: /* [] */0
                      }
                    };
            } else if (c$5 > 0) {
              return {
                      hd: x2,
                      tl: {
                        hd: x3,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            } else {
              return {
                      hd: x3,
                      tl: {
                        hd: x2,
                        tl: {
                          hd: x1,
                          tl: /* [] */0
                        }
                      }
                    };
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        var c$6 = curry._2(cmp, x1$1, x2$1);
        if (c$6 === 0) {
          return {
                  hd: x1$1,
                  tl: /* [] */0
                };
        } else if (c$6 > 0) {
          return {
                  hd: x1$1,
                  tl: {
                    hd: x2$1,
                    tl: /* [] */0
                  }
                };
        } else {
          return {
                  hd: x2$1,
                  tl: {
                    hd: x1$1,
                    tl: /* [] */0
                  }
                };
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = sort(n1, l);
    var s2 = sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2$1, accu);
      }
      if (!l2$1) {
        return rev_append(l1, accu);
      }
      var t2 = l2$1.tl;
      var h2 = l2$1.hd;
      var t1 = l1.tl;
      var h1 = l1.hd;
      var c$7 = curry._2(cmp, h1, h2);
      if (c$7 === 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l2 = t2;
        _l1 = t1;
        continue ;
      }
      if (c$7 < 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = t1;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = t2;
      continue ;
    }  };
  var len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l);
  }
}

function compare_lengths(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  }}

function compare_length_with(_l, _n) {
  while(true) {
    var n = _n;
    var l = _l;
    if (!l) {
      if (n === 0) {
        return 0;
      } else if (n > 0) {
        return -1;
      } else {
        return 1;
      }
    }
    if (n <= 0) {
      return 1;
    }
    _n = n - 1 | 0;
    _l = l.tl;
    continue ;
  }}

var append = pervasives.$at;

var concat = flatten;

var filter = find_all;

var sort = stable_sort;

var fast_sort = stable_sort;

var length_1 = length;
var compare_lengths_1 = compare_lengths;
var compare_length_with_1 = compare_length_with;
var cons_1 = cons;
var hd_1 = hd;
var tl_1 = tl;
var nth_1 = nth;
var nth_opt_1 = nth_opt;
var rev_1 = rev;
var init_1 = init;
var append_1 = append;
var rev_append_1 = rev_append;
var concat_1 = concat;
var flatten_1 = flatten;
var iter_1 = iter;
var iteri_1 = iteri;
var map_1 = map;
var mapi_1 = mapi$1;
var rev_map_1 = rev_map;
var fold_left_1 = fold_left;
var fold_right_1 = fold_right;
var iter2_1 = iter2;
var map2_1 = map2;
var rev_map2_1 = rev_map2;
var fold_left2_1 = fold_left2;
var fold_right2_1 = fold_right2;
var for_all_1 = for_all;
var exists_1 = exists;
var for_all2_1 = for_all2;
var exists2_1 = exists2;
var mem_1 = mem;
var memq_1 = memq;
var find_1 = find;
var find_opt_1 = find_opt;
var filter_1 = filter;
var find_all_1 = find_all;
var partition_1 = partition;
var assoc_1 = assoc;
var assoc_opt_1 = assoc_opt;
var assq_1 = assq;
var assq_opt_1 = assq_opt;
var mem_assoc_1 = mem_assoc;
var mem_assq_1 = mem_assq;
var remove_assoc_1 = remove_assoc;
var remove_assq_1 = remove_assq;
var split_1 = split;
var combine_1 = combine;
var sort_1 = sort;
var stable_sort_1 = stable_sort;
var fast_sort_1 = fast_sort;
var sort_uniq_1 = sort_uniq;
var merge_1 = merge;
/* No side effect */

var list = {
	length: length_1,
	compare_lengths: compare_lengths_1,
	compare_length_with: compare_length_with_1,
	cons: cons_1,
	hd: hd_1,
	tl: tl_1,
	nth: nth_1,
	nth_opt: nth_opt_1,
	rev: rev_1,
	init: init_1,
	append: append_1,
	rev_append: rev_append_1,
	concat: concat_1,
	flatten: flatten_1,
	iter: iter_1,
	iteri: iteri_1,
	map: map_1,
	mapi: mapi_1,
	rev_map: rev_map_1,
	fold_left: fold_left_1,
	fold_right: fold_right_1,
	iter2: iter2_1,
	map2: map2_1,
	rev_map2: rev_map2_1,
	fold_left2: fold_left2_1,
	fold_right2: fold_right2_1,
	for_all: for_all_1,
	exists: exists_1,
	for_all2: for_all2_1,
	exists2: exists2_1,
	mem: mem_1,
	memq: memq_1,
	find: find_1,
	find_opt: find_opt_1,
	filter: filter_1,
	find_all: find_all_1,
	partition: partition_1,
	assoc: assoc_1,
	assoc_opt: assoc_opt_1,
	assq: assq_1,
	assq_opt: assq_opt_1,
	mem_assoc: mem_assoc_1,
	mem_assq: mem_assq_1,
	remove_assoc: remove_assoc_1,
	remove_assq: remove_assq_1,
	split: split_1,
	combine: combine_1,
	sort: sort_1,
	stable_sort: stable_sort_1,
	fast_sort: fast_sort_1,
	sort_uniq: sort_uniq_1,
	merge: merge_1
};

function chr(n) {
  if (n < 0 || n > 255) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Char.chr",
          Error: new Error()
        };
  }
  return n;
}

function escaped(c) {
  var exit = 0;
  if (c >= 40) {
    if (c === 92) {
      return "\\\\";
    }
    exit = c >= 127 ? 1 : 2;
  } else if (c >= 32) {
    if (c >= 39) {
      return "\\'";
    }
    exit = 2;
  } else if (c >= 14) {
    exit = 1;
  } else {
    switch (c) {
      case 8 :
          return "\\b";
      case 9 :
          return "\\t";
      case 10 :
          return "\\n";
      case 0 :
      case 1 :
      case 2 :
      case 3 :
      case 4 :
      case 5 :
      case 6 :
      case 7 :
      case 11 :
      case 12 :
          exit = 1;
          break;
      case 13 :
          return "\\r";
      
    }
  }
  switch (exit) {
    case 1 :
        var s = [
          0,
          0,
          0,
          0
        ];
        s[0] = /* "\\" */92;
        s[1] = 48 + (c / 100 | 0) | 0;
        s[2] = 48 + (c / 10 | 0) % 10 | 0;
        s[3] = 48 + c % 10 | 0;
        return caml_bytes.bytes_to_string(s);
    case 2 :
        var s$1 = [0];
        s$1[0] = c;
        return caml_bytes.bytes_to_string(s$1);
    
  }
}

function lowercase$1(c) {
  if (c >= /* "A" */65 && c <= /* "Z" */90 || c >= /* "\192" */192 && c <= /* "\214" */214 || c >= /* "\216" */216 && c <= /* "\222" */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function uppercase(c) {
  if (c >= /* "a" */97 && c <= /* "z" */122 || c >= /* "\224" */224 && c <= /* "\246" */246 || c >= /* "\248" */248 && c <= /* "\254" */254) {
    return c - 32 | 0;
  } else {
    return c;
  }
}

function lowercase_ascii(c) {
  if (c >= /* "A" */65 && c <= /* "Z" */90) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function uppercase_ascii(c) {
  if (c >= /* "a" */97 && c <= /* "z" */122) {
    return c - 32 | 0;
  } else {
    return c;
  }
}

function compare$1(c1, c2) {
  return c1 - c2 | 0;
}

function equal(c1, c2) {
  return (c1 - c2 | 0) === 0;
}

var chr_1 = chr;
var escaped_1 = escaped;
var lowercase_1 = lowercase$1;
var uppercase_1 = uppercase;
var lowercase_ascii_1 = lowercase_ascii;
var uppercase_ascii_1 = uppercase_ascii;
var compare_1$1 = compare$1;
var equal_1 = equal;
/* No side effect */

var char = {
	chr: chr_1,
	escaped: escaped_1,
	lowercase: lowercase_1,
	uppercase: uppercase_1,
	lowercase_ascii: lowercase_ascii_1,
	uppercase_ascii: uppercase_ascii_1,
	compare: compare_1$1,
	equal: equal_1
};

function make$1(n, c) {
  var s = caml_bytes.caml_create_bytes(n);
  caml_bytes.caml_fill_bytes(s, 0, n, c);
  return s;
}

function init$1(n, f) {
  var s = caml_bytes.caml_create_bytes(n);
  for(var i = 0; i < n; ++i){
    s[i] = curry._1(f, i);
  }
  return s;
}

var empty = [];

function copy(s) {
  var len = s.length;
  var r = caml_bytes.caml_create_bytes(len);
  caml_bytes.caml_blit_bytes(s, 0, r, 0, len);
  return r;
}

function to_string$1(b) {
  return caml_bytes.bytes_to_string(copy(b));
}

function of_string(s) {
  return copy(caml_bytes.bytes_of_string(s));
}

function sub$1(s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.sub / Bytes.sub",
          Error: new Error()
        };
  }
  var r = caml_bytes.caml_create_bytes(len);
  caml_bytes.caml_blit_bytes(s, ofs, r, 0, len);
  return r;
}

function sub_string(b, ofs, len) {
  return caml_bytes.bytes_to_string(sub$1(b, ofs, len));
}

function $plus$plus(a, b) {
  var c = a + b | 0;
  var match = a < 0;
  var match$1 = b < 0;
  var match$2 = c < 0;
  if (match) {
    if (!match$1) {
      return c;
    }
    if (match$2) {
      return c;
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Bytes.extend",
          Error: new Error()
        };
  }
  if (match$1) {
    return c;
  }
  if (match$2) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Bytes.extend",
          Error: new Error()
        };
  }
  return c;
}

function extend(s, left, right) {
  var len = $plus$plus($plus$plus(s.length, left), right);
  var r = caml_bytes.caml_create_bytes(len);
  var match = left < 0 ? [
      -left | 0,
      0
    ] : [
      0,
      left
    ];
  var dstoff = match[1];
  var srcoff = match[0];
  var cpylen = caml_primitive.caml_int_min(s.length - srcoff | 0, len - dstoff | 0);
  if (cpylen > 0) {
    caml_bytes.caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
  }
  return r;
}

function fill$1(s, ofs, len, c) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.fill / Bytes.fill",
          Error: new Error()
        };
  }
  return caml_bytes.caml_fill_bytes(s, ofs, len, c);
}

function blit(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Bytes.blit",
          Error: new Error()
        };
  }
  return caml_bytes.caml_blit_bytes(s1, ofs1, s2, ofs2, len);
}

function blit_string(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.blit / Bytes.blit_string",
          Error: new Error()
        };
  }
  return caml_bytes.caml_blit_string(s1, ofs1, s2, ofs2, len);
}

function iter$1(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    curry._1(f, a[i]);
  }
  
}

function iteri$1(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    curry._2(f, i, a[i]);
  }
  
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "Bytes.concat",
        Error: new Error()
      };
}

function sum_lengths(_acc, seplen, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return acc;
    }
    var tl = param.tl;
    var hd = param.hd;
    if (!tl) {
      return hd.length + acc | 0;
    }
    _param = tl;
    _acc = ensure_ge((hd.length + seplen | 0) + acc | 0, acc);
    continue ;
  }}

function concat$1(sep, l) {
  if (!l) {
    return empty;
  }
  var seplen = sep.length;
  var dst = caml_bytes.caml_create_bytes(sum_lengths(0, seplen, l));
  var _pos = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var pos = _pos;
    if (!param) {
      return dst;
    }
    var tl = param.tl;
    var hd = param.hd;
    if (tl) {
      caml_bytes.caml_blit_bytes(hd, 0, dst, pos, hd.length);
      caml_bytes.caml_blit_bytes(sep, 0, dst, pos + hd.length | 0, seplen);
      _param = tl;
      _pos = (pos + hd.length | 0) + seplen | 0;
      continue ;
    }
    caml_bytes.caml_blit_bytes(hd, 0, dst, pos, hd.length);
    return dst;
  }}

function cat(s1, s2) {
  var l1 = s1.length;
  var l2 = s2.length;
  var r = caml_bytes.caml_create_bytes(l1 + l2 | 0);
  caml_bytes.caml_blit_bytes(s1, 0, r, 0, l1);
  caml_bytes.caml_blit_bytes(s2, 0, r, l1, l2);
  return r;
}

function is_space(param) {
  var switcher = param - 9 | 0;
  if (switcher > 4 || switcher < 0) {
    return switcher === 23;
  } else {
    return switcher !== 2;
  }
}

function trim(s) {
  var len = s.length;
  var i = 0;
  while(i < len && is_space(s[i])) {
    i = i + 1 | 0;
  }  var j = len - 1 | 0;
  while(j >= i && is_space(s[j])) {
    j = j - 1 | 0;
  }  if (j >= i) {
    return sub$1(s, i, (j - i | 0) + 1 | 0);
  } else {
    return empty;
  }
}

function escaped$1(s) {
  var n = 0;
  for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
    var match = s[i];
    var tmp;
    if (match >= 32) {
      var switcher = match - 34 | 0;
      tmp = switcher > 58 || switcher < 0 ? (
          switcher >= 93 ? 4 : 1
        ) : (
          switcher > 57 || switcher < 1 ? 2 : 1
        );
    } else {
      tmp = match >= 11 ? (
          match !== 13 ? 4 : 2
        ) : (
          match >= 8 ? 2 : 4
        );
    }
    n = n + tmp | 0;
  }
  if (n === s.length) {
    return copy(s);
  }
  var s$prime = caml_bytes.caml_create_bytes(n);
  n = 0;
  for(var i$1 = 0 ,i_finish$1 = s.length; i$1 < i_finish$1; ++i$1){
    var c = s[i$1];
    var exit = 0;
    if (c >= 35) {
      if (c !== 92) {
        if (c >= 127) {
          exit = 1;
        } else {
          s$prime[n] = c;
        }
      } else {
        exit = 2;
      }
    } else if (c >= 32) {
      if (c >= 34) {
        exit = 2;
      } else {
        s$prime[n] = c;
      }
    } else if (c >= 14) {
      exit = 1;
    } else {
      switch (c) {
        case 8 :
            s$prime[n] = /* "\\" */92;
            n = n + 1 | 0;
            s$prime[n] = /* "b" */98;
            break;
        case 9 :
            s$prime[n] = /* "\\" */92;
            n = n + 1 | 0;
            s$prime[n] = /* "t" */116;
            break;
        case 10 :
            s$prime[n] = /* "\\" */92;
            n = n + 1 | 0;
            s$prime[n] = /* "n" */110;
            break;
        case 0 :
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
        case 6 :
        case 7 :
        case 11 :
        case 12 :
            exit = 1;
            break;
        case 13 :
            s$prime[n] = /* "\\" */92;
            n = n + 1 | 0;
            s$prime[n] = /* "r" */114;
            break;
        
      }
    }
    switch (exit) {
      case 1 :
          s$prime[n] = /* "\\" */92;
          n = n + 1 | 0;
          s$prime[n] = 48 + (c / 100 | 0) | 0;
          n = n + 1 | 0;
          s$prime[n] = 48 + (c / 10 | 0) % 10 | 0;
          n = n + 1 | 0;
          s$prime[n] = 48 + c % 10 | 0;
          break;
      case 2 :
          s$prime[n] = /* "\\" */92;
          n = n + 1 | 0;
          s$prime[n] = c;
          break;
      
    }
    n = n + 1 | 0;
  }
  return s$prime;
}

function map$1(f, s) {
  var l = s.length;
  if (l === 0) {
    return s;
  }
  var r = caml_bytes.caml_create_bytes(l);
  for(var i = 0; i < l; ++i){
    r[i] = curry._1(f, s[i]);
  }
  return r;
}

function mapi$2(f, s) {
  var l = s.length;
  if (l === 0) {
    return s;
  }
  var r = caml_bytes.caml_create_bytes(l);
  for(var i = 0; i < l; ++i){
    r[i] = curry._2(f, i, s[i]);
  }
  return r;
}

function uppercase_ascii$1(s) {
  return map$1(char.uppercase_ascii, s);
}

function lowercase_ascii$1(s) {
  return map$1(char.lowercase_ascii, s);
}

function apply1(f, s) {
  if (s.length === 0) {
    return s;
  }
  var r = copy(s);
  r[0] = curry._1(f, s[0]);
  return r;
}

function capitalize_ascii(s) {
  return apply1(char.uppercase_ascii, s);
}

function uncapitalize_ascii(s) {
  return apply1(char.lowercase_ascii, s);
}

function index_rec(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    if (s[i] === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  }}

function index(s, c) {
  return index_rec(s, s.length, 0, c);
}

function index_rec_opt(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      return ;
    }
    if (s[i] === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  }}

function index_opt(s, c) {
  return index_rec_opt(s, s.length, 0, c);
}

function index_from(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.index_from / Bytes.index_from",
          Error: new Error()
        };
  }
  return index_rec(s, l, i, c);
}

function index_from_opt(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.index_from_opt / Bytes.index_from_opt",
          Error: new Error()
        };
  }
  return index_rec_opt(s, l, i, c);
}

function rindex_rec(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    if (s[i] === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue ;
  }}

function rindex(s, c) {
  return rindex_rec(s, s.length - 1 | 0, c);
}

function rindex_from(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from / Bytes.rindex_from",
          Error: new Error()
        };
  }
  return rindex_rec(s, i, c);
}

function rindex_rec_opt(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      return ;
    }
    if (s[i] === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue ;
  }}

function rindex_opt(s, c) {
  return rindex_rec_opt(s, s.length - 1 | 0, c);
}

function rindex_from_opt(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from_opt / Bytes.rindex_from_opt",
          Error: new Error()
        };
  }
  return rindex_rec_opt(s, i, c);
}

function contains_from(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.contains_from / Bytes.contains_from",
          Error: new Error()
        };
  }
  try {
    index_rec(s, l, i, c);
    return true;
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return false;
    }
    throw exn;
  }
}

function contains(s, c) {
  return contains_from(s, 0, c);
}

function rcontains_from(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.rcontains_from / Bytes.rcontains_from",
          Error: new Error()
        };
  }
  try {
    rindex_rec(s, i, c);
    return true;
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return false;
    }
    throw exn;
  }
}

var compare$2 = caml_bytes.caml_bytes_compare;

function uppercase$1(s) {
  return map$1(char.uppercase, s);
}

function lowercase$2(s) {
  return map$1(char.lowercase, s);
}

function capitalize(s) {
  return apply1(char.uppercase, s);
}

function uncapitalize(s) {
  return apply1(char.lowercase, s);
}

var equal$1 = caml_bytes.caml_bytes_equal;

var unsafe_to_string = caml_bytes.bytes_to_string;

var unsafe_of_string = caml_bytes.bytes_of_string;

var make_1$1 = make$1;
var init_1$1 = init$1;
var empty_1 = empty;
var copy_1 = copy;
var of_string_1 = of_string;
var to_string_1$1 = to_string$1;
var sub_1$1 = sub$1;
var sub_string_1 = sub_string;
var extend_1 = extend;
var fill_1 = fill$1;
var blit_1 = blit;
var blit_string_1 = blit_string;
var concat_1$1 = concat$1;
var cat_1 = cat;
var iter_1$1 = iter$1;
var iteri_1$1 = iteri$1;
var map_1$1 = map$1;
var mapi_1$1 = mapi$2;
var trim_1 = trim;
var escaped_1$1 = escaped$1;
var index_1 = index;
var index_opt_1 = index_opt;
var rindex_1 = rindex;
var rindex_opt_1 = rindex_opt;
var index_from_1 = index_from;
var index_from_opt_1 = index_from_opt;
var rindex_from_1 = rindex_from;
var rindex_from_opt_1 = rindex_from_opt;
var contains_1 = contains;
var contains_from_1 = contains_from;
var rcontains_from_1 = rcontains_from;
var uppercase_1$1 = uppercase$1;
var lowercase_1$1 = lowercase$2;
var capitalize_1 = capitalize;
var uncapitalize_1 = uncapitalize;
var uppercase_ascii_1$1 = uppercase_ascii$1;
var lowercase_ascii_1$1 = lowercase_ascii$1;
var capitalize_ascii_1 = capitalize_ascii;
var uncapitalize_ascii_1 = uncapitalize_ascii;
var compare_1$2 = compare$2;
var equal_1$1 = equal$1;
var unsafe_to_string_1 = unsafe_to_string;
var unsafe_of_string_1 = unsafe_of_string;
/* No side effect */

var bytes = {
	make: make_1$1,
	init: init_1$1,
	empty: empty_1,
	copy: copy_1,
	of_string: of_string_1,
	to_string: to_string_1$1,
	sub: sub_1$1,
	sub_string: sub_string_1,
	extend: extend_1,
	fill: fill_1,
	blit: blit_1,
	blit_string: blit_string_1,
	concat: concat_1$1,
	cat: cat_1,
	iter: iter_1$1,
	iteri: iteri_1$1,
	map: map_1$1,
	mapi: mapi_1$1,
	trim: trim_1,
	escaped: escaped_1$1,
	index: index_1,
	index_opt: index_opt_1,
	rindex: rindex_1,
	rindex_opt: rindex_opt_1,
	index_from: index_from_1,
	index_from_opt: index_from_opt_1,
	rindex_from: rindex_from_1,
	rindex_from_opt: rindex_from_opt_1,
	contains: contains_1,
	contains_from: contains_from_1,
	rcontains_from: rcontains_from_1,
	uppercase: uppercase_1$1,
	lowercase: lowercase_1$1,
	capitalize: capitalize_1,
	uncapitalize: uncapitalize_1,
	uppercase_ascii: uppercase_ascii_1$1,
	lowercase_ascii: lowercase_ascii_1$1,
	capitalize_ascii: capitalize_ascii_1,
	uncapitalize_ascii: uncapitalize_ascii_1,
	compare: compare_1$2,
	equal: equal_1$1,
	unsafe_to_string: unsafe_to_string_1,
	unsafe_of_string: unsafe_of_string_1
};

function init$2(n, f) {
  return caml_bytes.bytes_to_string(bytes.init(n, f));
}

function copy$1(s) {
  return caml_bytes.bytes_to_string(bytes.copy(caml_bytes.bytes_of_string(s)));
}

function sub$2(s, ofs, len) {
  return caml_bytes.bytes_to_string(bytes.sub(caml_bytes.bytes_of_string(s), ofs, len));
}

function ensure_ge$1(x, y) {
  if (x >= y) {
    return x;
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "String.concat",
        Error: new Error()
      };
}

function sum_lengths$1(_acc, seplen, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return acc;
    }
    var tl = param.tl;
    var hd = param.hd;
    if (!tl) {
      return hd.length + acc | 0;
    }
    _param = tl;
    _acc = ensure_ge$1((hd.length + seplen | 0) + acc | 0, acc);
    continue ;
  }}

function unsafe_blits(dst, _pos, sep, seplen, _param) {
  while(true) {
    var param = _param;
    var pos = _pos;
    if (!param) {
      return dst;
    }
    var tl = param.tl;
    var hd = param.hd;
    if (tl) {
      caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
      caml_bytes.caml_blit_string(sep, 0, dst, pos + hd.length | 0, seplen);
      _param = tl;
      _pos = (pos + hd.length | 0) + seplen | 0;
      continue ;
    }
    caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
    return dst;
  }}

function concat$2(sep, l) {
  if (!l) {
    return "";
  }
  var seplen = sep.length;
  return caml_bytes.bytes_to_string(unsafe_blits(caml_bytes.caml_create_bytes(sum_lengths$1(0, seplen, l)), 0, sep, seplen, l));
}

function iter$2(f, s) {
  for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
    curry._1(f, s.charCodeAt(i));
  }
  
}

function iteri$2(f, s) {
  for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
    curry._2(f, i, s.charCodeAt(i));
  }
  
}

function map$2(f, s) {
  return caml_bytes.bytes_to_string(bytes.map(f, caml_bytes.bytes_of_string(s)));
}

function mapi$3(f, s) {
  return caml_bytes.bytes_to_string(bytes.mapi(f, caml_bytes.bytes_of_string(s)));
}

function is_space$1(param) {
  var switcher = param - 9 | 0;
  if (switcher > 4 || switcher < 0) {
    return switcher === 23;
  } else {
    return switcher !== 2;
  }
}

function trim$1(s) {
  if (s === "" || !(is_space$1(s.charCodeAt(0)) || is_space$1(s.charCodeAt(s.length - 1 | 0)))) {
    return s;
  } else {
    return caml_bytes.bytes_to_string(bytes.trim(caml_bytes.bytes_of_string(s)));
  }
}

function escaped$2(s) {
  var needs_escape = function (_i) {
    while(true) {
      var i = _i;
      if (i >= s.length) {
        return false;
      }
      var match = s.charCodeAt(i);
      if (match < 32) {
        return true;
      }
      var switcher = match - 34 | 0;
      if (switcher > 58 || switcher < 0) {
        if (switcher >= 93) {
          return true;
        }
        _i = i + 1 | 0;
        continue ;
      }
      if (switcher > 57 || switcher < 1) {
        return true;
      }
      _i = i + 1 | 0;
      continue ;
    }  };
  if (needs_escape(0)) {
    return caml_bytes.bytes_to_string(bytes.escaped(caml_bytes.bytes_of_string(s)));
  } else {
    return s;
  }
}

function index_rec$1(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  }}

function index$1(s, c) {
  return index_rec$1(s, s.length, 0, c);
}

function index_rec_opt$1(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      return ;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  }}

function index_opt$1(s, c) {
  return index_rec_opt$1(s, s.length, 0, c);
}

function index_from$1(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.index_from / Bytes.index_from",
          Error: new Error()
        };
  }
  return index_rec$1(s, l, i, c);
}

function index_from_opt$1(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.index_from_opt / Bytes.index_from_opt",
          Error: new Error()
        };
  }
  return index_rec_opt$1(s, l, i, c);
}

function rindex_rec$1(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue ;
  }}

function rindex$1(s, c) {
  return rindex_rec$1(s, s.length - 1 | 0, c);
}

function rindex_from$1(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from / Bytes.rindex_from",
          Error: new Error()
        };
  }
  return rindex_rec$1(s, i, c);
}

function rindex_rec_opt$1(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      return ;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue ;
  }}

function rindex_opt$1(s, c) {
  return rindex_rec_opt$1(s, s.length - 1 | 0, c);
}

function rindex_from_opt$1(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from_opt / Bytes.rindex_from_opt",
          Error: new Error()
        };
  }
  return rindex_rec_opt$1(s, i, c);
}

function contains_from$1(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.contains_from / Bytes.contains_from",
          Error: new Error()
        };
  }
  try {
    index_rec$1(s, l, i, c);
    return true;
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return false;
    }
    throw exn;
  }
}

function contains$1(s, c) {
  return contains_from$1(s, 0, c);
}

function rcontains_from$1(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "String.rcontains_from / Bytes.rcontains_from",
          Error: new Error()
        };
  }
  try {
    rindex_rec$1(s, i, c);
    return true;
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return false;
    }
    throw exn;
  }
}

function uppercase_ascii$2(s) {
  return caml_bytes.bytes_to_string(bytes.uppercase_ascii(caml_bytes.bytes_of_string(s)));
}

function lowercase_ascii$2(s) {
  return caml_bytes.bytes_to_string(bytes.lowercase_ascii(caml_bytes.bytes_of_string(s)));
}

function capitalize_ascii$1(s) {
  return caml_bytes.bytes_to_string(bytes.capitalize_ascii(caml_bytes.bytes_of_string(s)));
}

function uncapitalize_ascii$1(s) {
  return caml_bytes.bytes_to_string(bytes.uncapitalize_ascii(caml_bytes.bytes_of_string(s)));
}

var compare$3 = caml_primitive.caml_string_compare;

function split_on_char(sep, s) {
  var r = /* [] */0;
  var j = s.length;
  for(var i = s.length - 1 | 0; i >= 0; --i){
    if (s.charCodeAt(i) === sep) {
      r = {
        hd: sub$2(s, i + 1 | 0, (j - i | 0) - 1 | 0),
        tl: r
      };
      j = i;
    }
    
  }
  return {
          hd: sub$2(s, 0, j),
          tl: r
        };
}

function uppercase$2(s) {
  return caml_bytes.bytes_to_string(bytes.uppercase(caml_bytes.bytes_of_string(s)));
}

function lowercase$3(s) {
  return caml_bytes.bytes_to_string(bytes.lowercase(caml_bytes.bytes_of_string(s)));
}

function capitalize$1(s) {
  return caml_bytes.bytes_to_string(bytes.capitalize(caml_bytes.bytes_of_string(s)));
}

function uncapitalize$1(s) {
  return caml_bytes.bytes_to_string(bytes.uncapitalize(caml_bytes.bytes_of_string(s)));
}

var make$2 = caml_string.make;

var fill$2 = bytes.fill;

var blit$1 = bytes.blit_string;

function equal$2(prim, prim$1) {
  return prim === prim$1;
}

var make_1$2 = make$2;
var init_1$2 = init$2;
var copy_1$1 = copy$1;
var sub_1$2 = sub$2;
var fill_1$1 = fill$2;
var blit_1$1 = blit$1;
var concat_1$2 = concat$2;
var iter_1$2 = iter$2;
var iteri_1$2 = iteri$2;
var map_1$2 = map$2;
var mapi_1$2 = mapi$3;
var trim_1$1 = trim$1;
var escaped_1$2 = escaped$2;
var index_1$1 = index$1;
var index_opt_1$1 = index_opt$1;
var rindex_1$1 = rindex$1;
var rindex_opt_1$1 = rindex_opt$1;
var index_from_1$1 = index_from$1;
var index_from_opt_1$1 = index_from_opt$1;
var rindex_from_1$1 = rindex_from$1;
var rindex_from_opt_1$1 = rindex_from_opt$1;
var contains_1$1 = contains$1;
var contains_from_1$1 = contains_from$1;
var rcontains_from_1$1 = rcontains_from$1;
var uppercase_1$2 = uppercase$2;
var lowercase_1$2 = lowercase$3;
var capitalize_1$1 = capitalize$1;
var uncapitalize_1$1 = uncapitalize$1;
var uppercase_ascii_1$2 = uppercase_ascii$2;
var lowercase_ascii_1$2 = lowercase_ascii$2;
var capitalize_ascii_1$1 = capitalize_ascii$1;
var uncapitalize_ascii_1$1 = uncapitalize_ascii$1;
var compare_1$3 = compare$3;
var equal_1$2 = equal$2;
var split_on_char_1 = split_on_char;
/* No side effect */

var string = {
	make: make_1$2,
	init: init_1$2,
	copy: copy_1$1,
	sub: sub_1$2,
	fill: fill_1$1,
	blit: blit_1$1,
	concat: concat_1$2,
	iter: iter_1$2,
	iteri: iteri_1$2,
	map: map_1$2,
	mapi: mapi_1$2,
	trim: trim_1$1,
	escaped: escaped_1$2,
	index: index_1$1,
	index_opt: index_opt_1$1,
	rindex: rindex_1$1,
	rindex_opt: rindex_opt_1$1,
	index_from: index_from_1$1,
	index_from_opt: index_from_opt_1$1,
	rindex_from: rindex_from_1$1,
	rindex_from_opt: rindex_from_opt_1$1,
	contains: contains_1$1,
	contains_from: contains_from_1$1,
	rcontains_from: rcontains_from_1$1,
	uppercase: uppercase_1$2,
	lowercase: lowercase_1$2,
	capitalize: capitalize_1$1,
	uncapitalize: uncapitalize_1$1,
	uppercase_ascii: uppercase_ascii_1$2,
	lowercase_ascii: lowercase_ascii_1$2,
	capitalize_ascii: capitalize_ascii_1$1,
	uncapitalize_ascii: uncapitalize_ascii_1$1,
	compare: compare_1$3,
	equal: equal_1$2,
	split_on_char: split_on_char_1
};

function create$1(n) {
  var n$1 = n < 1 ? 1 : n;
  var s = caml_bytes.caml_create_bytes(n$1);
  return {
          buffer: s,
          position: 0,
          length: n$1,
          initial_buffer: s
        };
}

function contents(b) {
  return bytes.sub_string(b.buffer, 0, b.position);
}

function to_bytes(b) {
  return bytes.sub(b.buffer, 0, b.position);
}

function sub$3(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.position - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Buffer.sub",
          Error: new Error()
        };
  }
  return bytes.sub_string(b.buffer, ofs, len);
}

function blit$2(src, srcoff, dst, dstoff, len) {
  if (len < 0 || srcoff < 0 || srcoff > (src.position - len | 0) || dstoff < 0 || dstoff > (dst.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Buffer.blit",
          Error: new Error()
        };
  }
  return caml_bytes.caml_blit_bytes(src.buffer, srcoff, dst, dstoff, len);
}

function nth$1(b, ofs) {
  if (ofs < 0 || ofs >= b.position) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Buffer.nth",
          Error: new Error()
        };
  }
  return b.buffer[ofs];
}

function length$1(b) {
  return b.position;
}

function clear(b) {
  b.position = 0;
  
}

function reset(b) {
  b.position = 0;
  b.buffer = b.initial_buffer;
  b.length = b.buffer.length;
  
}

function resize(b, more) {
  var len = b.length;
  var new_len = len;
  while((b.position + more | 0) > new_len) {
    new_len = (new_len << 1);
  }  var new_buffer = caml_bytes.caml_create_bytes(new_len);
  bytes.blit(b.buffer, 0, new_buffer, 0, b.position);
  b.buffer = new_buffer;
  b.length = new_len;
  
}

function add_char(b, c) {
  var pos = b.position;
  if (pos >= b.length) {
    resize(b, 1);
  }
  b.buffer[pos] = c;
  b.position = pos + 1 | 0;
  
}

function add_utf_8_uchar(b, u) {
  var u$1 = u;
  if (u$1 < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "buffer.ml",
            90,
            19
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 127) {
    return add_char(b, u$1);
  }
  if (u$1 <= 2047) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = 192 | (u$1 >>> 6);
    b.buffer[pos + 1 | 0] = 128 | u$1 & 63;
    b.position = pos + 2 | 0;
    return ;
  }
  if (u$1 <= 65535) {
    var pos$1 = b.position;
    if ((pos$1 + 3 | 0) > b.length) {
      resize(b, 3);
    }
    b.buffer[pos$1] = 224 | (u$1 >>> 12);
    b.buffer[pos$1 + 1 | 0] = 128 | (u$1 >>> 6) & 63;
    b.buffer[pos$1 + 2 | 0] = 128 | u$1 & 63;
    b.position = pos$1 + 3 | 0;
    return ;
  }
  if (u$1 <= 1114111) {
    var pos$2 = b.position;
    if ((pos$2 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$2] = 240 | (u$1 >>> 18);
    b.buffer[pos$2 + 1 | 0] = 128 | (u$1 >>> 12) & 63;
    b.buffer[pos$2 + 2 | 0] = 128 | (u$1 >>> 6) & 63;
    b.buffer[pos$2 + 3 | 0] = 128 | u$1 & 63;
    b.position = pos$2 + 4 | 0;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "buffer.ml",
          123,
          8
        ],
        Error: new Error()
      };
}

function add_utf_16be_uchar(b, u) {
  var u$1 = u;
  if (u$1 < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "buffer.ml",
            126,
            19
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 65535) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = (u$1 >>> 8);
    b.buffer[pos + 1 | 0] = u$1 & 255;
    b.position = pos + 2 | 0;
    return ;
  }
  if (u$1 <= 1114111) {
    var u$prime = u$1 - 65536 | 0;
    var hi = 55296 | (u$prime >>> 10);
    var lo = 56320 | u$prime & 1023;
    var pos$1 = b.position;
    if ((pos$1 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$1] = (hi >>> 8);
    b.buffer[pos$1 + 1 | 0] = hi & 255;
    b.buffer[pos$1 + 2 | 0] = (lo >>> 8);
    b.buffer[pos$1 + 3 | 0] = lo & 255;
    b.position = pos$1 + 4 | 0;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "buffer.ml",
          144,
          8
        ],
        Error: new Error()
      };
}

function add_utf_16le_uchar(b, u) {
  var u$1 = u;
  if (u$1 < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "buffer.ml",
            147,
            19
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 65535) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = u$1 & 255;
    b.buffer[pos + 1 | 0] = (u$1 >>> 8);
    b.position = pos + 2 | 0;
    return ;
  }
  if (u$1 <= 1114111) {
    var u$prime = u$1 - 65536 | 0;
    var hi = 55296 | (u$prime >>> 10);
    var lo = 56320 | u$prime & 1023;
    var pos$1 = b.position;
    if ((pos$1 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$1] = hi & 255;
    b.buffer[pos$1 + 1 | 0] = (hi >>> 8);
    b.buffer[pos$1 + 2 | 0] = lo & 255;
    b.buffer[pos$1 + 3 | 0] = (lo >>> 8);
    b.position = pos$1 + 4 | 0;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "buffer.ml",
          165,
          8
        ],
        Error: new Error()
      };
}

function add_substring(b, s, offset, len) {
  if (offset < 0 || len < 0 || offset > (s.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Buffer.add_substring/add_subbytes",
          Error: new Error()
        };
  }
  var new_position = b.position + len | 0;
  if (new_position > b.length) {
    resize(b, len);
  }
  bytes.blit_string(s, offset, b.buffer, b.position, len);
  b.position = new_position;
  
}

function add_subbytes(b, s, offset, len) {
  return add_substring(b, caml_bytes.bytes_to_string(s), offset, len);
}

function add_string(b, s) {
  var len = s.length;
  var new_position = b.position + len | 0;
  if (new_position > b.length) {
    resize(b, len);
  }
  bytes.blit_string(s, 0, b.buffer, b.position, len);
  b.position = new_position;
  
}

function add_bytes(b, s) {
  return add_string(b, caml_bytes.bytes_to_string(s));
}

function add_buffer(b, bs) {
  return add_subbytes(b, bs.buffer, 0, bs.position);
}

function add_channel(b, ic, len) {
  if (len < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Buffer.add_channel",
          Error: new Error()
        };
  }
  if ((b.position + len | 0) > b.length) {
    resize(b, len);
  }
  var _len = len;
  while(true) {
    var len$1 = _len;
    if (len$1 <= 0) {
      return ;
    }
    var n = pervasives.input(ic, b.buffer, b.position, len$1);
    b.position = b.position + n | 0;
    if (n === 0) {
      throw {
            RE_EXN_ID: "End_of_file",
            Error: new Error()
          };
    }
    _len = len$1 - n | 0;
    continue ;
  }}

function output_buffer(oc, b) {
  return pervasives.output(oc, b.buffer, 0, b.position);
}

function closing(param) {
  if (param === 40) {
    return /* ")" */41;
  }
  if (param === 123) {
    return /* "}" */125;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "buffer.ml",
          216,
          9
        ],
        Error: new Error()
      };
}

function advance_to_closing(opening, closing, k, s, start) {
  var _k = k;
  var _i = start;
  var lim = s.length;
  while(true) {
    var i = _i;
    var k$1 = _k;
    if (i >= lim) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    if (caml_string.get(s, i) === opening) {
      _i = i + 1 | 0;
      _k = k$1 + 1 | 0;
      continue ;
    }
    if (caml_string.get(s, i) === closing) {
      if (k$1 === 0) {
        return i;
      }
      _i = i + 1 | 0;
      _k = k$1 - 1 | 0;
      continue ;
    }
    _i = i + 1 | 0;
    continue ;
  }}

function advance_to_non_alpha(s, start) {
  var _i = start;
  var lim = s.length;
  while(true) {
    var i = _i;
    if (i >= lim) {
      return lim;
    }
    var match = caml_string.get(s, i);
    if (match >= 91) {
      if (match >= 97) {
        if (match >= 123) {
          return i;
        }
        
      } else if (match !== 95) {
        return i;
      }
      
    } else if (match >= 58) {
      if (match < 65) {
        return i;
      }
      
    } else if (match < 48) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  }}

function find_ident(s, start, lim) {
  if (start >= lim) {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  var c = caml_string.get(s, start);
  if (c !== 40 && c !== 123) {
    var stop = advance_to_non_alpha(s, start + 1 | 0);
    return [
            string.sub(s, start, stop - start | 0),
            stop
          ];
  }
  var new_start = start + 1 | 0;
  var stop$1 = advance_to_closing(c, closing(c), 0, s, new_start);
  return [
          string.sub(s, new_start, (stop$1 - start | 0) - 1 | 0),
          stop$1 + 1 | 0
        ];
}

function add_substitute(b, f, s) {
  var lim = s.length;
  var _previous = /* " " */32;
  var _i = 0;
  while(true) {
    var i = _i;
    var previous = _previous;
    if (i >= lim) {
      if (previous === /* "\\" */92) {
        return add_char(b, previous);
      } else {
        return ;
      }
    }
    var current = caml_string.get(s, i);
    if (current !== 36) {
      if (previous === /* "\\" */92) {
        add_char(b, /* "\\" */92);
        add_char(b, current);
        _i = i + 1 | 0;
        _previous = /* " " */32;
        continue ;
      }
      if (current !== 92) {
        add_char(b, current);
        _i = i + 1 | 0;
        _previous = current;
        continue ;
      }
      _i = i + 1 | 0;
      _previous = current;
      continue ;
    }
    if (previous === /* "\\" */92) {
      add_char(b, current);
      _i = i + 1 | 0;
      _previous = /* " " */32;
      continue ;
    }
    var j = i + 1 | 0;
    var match = find_ident(s, j, lim);
    add_string(b, curry._1(f, match[0]));
    _i = match[1];
    _previous = /* " " */32;
    continue ;
  }}

function truncate(b, len) {
  if (len < 0 || len > b.position) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Buffer.truncate",
          Error: new Error()
        };
  }
  b.position = len;
  
}

var create_1$1 = create$1;
var contents_1 = contents;
var to_bytes_1 = to_bytes;
var sub_1$3 = sub$3;
var blit_1$2 = blit$2;
var nth_1$1 = nth$1;
var length_1$1 = length$1;
var clear_1 = clear;
var reset_1 = reset;
var add_char_1 = add_char;
var add_utf_8_uchar_1 = add_utf_8_uchar;
var add_utf_16le_uchar_1 = add_utf_16le_uchar;
var add_utf_16be_uchar_1 = add_utf_16be_uchar;
var add_string_1 = add_string;
var add_bytes_1 = add_bytes;
var add_substring_1 = add_substring;
var add_subbytes_1 = add_subbytes;
var add_substitute_1 = add_substitute;
var add_buffer_1 = add_buffer;
var add_channel_1 = add_channel;
var output_buffer_1 = output_buffer;
var truncate_1 = truncate;
/* No side effect */

var buffer = {
	create: create_1$1,
	contents: contents_1,
	to_bytes: to_bytes_1,
	sub: sub_1$3,
	blit: blit_1$2,
	nth: nth_1$1,
	length: length_1$1,
	clear: clear_1,
	reset: reset_1,
	add_char: add_char_1,
	add_utf_8_uchar: add_utf_8_uchar_1,
	add_utf_16le_uchar: add_utf_16le_uchar_1,
	add_utf_16be_uchar: add_utf_16be_uchar_1,
	add_string: add_string_1,
	add_bytes: add_bytes_1,
	add_substring: add_substring_1,
	add_subbytes: add_subbytes_1,
	add_substitute: add_substitute_1,
	add_buffer: add_buffer_1,
	add_channel: add_channel_1,
	output_buffer: output_buffer_1,
	truncate: truncate_1
};

function erase_rel(rest) {
  if (typeof rest === "number") {
    return /* End_of_fmtty */0;
  }
  switch (rest.TAG | 0) {
    case /* Char_ty */0 :
        return {
                TAG: /* Char_ty */0,
                _0: erase_rel(rest._0)
              };
    case /* String_ty */1 :
        return {
                TAG: /* String_ty */1,
                _0: erase_rel(rest._0)
              };
    case /* Int_ty */2 :
        return {
                TAG: /* Int_ty */2,
                _0: erase_rel(rest._0)
              };
    case /* Int32_ty */3 :
        return {
                TAG: /* Int32_ty */3,
                _0: erase_rel(rest._0)
              };
    case /* Nativeint_ty */4 :
        return {
                TAG: /* Nativeint_ty */4,
                _0: erase_rel(rest._0)
              };
    case /* Int64_ty */5 :
        return {
                TAG: /* Int64_ty */5,
                _0: erase_rel(rest._0)
              };
    case /* Float_ty */6 :
        return {
                TAG: /* Float_ty */6,
                _0: erase_rel(rest._0)
              };
    case /* Bool_ty */7 :
        return {
                TAG: /* Bool_ty */7,
                _0: erase_rel(rest._0)
              };
    case /* Format_arg_ty */8 :
        return {
                TAG: /* Format_arg_ty */8,
                _0: rest._0,
                _1: erase_rel(rest._1)
              };
    case /* Format_subst_ty */9 :
        var ty1 = rest._0;
        return {
                TAG: /* Format_subst_ty */9,
                _0: ty1,
                _1: ty1,
                _2: erase_rel(rest._2)
              };
    case /* Alpha_ty */10 :
        return {
                TAG: /* Alpha_ty */10,
                _0: erase_rel(rest._0)
              };
    case /* Theta_ty */11 :
        return {
                TAG: /* Theta_ty */11,
                _0: erase_rel(rest._0)
              };
    case /* Any_ty */12 :
        return {
                TAG: /* Any_ty */12,
                _0: erase_rel(rest._0)
              };
    case /* Reader_ty */13 :
        return {
                TAG: /* Reader_ty */13,
                _0: erase_rel(rest._0)
              };
    case /* Ignored_reader_ty */14 :
        return {
                TAG: /* Ignored_reader_ty */14,
                _0: erase_rel(rest._0)
              };
    
  }
}

function concat_fmtty(fmtty1, fmtty2) {
  if (typeof fmtty1 === "number") {
    return fmtty2;
  }
  switch (fmtty1.TAG | 0) {
    case /* Char_ty */0 :
        return {
                TAG: /* Char_ty */0,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* String_ty */1 :
        return {
                TAG: /* String_ty */1,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Int_ty */2 :
        return {
                TAG: /* Int_ty */2,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Int32_ty */3 :
        return {
                TAG: /* Int32_ty */3,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Nativeint_ty */4 :
        return {
                TAG: /* Nativeint_ty */4,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Int64_ty */5 :
        return {
                TAG: /* Int64_ty */5,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Float_ty */6 :
        return {
                TAG: /* Float_ty */6,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Bool_ty */7 :
        return {
                TAG: /* Bool_ty */7,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Format_arg_ty */8 :
        return {
                TAG: /* Format_arg_ty */8,
                _0: fmtty1._0,
                _1: concat_fmtty(fmtty1._1, fmtty2)
              };
    case /* Format_subst_ty */9 :
        return {
                TAG: /* Format_subst_ty */9,
                _0: fmtty1._0,
                _1: fmtty1._1,
                _2: concat_fmtty(fmtty1._2, fmtty2)
              };
    case /* Alpha_ty */10 :
        return {
                TAG: /* Alpha_ty */10,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Theta_ty */11 :
        return {
                TAG: /* Theta_ty */11,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Any_ty */12 :
        return {
                TAG: /* Any_ty */12,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Reader_ty */13 :
        return {
                TAG: /* Reader_ty */13,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Ignored_reader_ty */14 :
        return {
                TAG: /* Ignored_reader_ty */14,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    
  }
}

function concat_fmt(fmt1, fmt2) {
  if (typeof fmt1 === "number") {
    return fmt2;
  }
  switch (fmt1.TAG | 0) {
    case /* Char */0 :
        return {
                TAG: /* Char */0,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* Caml_char */1 :
        return {
                TAG: /* Caml_char */1,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* String */2 :
        return {
                TAG: /* String */2,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Caml_string */3 :
        return {
                TAG: /* Caml_string */3,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Int */4 :
        return {
                TAG: /* Int */4,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: fmt1._2,
                _3: concat_fmt(fmt1._3, fmt2)
              };
    case /* Int32 */5 :
        return {
                TAG: /* Int32 */5,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: fmt1._2,
                _3: concat_fmt(fmt1._3, fmt2)
              };
    case /* Nativeint */6 :
        return {
                TAG: /* Nativeint */6,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: fmt1._2,
                _3: concat_fmt(fmt1._3, fmt2)
              };
    case /* Int64 */7 :
        return {
                TAG: /* Int64 */7,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: fmt1._2,
                _3: concat_fmt(fmt1._3, fmt2)
              };
    case /* Float */8 :
        return {
                TAG: /* Float */8,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: fmt1._2,
                _3: concat_fmt(fmt1._3, fmt2)
              };
    case /* Bool */9 :
        return {
                TAG: /* Bool */9,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Flush */10 :
        return {
                TAG: /* Flush */10,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* String_literal */11 :
        return {
                TAG: /* String_literal */11,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Char_literal */12 :
        return {
                TAG: /* Char_literal */12,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Format_arg */13 :
        return {
                TAG: /* Format_arg */13,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: concat_fmt(fmt1._2, fmt2)
              };
    case /* Format_subst */14 :
        return {
                TAG: /* Format_subst */14,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: concat_fmt(fmt1._2, fmt2)
              };
    case /* Alpha */15 :
        return {
                TAG: /* Alpha */15,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* Theta */16 :
        return {
                TAG: /* Theta */16,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* Formatting_lit */17 :
        return {
                TAG: /* Formatting_lit */17,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Formatting_gen */18 :
        return {
                TAG: /* Formatting_gen */18,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Reader */19 :
        return {
                TAG: /* Reader */19,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* Scan_char_set */20 :
        return {
                TAG: /* Scan_char_set */20,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: concat_fmt(fmt1._2, fmt2)
              };
    case /* Scan_get_counter */21 :
        return {
                TAG: /* Scan_get_counter */21,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Scan_next_char */22 :
        return {
                TAG: /* Scan_next_char */22,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* Ignored_param */23 :
        return {
                TAG: /* Ignored_param */23,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Custom */24 :
        return {
                TAG: /* Custom */24,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: concat_fmt(fmt1._2, fmt2)
              };
    
  }
}

var concat_fmtty_1 = concat_fmtty;
var erase_rel_1 = erase_rel;
var concat_fmt_1 = concat_fmt;
/* No side effect */

var camlinternalFormatBasics = {
	concat_fmtty: concat_fmtty_1,
	erase_rel: erase_rel_1,
	concat_fmt: concat_fmt_1
};

function create_char_set(param) {
  return bytes.make(32, /* "\000" */0);
}

function add_in_char_set(char_set, c) {
  var str_ind = (c >>> 3);
  var mask = (1 << (c & 7));
  return caml_bytes.set(char_set, str_ind, pervasives.char_of_int(caml_bytes.get(char_set, str_ind) | mask));
}

var freeze_char_set = bytes.to_string;

function rev_char_set(char_set) {
  var char_set$prime = bytes.make(32, /* "\000" */0);
  for(var i = 0; i <= 31; ++i){
    caml_bytes.set(char_set$prime, i, pervasives.char_of_int(caml_string.get(char_set, i) ^ 255));
  }
  return caml_bytes.bytes_to_string(char_set$prime);
}

function is_in_char_set(char_set, c) {
  var str_ind = (c >>> 3);
  var mask = (1 << (c & 7));
  return (caml_string.get(char_set, str_ind) & mask) !== 0;
}

function pad_of_pad_opt(pad_opt) {
  if (pad_opt !== undefined) {
    return {
            TAG: /* Lit_padding */0,
            _0: /* Right */1,
            _1: pad_opt
          };
  } else {
    return /* No_padding */0;
  }
}

function prec_of_prec_opt(prec_opt) {
  if (prec_opt !== undefined) {
    return /* Lit_precision */{
            _0: prec_opt
          };
  } else {
    return /* No_precision */0;
  }
}

function param_format_of_ignored_format(ign, fmt) {
  if (typeof ign === "number") {
    switch (ign) {
      case /* Ignored_char */0 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Char */0,
                    _0: fmt
                  }
                };
      case /* Ignored_caml_char */1 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Caml_char */1,
                    _0: fmt
                  }
                };
      case /* Ignored_reader */2 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Reader */19,
                    _0: fmt
                  }
                };
      case /* Ignored_scan_next_char */3 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Scan_next_char */22,
                    _0: fmt
                  }
                };
      
    }
  } else {
    switch (ign.TAG | 0) {
      case /* Ignored_string */0 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* String */2,
                    _0: pad_of_pad_opt(ign._0),
                    _1: fmt
                  }
                };
      case /* Ignored_caml_string */1 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Caml_string */3,
                    _0: pad_of_pad_opt(ign._0),
                    _1: fmt
                  }
                };
      case /* Ignored_int */2 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Int */4,
                    _0: ign._0,
                    _1: pad_of_pad_opt(ign._1),
                    _2: /* No_precision */0,
                    _3: fmt
                  }
                };
      case /* Ignored_int32 */3 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Int32 */5,
                    _0: ign._0,
                    _1: pad_of_pad_opt(ign._1),
                    _2: /* No_precision */0,
                    _3: fmt
                  }
                };
      case /* Ignored_nativeint */4 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Nativeint */6,
                    _0: ign._0,
                    _1: pad_of_pad_opt(ign._1),
                    _2: /* No_precision */0,
                    _3: fmt
                  }
                };
      case /* Ignored_int64 */5 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Int64 */7,
                    _0: ign._0,
                    _1: pad_of_pad_opt(ign._1),
                    _2: /* No_precision */0,
                    _3: fmt
                  }
                };
      case /* Ignored_float */6 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Float */8,
                    _0: /* Float_f */0,
                    _1: pad_of_pad_opt(ign._0),
                    _2: prec_of_prec_opt(ign._1),
                    _3: fmt
                  }
                };
      case /* Ignored_bool */7 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Bool */9,
                    _0: pad_of_pad_opt(ign._0),
                    _1: fmt
                  }
                };
      case /* Ignored_format_arg */8 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Format_arg */13,
                    _0: ign._0,
                    _1: ign._1,
                    _2: fmt
                  }
                };
      case /* Ignored_format_subst */9 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Format_subst */14,
                    _0: ign._0,
                    _1: ign._1,
                    _2: fmt
                  }
                };
      case /* Ignored_scan_char_set */10 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Scan_char_set */20,
                    _0: ign._0,
                    _1: ign._1,
                    _2: fmt
                  }
                };
      case /* Ignored_scan_get_counter */11 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Scan_get_counter */21,
                    _0: ign._0,
                    _1: fmt
                  }
                };
      
    }
  }
}

function buffer_check_size(buf, overhead) {
  var len = buf.bytes.length;
  var min_len = buf.ind + overhead | 0;
  if (min_len <= len) {
    return ;
  }
  var new_len = caml_primitive.caml_int_max((len << 1), min_len);
  var new_str = caml_bytes.caml_create_bytes(new_len);
  bytes.blit(buf.bytes, 0, new_str, 0, len);
  buf.bytes = new_str;
  
}

function buffer_add_char(buf, c) {
  buffer_check_size(buf, 1);
  caml_bytes.set(buf.bytes, buf.ind, c);
  buf.ind = buf.ind + 1 | 0;
  
}

function buffer_add_string(buf, s) {
  var str_len = s.length;
  buffer_check_size(buf, str_len);
  string.blit(s, 0, buf.bytes, buf.ind, str_len);
  buf.ind = buf.ind + str_len | 0;
  
}

function buffer_contents(buf) {
  return bytes.sub_string(buf.bytes, 0, buf.ind);
}

function char_of_iconv(iconv) {
  switch (iconv) {
    case /* Int_d */0 :
    case /* Int_pd */1 :
    case /* Int_sd */2 :
        return /* "d" */100;
    case /* Int_i */3 :
    case /* Int_pi */4 :
    case /* Int_si */5 :
        return /* "i" */105;
    case /* Int_x */6 :
    case /* Int_Cx */7 :
        return /* "x" */120;
    case /* Int_X */8 :
    case /* Int_CX */9 :
        return /* "X" */88;
    case /* Int_o */10 :
    case /* Int_Co */11 :
        return /* "o" */111;
    case /* Int_u */12 :
        return /* "u" */117;
    
  }
}

function char_of_fconv(fconv) {
  switch (fconv) {
    case /* Float_f */0 :
    case /* Float_pf */1 :
    case /* Float_sf */2 :
        return /* "f" */102;
    case /* Float_e */3 :
    case /* Float_pe */4 :
    case /* Float_se */5 :
        return /* "e" */101;
    case /* Float_E */6 :
    case /* Float_pE */7 :
    case /* Float_sE */8 :
        return /* "E" */69;
    case /* Float_g */9 :
    case /* Float_pg */10 :
    case /* Float_sg */11 :
        return /* "g" */103;
    case /* Float_G */12 :
    case /* Float_pG */13 :
    case /* Float_sG */14 :
        return /* "G" */71;
    case /* Float_F */15 :
        return /* "F" */70;
    case /* Float_h */16 :
    case /* Float_ph */17 :
    case /* Float_sh */18 :
        return /* "h" */104;
    case /* Float_H */19 :
    case /* Float_pH */20 :
    case /* Float_sH */21 :
        return /* "H" */72;
    
  }
}

function char_of_counter(counter) {
  switch (counter) {
    case /* Line_counter */0 :
        return /* "l" */108;
    case /* Char_counter */1 :
        return /* "n" */110;
    case /* Token_counter */2 :
        return /* "N" */78;
    
  }
}

function bprint_char_set(buf, char_set) {
  var print_char = function (buf, i) {
    var c = pervasives.char_of_int(i);
    if (c !== 37) {
      if (c !== 64) {
        return buffer_add_char(buf, c);
      } else {
        buffer_add_char(buf, /* "%" */37);
        return buffer_add_char(buf, /* "@" */64);
      }
    } else {
      buffer_add_char(buf, /* "%" */37);
      return buffer_add_char(buf, /* "%" */37);
    }
  };
  var print_out = function (set, _i) {
    while(true) {
      var i = _i;
      if (i >= 256) {
        return ;
      }
      if (is_in_char_set(set, pervasives.char_of_int(i))) {
        var match = pervasives.char_of_int(i);
        var switcher = match - 45 | 0;
        if (switcher > 48 || switcher < 0) {
          if (switcher >= 210) {
            return print_char(buf, 255);
          } else {
            return print_second(set, i + 1 | 0);
          }
        } else if (switcher > 47 || switcher < 1) {
          return print_out(set, i + 1 | 0);
        } else {
          return print_second(set, i + 1 | 0);
        }
      }
      _i = i + 1 | 0;
      continue ;
    }  };
  var print_second = function (set, i) {
    if (is_in_char_set(set, pervasives.char_of_int(i))) {
      var match = pervasives.char_of_int(i);
      var switcher = match - 45 | 0;
      if (switcher > 48 || switcher < 0) {
        if (switcher >= 210) {
          print_char(buf, 254);
          return print_char(buf, 255);
        }
        
      } else if ((switcher > 47 || switcher < 1) && !is_in_char_set(set, pervasives.char_of_int(i + 1 | 0))) {
        print_char(buf, i - 1 | 0);
        return print_out(set, i + 1 | 0);
      }
      if (is_in_char_set(set, pervasives.char_of_int(i + 1 | 0))) {
        var i$1 = i - 1 | 0;
        var _j = i + 2 | 0;
        while(true) {
          var j = _j;
          if (j === 256 || !is_in_char_set(set, pervasives.char_of_int(j))) {
            print_char(buf, i$1);
            print_char(buf, /* "-" */45);
            print_char(buf, j - 1 | 0);
            if (j < 256) {
              return print_out(set, j + 1 | 0);
            } else {
              return ;
            }
          }
          _j = j + 1 | 0;
          continue ;
        }      } else {
        print_char(buf, i - 1 | 0);
        print_char(buf, i);
        return print_out(set, i + 2 | 0);
      }
    }
    print_char(buf, i - 1 | 0);
    return print_out(set, i + 1 | 0);
  };
  var print_start = function (set) {
    var is_alone = function (c) {
      var before = char.chr(c - 1 | 0);
      var after = char.chr(c + 1 | 0);
      if (is_in_char_set(set, c)) {
        return !(is_in_char_set(set, before) && is_in_char_set(set, after));
      } else {
        return false;
      }
    };
    if (is_alone(/* "]" */93)) {
      buffer_add_char(buf, /* "]" */93);
    }
    print_out(set, 1);
    if (is_alone(/* "-" */45)) {
      return buffer_add_char(buf, /* "-" */45);
    }
    
  };
  buffer_add_char(buf, /* "[" */91);
  print_start(is_in_char_set(char_set, /* "\000" */0) ? (buffer_add_char(buf, /* "^" */94), rev_char_set(char_set)) : char_set);
  return buffer_add_char(buf, /* "]" */93);
}

function bprint_padty(buf, padty) {
  switch (padty) {
    case /* Left */0 :
        return buffer_add_char(buf, /* "-" */45);
    case /* Right */1 :
        return ;
    case /* Zeros */2 :
        return buffer_add_char(buf, /* "0" */48);
    
  }
}

function bprint_ignored_flag(buf, ign_flag) {
  if (ign_flag) {
    return buffer_add_char(buf, /* "_" */95);
  }
  
}

function bprint_pad_opt(buf, pad_opt) {
  if (pad_opt !== undefined) {
    return buffer_add_string(buf, String(pad_opt));
  }
  
}

function bprint_padding(buf, pad) {
  if (typeof pad === "number") {
    return ;
  }
  if (pad.TAG === /* Lit_padding */0) {
    bprint_padty(buf, pad._0);
    return buffer_add_string(buf, String(pad._1));
  }
  bprint_padty(buf, pad._0);
  return buffer_add_char(buf, /* "*" */42);
}

function bprint_precision(buf, prec) {
  if (typeof prec === "number") {
    if (prec !== 0) {
      return buffer_add_string(buf, ".*");
    } else {
      return ;
    }
  } else {
    buffer_add_char(buf, /* "." */46);
    return buffer_add_string(buf, String(prec._0));
  }
}

function bprint_iconv_flag(buf, iconv) {
  switch (iconv) {
    case /* Int_pd */1 :
    case /* Int_pi */4 :
        return buffer_add_char(buf, /* "+" */43);
    case /* Int_sd */2 :
    case /* Int_si */5 :
        return buffer_add_char(buf, /* " " */32);
    case /* Int_Cx */7 :
    case /* Int_CX */9 :
    case /* Int_Co */11 :
        return buffer_add_char(buf, /* "#" */35);
    case /* Int_d */0 :
    case /* Int_i */3 :
    case /* Int_x */6 :
    case /* Int_X */8 :
    case /* Int_o */10 :
    case /* Int_u */12 :
        return ;
    
  }
}

function bprint_int_fmt(buf, ign_flag, iconv, pad, prec) {
  buffer_add_char(buf, /* "%" */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_iconv_flag(buf, iconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  return buffer_add_char(buf, char_of_iconv(iconv));
}

function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c) {
  buffer_add_char(buf, /* "%" */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_iconv_flag(buf, iconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  buffer_add_char(buf, c);
  return buffer_add_char(buf, char_of_iconv(iconv));
}

function bprint_fconv_flag(buf, fconv) {
  switch (fconv) {
    case /* Float_f */0 :
    case /* Float_e */3 :
    case /* Float_E */6 :
    case /* Float_g */9 :
    case /* Float_G */12 :
    case /* Float_F */15 :
    case /* Float_h */16 :
    case /* Float_H */19 :
        return ;
    case /* Float_pf */1 :
    case /* Float_pe */4 :
    case /* Float_pE */7 :
    case /* Float_pg */10 :
    case /* Float_pG */13 :
    case /* Float_ph */17 :
    case /* Float_pH */20 :
        return buffer_add_char(buf, /* "+" */43);
    case /* Float_sf */2 :
    case /* Float_se */5 :
    case /* Float_sE */8 :
    case /* Float_sg */11 :
    case /* Float_sG */14 :
    case /* Float_sh */18 :
    case /* Float_sH */21 :
        return buffer_add_char(buf, /* " " */32);
    
  }
}

function bprint_float_fmt(buf, ign_flag, fconv, pad, prec) {
  buffer_add_char(buf, /* "%" */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_fconv_flag(buf, fconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  return buffer_add_char(buf, char_of_fconv(fconv));
}

function string_of_formatting_lit(formatting_lit) {
  if (typeof formatting_lit === "number") {
    switch (formatting_lit) {
      case /* Close_box */0 :
          return "@]";
      case /* Close_tag */1 :
          return "@}";
      case /* FFlush */2 :
          return "@?";
      case /* Force_newline */3 :
          return "@\n";
      case /* Flush_newline */4 :
          return "@.";
      case /* Escaped_at */5 :
          return "@@";
      case /* Escaped_percent */6 :
          return "@%";
      
    }
  } else {
    switch (formatting_lit.TAG | 0) {
      case /* Break */0 :
      case /* Magic_size */1 :
          return formatting_lit._0;
      case /* Scan_indic */2 :
          return "@" + caml_string.make(1, formatting_lit._0);
      
    }
  }
}

function string_of_formatting_gen(formatting_gen) {
  return formatting_gen._0._1;
}

function bprint_char_literal(buf, chr) {
  if (chr !== 37) {
    return buffer_add_char(buf, chr);
  } else {
    return buffer_add_string(buf, "%%");
  }
}

function bprint_string_literal(buf, str) {
  for(var i = 0 ,i_finish = str.length; i < i_finish; ++i){
    bprint_char_literal(buf, caml_string.get(str, i));
  }
  
}

function bprint_fmtty(buf, _fmtty) {
  while(true) {
    var fmtty = _fmtty;
    if (typeof fmtty === "number") {
      return ;
    }
    switch (fmtty.TAG | 0) {
      case /* Char_ty */0 :
          buffer_add_string(buf, "%c");
          _fmtty = fmtty._0;
          continue ;
      case /* String_ty */1 :
          buffer_add_string(buf, "%s");
          _fmtty = fmtty._0;
          continue ;
      case /* Int_ty */2 :
          buffer_add_string(buf, "%i");
          _fmtty = fmtty._0;
          continue ;
      case /* Int32_ty */3 :
          buffer_add_string(buf, "%li");
          _fmtty = fmtty._0;
          continue ;
      case /* Nativeint_ty */4 :
          buffer_add_string(buf, "%ni");
          _fmtty = fmtty._0;
          continue ;
      case /* Int64_ty */5 :
          buffer_add_string(buf, "%Li");
          _fmtty = fmtty._0;
          continue ;
      case /* Float_ty */6 :
          buffer_add_string(buf, "%f");
          _fmtty = fmtty._0;
          continue ;
      case /* Bool_ty */7 :
          buffer_add_string(buf, "%B");
          _fmtty = fmtty._0;
          continue ;
      case /* Format_arg_ty */8 :
          buffer_add_string(buf, "%{");
          bprint_fmtty(buf, fmtty._0);
          buffer_add_string(buf, "%}");
          _fmtty = fmtty._1;
          continue ;
      case /* Format_subst_ty */9 :
          buffer_add_string(buf, "%(");
          bprint_fmtty(buf, fmtty._0);
          buffer_add_string(buf, "%)");
          _fmtty = fmtty._2;
          continue ;
      case /* Alpha_ty */10 :
          buffer_add_string(buf, "%a");
          _fmtty = fmtty._0;
          continue ;
      case /* Theta_ty */11 :
          buffer_add_string(buf, "%t");
          _fmtty = fmtty._0;
          continue ;
      case /* Any_ty */12 :
          buffer_add_string(buf, "%?");
          _fmtty = fmtty._0;
          continue ;
      case /* Reader_ty */13 :
          buffer_add_string(buf, "%r");
          _fmtty = fmtty._0;
          continue ;
      case /* Ignored_reader_ty */14 :
          buffer_add_string(buf, "%_r");
          _fmtty = fmtty._0;
          continue ;
      
    }
  }}

function int_of_custom_arity(x) {
  if (x) {
    return 1 + int_of_custom_arity(x._0) | 0;
  } else {
    return 0;
  }
}

function bprint_fmt(buf, fmt) {
  var _fmt = fmt;
  var _ign_flag = false;
  while(true) {
    var ign_flag = _ign_flag;
    var fmt$1 = _fmt;
    if (typeof fmt$1 === "number") {
      return ;
    }
    switch (fmt$1.TAG | 0) {
      case /* Char */0 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* "c" */99);
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* Caml_char */1 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* "C" */67);
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* String */2 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_padding(buf, fmt$1._0);
          buffer_add_char(buf, /* "s" */115);
          _ign_flag = false;
          _fmt = fmt$1._1;
          continue ;
      case /* Caml_string */3 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_padding(buf, fmt$1._0);
          buffer_add_char(buf, /* "S" */83);
          _ign_flag = false;
          _fmt = fmt$1._1;
          continue ;
      case /* Int */4 :
          bprint_int_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2);
          _ign_flag = false;
          _fmt = fmt$1._3;
          continue ;
      case /* Int32 */5 :
          bprint_altint_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2, /* "l" */108);
          _ign_flag = false;
          _fmt = fmt$1._3;
          continue ;
      case /* Nativeint */6 :
          bprint_altint_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2, /* "n" */110);
          _ign_flag = false;
          _fmt = fmt$1._3;
          continue ;
      case /* Int64 */7 :
          bprint_altint_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2, /* "L" */76);
          _ign_flag = false;
          _fmt = fmt$1._3;
          continue ;
      case /* Float */8 :
          bprint_float_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2);
          _ign_flag = false;
          _fmt = fmt$1._3;
          continue ;
      case /* Bool */9 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_padding(buf, fmt$1._0);
          buffer_add_char(buf, /* "B" */66);
          _ign_flag = false;
          _fmt = fmt$1._1;
          continue ;
      case /* Flush */10 :
          buffer_add_string(buf, "%!");
          _fmt = fmt$1._0;
          continue ;
      case /* String_literal */11 :
          bprint_string_literal(buf, fmt$1._0);
          _fmt = fmt$1._1;
          continue ;
      case /* Char_literal */12 :
          bprint_char_literal(buf, fmt$1._0);
          _fmt = fmt$1._1;
          continue ;
      case /* Format_arg */13 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_pad_opt(buf, fmt$1._0);
          buffer_add_char(buf, /* "{" */123);
          bprint_fmtty(buf, fmt$1._1);
          buffer_add_char(buf, /* "%" */37);
          buffer_add_char(buf, /* "}" */125);
          _ign_flag = false;
          _fmt = fmt$1._2;
          continue ;
      case /* Format_subst */14 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_pad_opt(buf, fmt$1._0);
          buffer_add_char(buf, /* "(" */40);
          bprint_fmtty(buf, fmt$1._1);
          buffer_add_char(buf, /* "%" */37);
          buffer_add_char(buf, /* ")" */41);
          _ign_flag = false;
          _fmt = fmt$1._2;
          continue ;
      case /* Alpha */15 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* "a" */97);
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* Theta */16 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* "t" */116);
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* Formatting_lit */17 :
          bprint_string_literal(buf, string_of_formatting_lit(fmt$1._0));
          _fmt = fmt$1._1;
          continue ;
      case /* Formatting_gen */18 :
          bprint_string_literal(buf, "@{");
          bprint_string_literal(buf, string_of_formatting_gen(fmt$1._0));
          _fmt = fmt$1._1;
          continue ;
      case /* Reader */19 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* "r" */114);
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* Scan_char_set */20 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_pad_opt(buf, fmt$1._0);
          bprint_char_set(buf, fmt$1._1);
          _ign_flag = false;
          _fmt = fmt$1._2;
          continue ;
      case /* Scan_get_counter */21 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, char_of_counter(fmt$1._0));
          _ign_flag = false;
          _fmt = fmt$1._1;
          continue ;
      case /* Scan_next_char */22 :
          buffer_add_char(buf, /* "%" */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_string_literal(buf, "0c");
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* Ignored_param */23 :
          var fmt$prime = param_format_of_ignored_format(fmt$1._0, fmt$1._1);
          _ign_flag = true;
          _fmt = fmt$prime._0;
          continue ;
      case /* Custom */24 :
          for(var _i = 1 ,_i_finish = int_of_custom_arity(fmt$1._0); _i <= _i_finish; ++_i){
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            buffer_add_char(buf, /* "?" */63);
          }
          _ign_flag = false;
          _fmt = fmt$1._2;
          continue ;
      
    }
  }}

function string_of_fmt(fmt) {
  var buf = {
    ind: 0,
    bytes: caml_bytes.caml_create_bytes(16)
  };
  bprint_fmt(buf, fmt);
  return buffer_contents(buf);
}

function symm(rest) {
  if (typeof rest === "number") {
    return /* End_of_fmtty */0;
  }
  switch (rest.TAG | 0) {
    case /* Char_ty */0 :
        return {
                TAG: /* Char_ty */0,
                _0: symm(rest._0)
              };
    case /* String_ty */1 :
        return {
                TAG: /* String_ty */1,
                _0: symm(rest._0)
              };
    case /* Int_ty */2 :
        return {
                TAG: /* Int_ty */2,
                _0: symm(rest._0)
              };
    case /* Int32_ty */3 :
        return {
                TAG: /* Int32_ty */3,
                _0: symm(rest._0)
              };
    case /* Nativeint_ty */4 :
        return {
                TAG: /* Nativeint_ty */4,
                _0: symm(rest._0)
              };
    case /* Int64_ty */5 :
        return {
                TAG: /* Int64_ty */5,
                _0: symm(rest._0)
              };
    case /* Float_ty */6 :
        return {
                TAG: /* Float_ty */6,
                _0: symm(rest._0)
              };
    case /* Bool_ty */7 :
        return {
                TAG: /* Bool_ty */7,
                _0: symm(rest._0)
              };
    case /* Format_arg_ty */8 :
        return {
                TAG: /* Format_arg_ty */8,
                _0: rest._0,
                _1: symm(rest._1)
              };
    case /* Format_subst_ty */9 :
        return {
                TAG: /* Format_subst_ty */9,
                _0: rest._1,
                _1: rest._0,
                _2: symm(rest._2)
              };
    case /* Alpha_ty */10 :
        return {
                TAG: /* Alpha_ty */10,
                _0: symm(rest._0)
              };
    case /* Theta_ty */11 :
        return {
                TAG: /* Theta_ty */11,
                _0: symm(rest._0)
              };
    case /* Any_ty */12 :
        return {
                TAG: /* Any_ty */12,
                _0: symm(rest._0)
              };
    case /* Reader_ty */13 :
        return {
                TAG: /* Reader_ty */13,
                _0: symm(rest._0)
              };
    case /* Ignored_reader_ty */14 :
        return {
                TAG: /* Ignored_reader_ty */14,
                _0: symm(rest._0)
              };
    
  }
}

function fmtty_rel_det(rest) {
  if (typeof rest === "number") {
    return [
            (function (param) {
                return /* Refl */0;
              }),
            (function (param) {
                return /* Refl */0;
              }),
            (function (param) {
                return /* Refl */0;
              }),
            (function (param) {
                return /* Refl */0;
              })
          ];
  }
  switch (rest.TAG | 0) {
    case /* Char_ty */0 :
        var match = fmtty_rel_det(rest._0);
        var af = match[1];
        var fa = match[0];
        return [
                (function (param) {
                    curry._1(fa, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af, /* Refl */0);
                    return /* Refl */0;
                  }),
                match[2],
                match[3]
              ];
    case /* String_ty */1 :
        var match$1 = fmtty_rel_det(rest._0);
        var af$1 = match$1[1];
        var fa$1 = match$1[0];
        return [
                (function (param) {
                    curry._1(fa$1, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$1, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$1[2],
                match$1[3]
              ];
    case /* Int_ty */2 :
        var match$2 = fmtty_rel_det(rest._0);
        var af$2 = match$2[1];
        var fa$2 = match$2[0];
        return [
                (function (param) {
                    curry._1(fa$2, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$2, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$2[2],
                match$2[3]
              ];
    case /* Int32_ty */3 :
        var match$3 = fmtty_rel_det(rest._0);
        var af$3 = match$3[1];
        var fa$3 = match$3[0];
        return [
                (function (param) {
                    curry._1(fa$3, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$3, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$3[2],
                match$3[3]
              ];
    case /* Nativeint_ty */4 :
        var match$4 = fmtty_rel_det(rest._0);
        var af$4 = match$4[1];
        var fa$4 = match$4[0];
        return [
                (function (param) {
                    curry._1(fa$4, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$4, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$4[2],
                match$4[3]
              ];
    case /* Int64_ty */5 :
        var match$5 = fmtty_rel_det(rest._0);
        var af$5 = match$5[1];
        var fa$5 = match$5[0];
        return [
                (function (param) {
                    curry._1(fa$5, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$5, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$5[2],
                match$5[3]
              ];
    case /* Float_ty */6 :
        var match$6 = fmtty_rel_det(rest._0);
        var af$6 = match$6[1];
        var fa$6 = match$6[0];
        return [
                (function (param) {
                    curry._1(fa$6, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$6, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$6[2],
                match$6[3]
              ];
    case /* Bool_ty */7 :
        var match$7 = fmtty_rel_det(rest._0);
        var af$7 = match$7[1];
        var fa$7 = match$7[0];
        return [
                (function (param) {
                    curry._1(fa$7, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$7, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$7[2],
                match$7[3]
              ];
    case /* Format_arg_ty */8 :
        var match$8 = fmtty_rel_det(rest._1);
        var af$8 = match$8[1];
        var fa$8 = match$8[0];
        return [
                (function (param) {
                    curry._1(fa$8, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$8, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$8[2],
                match$8[3]
              ];
    case /* Format_subst_ty */9 :
        var match$9 = fmtty_rel_det(rest._2);
        var de = match$9[3];
        var ed = match$9[2];
        var af$9 = match$9[1];
        var fa$9 = match$9[0];
        var ty = trans(symm(rest._0), rest._1);
        var match$10 = fmtty_rel_det(ty);
        var jd = match$10[3];
        var dj = match$10[2];
        var ga = match$10[1];
        var ag = match$10[0];
        return [
                (function (param) {
                    curry._1(fa$9, /* Refl */0);
                    curry._1(ag, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(ga, /* Refl */0);
                    curry._1(af$9, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(ed, /* Refl */0);
                    curry._1(dj, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(jd, /* Refl */0);
                    curry._1(de, /* Refl */0);
                    return /* Refl */0;
                  })
              ];
    case /* Alpha_ty */10 :
        var match$11 = fmtty_rel_det(rest._0);
        var af$10 = match$11[1];
        var fa$10 = match$11[0];
        return [
                (function (param) {
                    curry._1(fa$10, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$10, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$11[2],
                match$11[3]
              ];
    case /* Theta_ty */11 :
        var match$12 = fmtty_rel_det(rest._0);
        var af$11 = match$12[1];
        var fa$11 = match$12[0];
        return [
                (function (param) {
                    curry._1(fa$11, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$11, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$12[2],
                match$12[3]
              ];
    case /* Any_ty */12 :
        var match$13 = fmtty_rel_det(rest._0);
        var af$12 = match$13[1];
        var fa$12 = match$13[0];
        return [
                (function (param) {
                    curry._1(fa$12, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$12, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$13[2],
                match$13[3]
              ];
    case /* Reader_ty */13 :
        var match$14 = fmtty_rel_det(rest._0);
        var de$1 = match$14[3];
        var ed$1 = match$14[2];
        var af$13 = match$14[1];
        var fa$13 = match$14[0];
        return [
                (function (param) {
                    curry._1(fa$13, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$13, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(ed$1, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(de$1, /* Refl */0);
                    return /* Refl */0;
                  })
              ];
    case /* Ignored_reader_ty */14 :
        var match$15 = fmtty_rel_det(rest._0);
        var de$2 = match$15[3];
        var ed$2 = match$15[2];
        var af$14 = match$15[1];
        var fa$14 = match$15[0];
        return [
                (function (param) {
                    curry._1(fa$14, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(af$14, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(ed$2, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    curry._1(de$2, /* Refl */0);
                    return /* Refl */0;
                  })
              ];
    
  }
}

function trans(ty1, ty2) {
  var exit = 0;
  if (typeof ty1 === "number") {
    if (typeof ty2 === "number") {
      return /* End_of_fmtty */0;
    }
    switch (ty2.TAG | 0) {
      case /* Format_arg_ty */8 :
          exit = 6;
          break;
      case /* Format_subst_ty */9 :
          exit = 7;
          break;
      case /* Alpha_ty */10 :
          exit = 1;
          break;
      case /* Theta_ty */11 :
          exit = 2;
          break;
      case /* Any_ty */12 :
          exit = 3;
          break;
      case /* Reader_ty */13 :
          exit = 4;
          break;
      case /* Ignored_reader_ty */14 :
          exit = 5;
          break;
      default:
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                846,
                23
              ],
              Error: new Error()
            };
    }
  } else {
    switch (ty1.TAG | 0) {
      case /* Char_ty */0 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Char_ty */0 :
                  return {
                          TAG: /* Char_ty */0,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* String_ty */1 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* String_ty */1 :
                  return {
                          TAG: /* String_ty */1,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Int_ty */2 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Int_ty */2 :
                  return {
                          TAG: /* Int_ty */2,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Int32_ty */3 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Int32_ty */3 :
                  return {
                          TAG: /* Int32_ty */3,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Nativeint_ty */4 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Nativeint_ty */4 :
                  return {
                          TAG: /* Nativeint_ty */4,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Int64_ty */5 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Int64_ty */5 :
                  return {
                          TAG: /* Int64_ty */5,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Float_ty */6 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Float_ty */6 :
                  return {
                          TAG: /* Float_ty */6,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Bool_ty */7 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Bool_ty */7 :
                  return {
                          TAG: /* Bool_ty */7,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Format_arg_ty */8 :
          if (typeof ty2 === "number") {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.ml",
                    832,
                    26
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Format_arg_ty */8 :
                return {
                        TAG: /* Format_arg_ty */8,
                        _0: trans(ty1._0, ty2._0),
                        _1: trans(ty1._1, ty2._1)
                      };
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                exit = 2;
                break;
            case /* Any_ty */12 :
                exit = 3;
                break;
            case /* Reader_ty */13 :
                exit = 4;
                break;
            case /* Ignored_reader_ty */14 :
                exit = 5;
                break;
            default:
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.ml",
                      832,
                      26
                    ],
                    Error: new Error()
                  };
          }
          break;
      case /* Format_subst_ty */9 :
          if (typeof ty2 === "number") {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.ml",
                    842,
                    28
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Format_arg_ty */8 :
                exit = 6;
                break;
            case /* Format_subst_ty */9 :
                var ty = trans(symm(ty1._1), ty2._0);
                var match = fmtty_rel_det(ty);
                curry._1(match[1], /* Refl */0);
                curry._1(match[3], /* Refl */0);
                return {
                        TAG: /* Format_subst_ty */9,
                        _0: ty1._0,
                        _1: ty2._1,
                        _2: trans(ty1._2, ty2._2)
                      };
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                exit = 2;
                break;
            case /* Any_ty */12 :
                exit = 3;
                break;
            case /* Reader_ty */13 :
                exit = 4;
                break;
            case /* Ignored_reader_ty */14 :
                exit = 5;
                break;
            default:
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.ml",
                      842,
                      28
                    ],
                    Error: new Error()
                  };
          }
          break;
      case /* Alpha_ty */10 :
          if (typeof ty2 === "number") {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.ml",
                    810,
                    21
                  ],
                  Error: new Error()
                };
          }
          if (ty2.TAG === /* Alpha_ty */10) {
            return {
                    TAG: /* Alpha_ty */10,
                    _0: trans(ty1._0, ty2._0)
                  };
          }
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.ml",
                  810,
                  21
                ],
                Error: new Error()
              };
      case /* Theta_ty */11 :
          if (typeof ty2 === "number") {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.ml",
                    814,
                    21
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                return {
                        TAG: /* Theta_ty */11,
                        _0: trans(ty1._0, ty2._0)
                      };
            default:
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.ml",
                      814,
                      21
                    ],
                    Error: new Error()
                  };
          }
          break;
      case /* Any_ty */12 :
          if (typeof ty2 === "number") {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.ml",
                    818,
                    19
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                exit = 2;
                break;
            case /* Any_ty */12 :
                return {
                        TAG: /* Any_ty */12,
                        _0: trans(ty1._0, ty2._0)
                      };
            default:
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.ml",
                      818,
                      19
                    ],
                    Error: new Error()
                  };
          }
          break;
      case /* Reader_ty */13 :
          if (typeof ty2 === "number") {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.ml",
                    822,
                    22
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                exit = 2;
                break;
            case /* Any_ty */12 :
                exit = 3;
                break;
            case /* Reader_ty */13 :
                return {
                        TAG: /* Reader_ty */13,
                        _0: trans(ty1._0, ty2._0)
                      };
            default:
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.ml",
                      822,
                      22
                    ],
                    Error: new Error()
                  };
          }
          break;
      case /* Ignored_reader_ty */14 :
          if (typeof ty2 === "number") {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.ml",
                    827,
                    30
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                exit = 2;
                break;
            case /* Any_ty */12 :
                exit = 3;
                break;
            case /* Reader_ty */13 :
                exit = 4;
                break;
            case /* Ignored_reader_ty */14 :
                return {
                        TAG: /* Ignored_reader_ty */14,
                        _0: trans(ty1._0, ty2._0)
                      };
            default:
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.ml",
                      827,
                      30
                    ],
                    Error: new Error()
                  };
          }
          break;
      
    }
  }
  switch (exit) {
    case 1 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                811,
                21
              ],
              Error: new Error()
            };
    case 2 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                815,
                21
              ],
              Error: new Error()
            };
    case 3 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                819,
                19
              ],
              Error: new Error()
            };
    case 4 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                823,
                22
              ],
              Error: new Error()
            };
    case 5 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                828,
                30
              ],
              Error: new Error()
            };
    case 6 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                833,
                26
              ],
              Error: new Error()
            };
    case 7 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                843,
                28
              ],
              Error: new Error()
            };
    case 8 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                847,
                23
              ],
              Error: new Error()
            };
    
  }
}

function fmtty_of_formatting_gen(formatting_gen) {
  return fmtty_of_fmt(formatting_gen._0._0);
}

function fmtty_of_fmt(_fmtty) {
  while(true) {
    var fmtty = _fmtty;
    if (typeof fmtty === "number") {
      return /* End_of_fmtty */0;
    }
    switch (fmtty.TAG | 0) {
      case /* String */2 :
      case /* Caml_string */3 :
          break;
      case /* Int */4 :
          var ty_rest = fmtty_of_fmt(fmtty._3);
          var prec_ty = fmtty_of_precision_fmtty(fmtty._2, {
                TAG: /* Int_ty */2,
                _0: ty_rest
              });
          return fmtty_of_padding_fmtty(fmtty._1, prec_ty);
      case /* Int32 */5 :
          var ty_rest$1 = fmtty_of_fmt(fmtty._3);
          var prec_ty$1 = fmtty_of_precision_fmtty(fmtty._2, {
                TAG: /* Int32_ty */3,
                _0: ty_rest$1
              });
          return fmtty_of_padding_fmtty(fmtty._1, prec_ty$1);
      case /* Nativeint */6 :
          var ty_rest$2 = fmtty_of_fmt(fmtty._3);
          var prec_ty$2 = fmtty_of_precision_fmtty(fmtty._2, {
                TAG: /* Nativeint_ty */4,
                _0: ty_rest$2
              });
          return fmtty_of_padding_fmtty(fmtty._1, prec_ty$2);
      case /* Int64 */7 :
          var ty_rest$3 = fmtty_of_fmt(fmtty._3);
          var prec_ty$3 = fmtty_of_precision_fmtty(fmtty._2, {
                TAG: /* Int64_ty */5,
                _0: ty_rest$3
              });
          return fmtty_of_padding_fmtty(fmtty._1, prec_ty$3);
      case /* Float */8 :
          var ty_rest$4 = fmtty_of_fmt(fmtty._3);
          var prec_ty$4 = fmtty_of_precision_fmtty(fmtty._2, {
                TAG: /* Float_ty */6,
                _0: ty_rest$4
              });
          return fmtty_of_padding_fmtty(fmtty._1, prec_ty$4);
      case /* Bool */9 :
          return fmtty_of_padding_fmtty(fmtty._0, {
                      TAG: /* Bool_ty */7,
                      _0: fmtty_of_fmt(fmtty._1)
                    });
      case /* Flush */10 :
          _fmtty = fmtty._0;
          continue ;
      case /* Format_arg */13 :
          return {
                  TAG: /* Format_arg_ty */8,
                  _0: fmtty._1,
                  _1: fmtty_of_fmt(fmtty._2)
                };
      case /* Format_subst */14 :
          var ty = fmtty._1;
          return {
                  TAG: /* Format_subst_ty */9,
                  _0: ty,
                  _1: ty,
                  _2: fmtty_of_fmt(fmtty._2)
                };
      case /* Alpha */15 :
          return {
                  TAG: /* Alpha_ty */10,
                  _0: fmtty_of_fmt(fmtty._0)
                };
      case /* Theta */16 :
          return {
                  TAG: /* Theta_ty */11,
                  _0: fmtty_of_fmt(fmtty._0)
                };
      case /* String_literal */11 :
      case /* Char_literal */12 :
      case /* Formatting_lit */17 :
          _fmtty = fmtty._1;
          continue ;
      case /* Formatting_gen */18 :
          return camlinternalFormatBasics.concat_fmtty(fmtty_of_formatting_gen(fmtty._0), fmtty_of_fmt(fmtty._1));
      case /* Reader */19 :
          return {
                  TAG: /* Reader_ty */13,
                  _0: fmtty_of_fmt(fmtty._0)
                };
      case /* Scan_char_set */20 :
          return {
                  TAG: /* String_ty */1,
                  _0: fmtty_of_fmt(fmtty._2)
                };
      case /* Scan_get_counter */21 :
          return {
                  TAG: /* Int_ty */2,
                  _0: fmtty_of_fmt(fmtty._1)
                };
      case /* Ignored_param */23 :
          var ign = fmtty._0;
          var fmt = fmtty._1;
          if (typeof ign === "number") {
            if (ign === /* Ignored_reader */2) {
              return {
                      TAG: /* Ignored_reader_ty */14,
                      _0: fmtty_of_fmt(fmt)
                    };
            } else {
              return fmtty_of_fmt(fmt);
            }
          } else if (ign.TAG === /* Ignored_format_subst */9) {
            return camlinternalFormatBasics.concat_fmtty(ign._1, fmtty_of_fmt(fmt));
          } else {
            return fmtty_of_fmt(fmt);
          }
      case /* Custom */24 :
          return fmtty_of_custom(fmtty._0, fmtty_of_fmt(fmtty._2));
      default:
        return {
                TAG: /* Char_ty */0,
                _0: fmtty_of_fmt(fmtty._0)
              };
    }
    return fmtty_of_padding_fmtty(fmtty._0, {
                TAG: /* String_ty */1,
                _0: fmtty_of_fmt(fmtty._1)
              });
  }}

function fmtty_of_custom(arity, fmtty) {
  if (arity) {
    return {
            TAG: /* Any_ty */12,
            _0: fmtty_of_custom(arity._0, fmtty)
          };
  } else {
    return fmtty;
  }
}

function fmtty_of_padding_fmtty(pad, fmtty) {
  if (typeof pad === "number" || pad.TAG === /* Lit_padding */0) {
    return fmtty;
  } else {
    return {
            TAG: /* Int_ty */2,
            _0: fmtty
          };
  }
}

function fmtty_of_precision_fmtty(prec, fmtty) {
  if (typeof prec === "number" && prec !== 0) {
    return {
            TAG: /* Int_ty */2,
            _0: fmtty
          };
  } else {
    return fmtty;
  }
}

var Type_mismatch = caml_exceptions.create("CamlinternalFormat.Type_mismatch");

function type_padding(pad, fmtty) {
  if (typeof pad === "number") {
    return /* Padding_fmtty_EBB */{
            _0: /* No_padding */0,
            _1: fmtty
          };
  }
  if (pad.TAG === /* Lit_padding */0) {
    return /* Padding_fmtty_EBB */{
            _0: {
              TAG: /* Lit_padding */0,
              _0: pad._0,
              _1: pad._1
            },
            _1: fmtty
          };
  }
  if (typeof fmtty === "number") {
    throw {
          RE_EXN_ID: Type_mismatch,
          Error: new Error()
        };
  }
  if (fmtty.TAG === /* Int_ty */2) {
    return /* Padding_fmtty_EBB */{
            _0: {
              TAG: /* Arg_padding */1,
              _0: pad._0
            },
            _1: fmtty._0
          };
  }
  throw {
        RE_EXN_ID: Type_mismatch,
        Error: new Error()
      };
}

function type_padprec(pad, prec, fmtty) {
  var match = type_padding(pad, fmtty);
  if (typeof prec !== "number") {
    return /* Padprec_fmtty_EBB */{
            _0: match._0,
            _1: /* Lit_precision */{
              _0: prec._0
            },
            _2: match._1
          };
  }
  if (prec === 0) {
    return /* Padprec_fmtty_EBB */{
            _0: match._0,
            _1: /* No_precision */0,
            _2: match._1
          };
  }
  var rest = match._1;
  if (typeof rest === "number") {
    throw {
          RE_EXN_ID: Type_mismatch,
          Error: new Error()
        };
  }
  if (rest.TAG === /* Int_ty */2) {
    return /* Padprec_fmtty_EBB */{
            _0: match._0,
            _1: /* Arg_precision */1,
            _2: rest._0
          };
  }
  throw {
        RE_EXN_ID: Type_mismatch,
        Error: new Error()
      };
}

function type_ignored_format_substitution(sub_fmtty, fmt, fmtty) {
  if (typeof sub_fmtty === "number") {
    return /* Fmtty_fmt_EBB */{
            _0: /* End_of_fmtty */0,
            _1: type_format_gen(fmt, fmtty)
          };
  }
  switch (sub_fmtty.TAG | 0) {
    case /* Char_ty */0 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Char_ty */0) {
          var match = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Char_ty */0,
                    _0: match._0
                  },
                  _1: match._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* String_ty */1 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* String_ty */1) {
          var match$1 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* String_ty */1,
                    _0: match$1._0
                  },
                  _1: match$1._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int_ty */2 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Int_ty */2) {
          var match$2 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Int_ty */2,
                    _0: match$2._0
                  },
                  _1: match$2._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int32_ty */3 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Int32_ty */3) {
          var match$3 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Int32_ty */3,
                    _0: match$3._0
                  },
                  _1: match$3._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Nativeint_ty */4 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Nativeint_ty */4) {
          var match$4 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Nativeint_ty */4,
                    _0: match$4._0
                  },
                  _1: match$4._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int64_ty */5 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Int64_ty */5) {
          var match$5 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Int64_ty */5,
                    _0: match$5._0
                  },
                  _1: match$5._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Float_ty */6 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Float_ty */6) {
          var match$6 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Float_ty */6,
                    _0: match$6._0
                  },
                  _1: match$6._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Bool_ty */7 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Bool_ty */7) {
          var match$7 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Bool_ty */7,
                    _0: match$7._0
                  },
                  _1: match$7._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Format_arg_ty */8 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Format_arg_ty */8) {
          var sub2_fmtty$prime = fmtty._0;
          if (caml_obj.caml_notequal(/* Fmtty_EBB */{
                  _0: sub_fmtty._0
                }, /* Fmtty_EBB */{
                  _0: sub2_fmtty$prime
                })) {
            throw {
                  RE_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          var match$8 = type_ignored_format_substitution(sub_fmtty._1, fmt, fmtty._1);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Format_arg_ty */8,
                    _0: sub2_fmtty$prime,
                    _1: match$8._0
                  },
                  _1: match$8._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Format_subst_ty */9 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Format_subst_ty */9) {
          var sub2_fmtty$prime$1 = fmtty._1;
          var sub1_fmtty$prime = fmtty._0;
          if (caml_obj.caml_notequal(/* Fmtty_EBB */{
                  _0: camlinternalFormatBasics.erase_rel(sub_fmtty._0)
                }, /* Fmtty_EBB */{
                  _0: camlinternalFormatBasics.erase_rel(sub1_fmtty$prime)
                })) {
            throw {
                  RE_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          if (caml_obj.caml_notequal(/* Fmtty_EBB */{
                  _0: camlinternalFormatBasics.erase_rel(sub_fmtty._1)
                }, /* Fmtty_EBB */{
                  _0: camlinternalFormatBasics.erase_rel(sub2_fmtty$prime$1)
                })) {
            throw {
                  RE_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          var sub_fmtty$prime = trans(symm(sub1_fmtty$prime), sub2_fmtty$prime$1);
          var match$9 = fmtty_rel_det(sub_fmtty$prime);
          curry._1(match$9[1], /* Refl */0);
          curry._1(match$9[3], /* Refl */0);
          var match$10 = type_ignored_format_substitution(camlinternalFormatBasics.erase_rel(sub_fmtty._2), fmt, fmtty._2);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Format_subst_ty */9,
                    _0: sub1_fmtty$prime,
                    _1: sub2_fmtty$prime$1,
                    _2: symm(match$10._0)
                  },
                  _1: match$10._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Alpha_ty */10 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Alpha_ty */10) {
          var match$11 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Alpha_ty */10,
                    _0: match$11._0
                  },
                  _1: match$11._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Theta_ty */11 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Theta_ty */11) {
          var match$12 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Theta_ty */11,
                    _0: match$12._0
                  },
                  _1: match$12._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Any_ty */12 :
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Reader_ty */13 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Reader_ty */13) {
          var match$13 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Reader_ty */13,
                    _0: match$13._0
                  },
                  _1: match$13._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Ignored_reader_ty */14 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Ignored_reader_ty */14) {
          var match$14 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Ignored_reader_ty */14,
                    _0: match$14._0
                  },
                  _1: match$14._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    
  }
}

function type_format_gen(fmt, fmtty) {
  if (typeof fmt === "number") {
    return /* Fmt_fmtty_EBB */{
            _0: /* End_of_format */0,
            _1: fmtty
          };
  }
  switch (fmt.TAG | 0) {
    case /* Char */0 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Char_ty */0) {
          var match = type_format_gen(fmt._0, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Char */0,
                    _0: match._0
                  },
                  _1: match._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Caml_char */1 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Char_ty */0) {
          var match$1 = type_format_gen(fmt._0, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Caml_char */1,
                    _0: match$1._0
                  },
                  _1: match$1._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* String */2 :
        var match$2 = type_padding(fmt._0, fmtty);
        var fmtty_rest = match$2._1;
        if (typeof fmtty_rest === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest.TAG === /* String_ty */1) {
          var match$3 = type_format_gen(fmt._1, fmtty_rest._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* String */2,
                    _0: match$2._0,
                    _1: match$3._0
                  },
                  _1: match$3._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Caml_string */3 :
        var match$4 = type_padding(fmt._0, fmtty);
        var fmtty_rest$1 = match$4._1;
        if (typeof fmtty_rest$1 === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$1.TAG === /* String_ty */1) {
          var match$5 = type_format_gen(fmt._1, fmtty_rest$1._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Caml_string */3,
                    _0: match$4._0,
                    _1: match$5._0
                  },
                  _1: match$5._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int */4 :
        var match$6 = type_padprec(fmt._1, fmt._2, fmtty);
        var fmtty_rest$2 = match$6._2;
        if (typeof fmtty_rest$2 === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$2.TAG === /* Int_ty */2) {
          var match$7 = type_format_gen(fmt._3, fmtty_rest$2._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Int */4,
                    _0: fmt._0,
                    _1: match$6._0,
                    _2: match$6._1,
                    _3: match$7._0
                  },
                  _1: match$7._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int32 */5 :
        var match$8 = type_padprec(fmt._1, fmt._2, fmtty);
        var fmtty_rest$3 = match$8._2;
        if (typeof fmtty_rest$3 === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$3.TAG === /* Int32_ty */3) {
          var match$9 = type_format_gen(fmt._3, fmtty_rest$3._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Int32 */5,
                    _0: fmt._0,
                    _1: match$8._0,
                    _2: match$8._1,
                    _3: match$9._0
                  },
                  _1: match$9._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Nativeint */6 :
        var match$10 = type_padprec(fmt._1, fmt._2, fmtty);
        var fmtty_rest$4 = match$10._2;
        if (typeof fmtty_rest$4 === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$4.TAG === /* Nativeint_ty */4) {
          var match$11 = type_format_gen(fmt._3, fmtty_rest$4._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Nativeint */6,
                    _0: fmt._0,
                    _1: match$10._0,
                    _2: match$10._1,
                    _3: match$11._0
                  },
                  _1: match$11._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int64 */7 :
        var match$12 = type_padprec(fmt._1, fmt._2, fmtty);
        var fmtty_rest$5 = match$12._2;
        if (typeof fmtty_rest$5 === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$5.TAG === /* Int64_ty */5) {
          var match$13 = type_format_gen(fmt._3, fmtty_rest$5._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Int64 */7,
                    _0: fmt._0,
                    _1: match$12._0,
                    _2: match$12._1,
                    _3: match$13._0
                  },
                  _1: match$13._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Float */8 :
        var match$14 = type_padprec(fmt._1, fmt._2, fmtty);
        var fmtty_rest$6 = match$14._2;
        if (typeof fmtty_rest$6 === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$6.TAG === /* Float_ty */6) {
          var match$15 = type_format_gen(fmt._3, fmtty_rest$6._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Float */8,
                    _0: fmt._0,
                    _1: match$14._0,
                    _2: match$14._1,
                    _3: match$15._0
                  },
                  _1: match$15._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Bool */9 :
        var match$16 = type_padding(fmt._0, fmtty);
        var fmtty_rest$7 = match$16._1;
        if (typeof fmtty_rest$7 === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$7.TAG === /* Bool_ty */7) {
          var match$17 = type_format_gen(fmt._1, fmtty_rest$7._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Bool */9,
                    _0: match$16._0,
                    _1: match$17._0
                  },
                  _1: match$17._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Flush */10 :
        var match$18 = type_format_gen(fmt._0, fmtty);
        return /* Fmt_fmtty_EBB */{
                _0: {
                  TAG: /* Flush */10,
                  _0: match$18._0
                },
                _1: match$18._1
              };
    case /* String_literal */11 :
        var match$19 = type_format_gen(fmt._1, fmtty);
        return /* Fmt_fmtty_EBB */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: fmt._0,
                  _1: match$19._0
                },
                _1: match$19._1
              };
    case /* Char_literal */12 :
        var match$20 = type_format_gen(fmt._1, fmtty);
        return /* Fmt_fmtty_EBB */{
                _0: {
                  TAG: /* Char_literal */12,
                  _0: fmt._0,
                  _1: match$20._0
                },
                _1: match$20._1
              };
    case /* Format_arg */13 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Format_arg_ty */8) {
          var sub_fmtty$prime = fmtty._0;
          if (caml_obj.caml_notequal(/* Fmtty_EBB */{
                  _0: fmt._1
                }, /* Fmtty_EBB */{
                  _0: sub_fmtty$prime
                })) {
            throw {
                  RE_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          var match$21 = type_format_gen(fmt._2, fmtty._1);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Format_arg */13,
                    _0: fmt._0,
                    _1: sub_fmtty$prime,
                    _2: match$21._0
                  },
                  _1: match$21._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Format_subst */14 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Format_subst_ty */9) {
          var sub_fmtty1 = fmtty._0;
          if (caml_obj.caml_notequal(/* Fmtty_EBB */{
                  _0: camlinternalFormatBasics.erase_rel(fmt._1)
                }, /* Fmtty_EBB */{
                  _0: camlinternalFormatBasics.erase_rel(sub_fmtty1)
                })) {
            throw {
                  RE_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          var match$22 = type_format_gen(fmt._2, camlinternalFormatBasics.erase_rel(fmtty._2));
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Format_subst */14,
                    _0: fmt._0,
                    _1: sub_fmtty1,
                    _2: match$22._0
                  },
                  _1: match$22._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Alpha */15 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Alpha_ty */10) {
          var match$23 = type_format_gen(fmt._0, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Alpha */15,
                    _0: match$23._0
                  },
                  _1: match$23._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Theta */16 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Theta_ty */11) {
          var match$24 = type_format_gen(fmt._0, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Theta */16,
                    _0: match$24._0
                  },
                  _1: match$24._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Formatting_lit */17 :
        var match$25 = type_format_gen(fmt._1, fmtty);
        return /* Fmt_fmtty_EBB */{
                _0: {
                  TAG: /* Formatting_lit */17,
                  _0: fmt._0,
                  _1: match$25._0
                },
                _1: match$25._1
              };
    case /* Formatting_gen */18 :
        var formatting_gen = fmt._0;
        var fmt0 = fmt._1;
        if (formatting_gen.TAG === /* Open_tag */0) {
          var match$26 = formatting_gen._0;
          var match$27 = type_format_gen(match$26._0, fmtty);
          var match$28 = type_format_gen(fmt0, match$27._1);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Formatting_gen */18,
                    _0: {
                      TAG: /* Open_tag */0,
                      _0: /* Format */{
                        _0: match$27._0,
                        _1: match$26._1
                      }
                    },
                    _1: match$28._0
                  },
                  _1: match$28._1
                };
        }
        var match$29 = formatting_gen._0;
        var match$30 = type_format_gen(match$29._0, fmtty);
        var match$31 = type_format_gen(fmt0, match$30._1);
        return /* Fmt_fmtty_EBB */{
                _0: {
                  TAG: /* Formatting_gen */18,
                  _0: {
                    TAG: /* Open_box */1,
                    _0: /* Format */{
                      _0: match$30._0,
                      _1: match$29._1
                    }
                  },
                  _1: match$31._0
                },
                _1: match$31._1
              };
    case /* Reader */19 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Reader_ty */13) {
          var match$32 = type_format_gen(fmt._0, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Reader */19,
                    _0: match$32._0
                  },
                  _1: match$32._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Scan_char_set */20 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* String_ty */1) {
          var match$33 = type_format_gen(fmt._2, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Scan_char_set */20,
                    _0: fmt._0,
                    _1: fmt._1,
                    _2: match$33._0
                  },
                  _1: match$33._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Scan_get_counter */21 :
        if (typeof fmtty === "number") {
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Int_ty */2) {
          var match$34 = type_format_gen(fmt._1, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Scan_get_counter */21,
                    _0: fmt._0,
                    _1: match$34._0
                  },
                  _1: match$34._1
                };
        }
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Ignored_param */23 :
        var ign = fmt._0;
        var fmt$1 = fmt._1;
        if (typeof ign === "number") {
          if (ign !== /* Ignored_reader */2) {
            return type_ignored_param_one(ign, fmt$1, fmtty);
          }
          if (typeof fmtty === "number") {
            throw {
                  RE_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          if (fmtty.TAG === /* Ignored_reader_ty */14) {
            var match$35 = type_format_gen(fmt$1, fmtty._0);
            return /* Fmt_fmtty_EBB */{
                    _0: {
                      TAG: /* Ignored_param */23,
                      _0: /* Ignored_reader */2,
                      _1: match$35._0
                    },
                    _1: match$35._1
                  };
          }
          throw {
                RE_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        } else {
          switch (ign.TAG | 0) {
            case /* Ignored_format_arg */8 :
                return type_ignored_param_one({
                            TAG: /* Ignored_format_arg */8,
                            _0: ign._0,
                            _1: ign._1
                          }, fmt$1, fmtty);
            case /* Ignored_format_subst */9 :
                var match$36 = type_ignored_format_substitution(ign._1, fmt$1, fmtty);
                var match$37 = match$36._1;
                return /* Fmt_fmtty_EBB */{
                        _0: {
                          TAG: /* Ignored_param */23,
                          _0: {
                            TAG: /* Ignored_format_subst */9,
                            _0: ign._0,
                            _1: match$36._0
                          },
                          _1: match$37._0
                        },
                        _1: match$37._1
                      };
            default:
              return type_ignored_param_one(ign, fmt$1, fmtty);
          }
        }
    case /* Scan_next_char */22 :
    case /* Custom */24 :
        throw {
              RE_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    
  }
}

function type_ignored_param_one(ign, fmt, fmtty) {
  var match = type_format_gen(fmt, fmtty);
  return /* Fmt_fmtty_EBB */{
          _0: {
            TAG: /* Ignored_param */23,
            _0: ign,
            _1: match._0
          },
          _1: match._1
        };
}

function type_format(fmt, fmtty) {
  var match = type_format_gen(fmt, fmtty);
  if (typeof match._1 === "number") {
    return match._0;
  }
  throw {
        RE_EXN_ID: Type_mismatch,
        Error: new Error()
      };
}

function recast(fmt, fmtty) {
  return type_format(fmt, camlinternalFormatBasics.erase_rel(symm(fmtty)));
}

function fix_padding(padty, width, str) {
  var len = str.length;
  var width$1 = pervasives.abs(width);
  var padty$1 = width < 0 ? /* Left */0 : padty;
  if (width$1 <= len) {
    return str;
  }
  var res = bytes.make(width$1, padty$1 === /* Zeros */2 ? /* "0" */48 : /* " " */32);
  switch (padty$1) {
    case /* Left */0 :
        string.blit(str, 0, res, 0, len);
        break;
    case /* Right */1 :
        string.blit(str, 0, res, width$1 - len | 0, len);
        break;
    case /* Zeros */2 :
        if (len > 0 && (caml_string.get(str, 0) === /* "+" */43 || caml_string.get(str, 0) === /* "-" */45 || caml_string.get(str, 0) === /* " " */32)) {
          caml_bytes.set(res, 0, caml_string.get(str, 0));
          string.blit(str, 1, res, (width$1 - len | 0) + 1 | 0, len - 1 | 0);
        } else if (len > 1 && caml_string.get(str, 0) === /* "0" */48 && (caml_string.get(str, 1) === /* "x" */120 || caml_string.get(str, 1) === /* "X" */88)) {
          caml_bytes.set(res, 1, caml_string.get(str, 1));
          string.blit(str, 2, res, (width$1 - len | 0) + 2 | 0, len - 2 | 0);
        } else {
          string.blit(str, 0, res, width$1 - len | 0, len);
        }
        break;
    
  }
  return caml_bytes.bytes_to_string(res);
}

function fix_int_precision(prec, str) {
  var prec$1 = pervasives.abs(prec);
  var len = str.length;
  var c = caml_string.get(str, 0);
  var exit = 0;
  if (c >= 58) {
    if (c >= 71) {
      if (c > 102 || c < 97) {
        return str;
      }
      exit = 2;
    } else {
      if (c < 65) {
        return str;
      }
      exit = 2;
    }
  } else if (c !== 32) {
    if (c < 43) {
      return str;
    }
    switch (c - 43 | 0) {
      case 0 :
      case 2 :
          exit = 1;
          break;
      case 1 :
      case 3 :
      case 4 :
          return str;
      case 5 :
          if ((prec$1 + 2 | 0) > len && len > 1 && (caml_string.get(str, 1) === /* "x" */120 || caml_string.get(str, 1) === /* "X" */88)) {
            var res = bytes.make(prec$1 + 2 | 0, /* "0" */48);
            caml_bytes.set(res, 1, caml_string.get(str, 1));
            string.blit(str, 2, res, (prec$1 - len | 0) + 4 | 0, len - 2 | 0);
            return caml_bytes.bytes_to_string(res);
          }
          exit = 2;
          break;
      case 6 :
      case 7 :
      case 8 :
      case 9 :
      case 10 :
      case 11 :
      case 12 :
      case 13 :
      case 14 :
          exit = 2;
          break;
      
    }
  } else {
    exit = 1;
  }
  switch (exit) {
    case 1 :
        if ((prec$1 + 1 | 0) <= len) {
          return str;
        }
        var res$1 = bytes.make(prec$1 + 1 | 0, /* "0" */48);
        caml_bytes.set(res$1, 0, c);
        string.blit(str, 1, res$1, (prec$1 - len | 0) + 2 | 0, len - 1 | 0);
        return caml_bytes.bytes_to_string(res$1);
    case 2 :
        if (prec$1 <= len) {
          return str;
        }
        var res$2 = bytes.make(prec$1, /* "0" */48);
        string.blit(str, 0, res$2, prec$1 - len | 0, len);
        return caml_bytes.bytes_to_string(res$2);
    
  }
}

function string_to_caml_string(str) {
  var str$1 = string.escaped(str);
  var l = str$1.length;
  var res = bytes.make(l + 2 | 0, /* "\"" */34);
  caml_bytes.caml_blit_string(str$1, 0, res, 1, l);
  return caml_bytes.bytes_to_string(res);
}

function format_of_iconv(param) {
  switch (param) {
    case /* Int_d */0 :
        return "%d";
    case /* Int_pd */1 :
        return "%+d";
    case /* Int_sd */2 :
        return "% d";
    case /* Int_i */3 :
        return "%i";
    case /* Int_pi */4 :
        return "%+i";
    case /* Int_si */5 :
        return "% i";
    case /* Int_x */6 :
        return "%x";
    case /* Int_Cx */7 :
        return "%#x";
    case /* Int_X */8 :
        return "%X";
    case /* Int_CX */9 :
        return "%#X";
    case /* Int_o */10 :
        return "%o";
    case /* Int_Co */11 :
        return "%#o";
    case /* Int_u */12 :
        return "%u";
    
  }
}

function format_of_iconvL(param) {
  switch (param) {
    case /* Int_d */0 :
        return "%Ld";
    case /* Int_pd */1 :
        return "%+Ld";
    case /* Int_sd */2 :
        return "% Ld";
    case /* Int_i */3 :
        return "%Li";
    case /* Int_pi */4 :
        return "%+Li";
    case /* Int_si */5 :
        return "% Li";
    case /* Int_x */6 :
        return "%Lx";
    case /* Int_Cx */7 :
        return "%#Lx";
    case /* Int_X */8 :
        return "%LX";
    case /* Int_CX */9 :
        return "%#LX";
    case /* Int_o */10 :
        return "%Lo";
    case /* Int_Co */11 :
        return "%#Lo";
    case /* Int_u */12 :
        return "%Lu";
    
  }
}

function format_of_iconvl(param) {
  switch (param) {
    case /* Int_d */0 :
        return "%ld";
    case /* Int_pd */1 :
        return "%+ld";
    case /* Int_sd */2 :
        return "% ld";
    case /* Int_i */3 :
        return "%li";
    case /* Int_pi */4 :
        return "%+li";
    case /* Int_si */5 :
        return "% li";
    case /* Int_x */6 :
        return "%lx";
    case /* Int_Cx */7 :
        return "%#lx";
    case /* Int_X */8 :
        return "%lX";
    case /* Int_CX */9 :
        return "%#lX";
    case /* Int_o */10 :
        return "%lo";
    case /* Int_Co */11 :
        return "%#lo";
    case /* Int_u */12 :
        return "%lu";
    
  }
}

function format_of_iconvn(param) {
  switch (param) {
    case /* Int_d */0 :
        return "%nd";
    case /* Int_pd */1 :
        return "%+nd";
    case /* Int_sd */2 :
        return "% nd";
    case /* Int_i */3 :
        return "%ni";
    case /* Int_pi */4 :
        return "%+ni";
    case /* Int_si */5 :
        return "% ni";
    case /* Int_x */6 :
        return "%nx";
    case /* Int_Cx */7 :
        return "%#nx";
    case /* Int_X */8 :
        return "%nX";
    case /* Int_CX */9 :
        return "%#nX";
    case /* Int_o */10 :
        return "%no";
    case /* Int_Co */11 :
        return "%#no";
    case /* Int_u */12 :
        return "%nu";
    
  }
}

function format_of_fconv(fconv, prec) {
  if (fconv === /* Float_F */15) {
    return "%.12g";
  }
  var prec$1 = pervasives.abs(prec);
  var symb = char_of_fconv(fconv);
  var buf = {
    ind: 0,
    bytes: caml_bytes.caml_create_bytes(16)
  };
  buffer_add_char(buf, /* "%" */37);
  bprint_fconv_flag(buf, fconv);
  buffer_add_char(buf, /* "." */46);
  buffer_add_string(buf, String(prec$1));
  buffer_add_char(buf, symb);
  return buffer_contents(buf);
}

function convert_int(iconv, n) {
  return caml_format.caml_format_int(format_of_iconv(iconv), n);
}

function convert_int32(iconv, n) {
  return caml_format.caml_int32_format(format_of_iconvl(iconv), n);
}

function convert_nativeint(iconv, n) {
  return caml_format.caml_nativeint_format(format_of_iconvn(iconv), n);
}

function convert_int64(iconv, n) {
  return caml_format.caml_int64_format(format_of_iconvL(iconv), n);
}

function convert_float(fconv, prec, x) {
  if (fconv >= 16) {
    var sign;
    if (fconv >= 17) {
      switch (fconv - 17 | 0) {
        case /* Float_sf */2 :
            sign = /* "-" */45;
            break;
        case /* Float_f */0 :
        case /* Float_e */3 :
            sign = /* "+" */43;
            break;
        case /* Float_pf */1 :
        case /* Float_pe */4 :
            sign = /* " " */32;
            break;
        
      }
    } else {
      sign = /* "-" */45;
    }
    var str = caml_format.caml_hexstring_of_float(x, prec, sign);
    if (fconv >= 19) {
      return caml_bytes.bytes_to_string(bytes.uppercase_ascii(caml_bytes.bytes_of_string(str)));
    } else {
      return str;
    }
  }
  var str$1 = caml_format.caml_format_float(format_of_fconv(fconv, prec), x);
  if (fconv !== /* Float_F */15) {
    return str$1;
  }
  var len = str$1.length;
  var is_valid = function (_i) {
    while(true) {
      var i = _i;
      if (i === len) {
        return false;
      }
      var match = caml_string.get(str$1, i);
      var switcher = match - 46 | 0;
      if (switcher > 23 || switcher < 0) {
        if (switcher === 55) {
          return true;
        }
        _i = i + 1 | 0;
        continue ;
      }
      if (switcher > 22 || switcher < 1) {
        return true;
      }
      _i = i + 1 | 0;
      continue ;
    }  };
  var match = pervasives.classify_float(x);
  if (match !== 3) {
    if (match >= 4) {
      return "nan";
    } else if (is_valid(0)) {
      return str$1;
    } else {
      return str$1 + ".";
    }
  } else if (x < 0.0) {
    return "neg_infinity";
  } else {
    return "infinity";
  }
}

function format_caml_char(c) {
  var str = char.escaped(c);
  var l = str.length;
  var res = bytes.make(l + 2 | 0, /* "'" */39);
  caml_bytes.caml_blit_string(str, 0, res, 1, l);
  return caml_bytes.bytes_to_string(res);
}

function string_of_fmtty(fmtty) {
  var buf = {
    ind: 0,
    bytes: caml_bytes.caml_create_bytes(16)
  };
  bprint_fmtty(buf, fmtty);
  return buffer_contents(buf);
}

function make_printf(_k, o, _acc, _fmt) {
  while(true) {
    var fmt = _fmt;
    var acc = _acc;
    var k = _k;
    if (typeof fmt === "number") {
      return curry._2(k, o, acc);
    }
    switch (fmt.TAG | 0) {
      case /* Char */0 :
          var rest = fmt._0;
          return (function(k,acc,rest){
          return function (c) {
            var new_acc = {
              TAG: /* Acc_data_char */5,
              _0: acc,
              _1: c
            };
            return make_printf(k, o, new_acc, rest);
          }
          }(k,acc,rest));
      case /* Caml_char */1 :
          var rest$1 = fmt._0;
          return (function(k,acc,rest$1){
          return function (c) {
            var new_acc_1 = format_caml_char(c);
            var new_acc = {
              TAG: /* Acc_data_string */4,
              _0: acc,
              _1: new_acc_1
            };
            return make_printf(k, o, new_acc, rest$1);
          }
          }(k,acc,rest$1));
      case /* String */2 :
          return make_padding(k, o, acc, fmt._1, fmt._0, (function (str) {
                        return str;
                      }));
      case /* Caml_string */3 :
          return make_padding(k, o, acc, fmt._1, fmt._0, string_to_caml_string);
      case /* Int */4 :
          return make_int_padding_precision(k, o, acc, fmt._3, fmt._1, fmt._2, convert_int, fmt._0);
      case /* Int32 */5 :
          return make_int_padding_precision(k, o, acc, fmt._3, fmt._1, fmt._2, convert_int32, fmt._0);
      case /* Nativeint */6 :
          return make_int_padding_precision(k, o, acc, fmt._3, fmt._1, fmt._2, convert_nativeint, fmt._0);
      case /* Int64 */7 :
          return make_int_padding_precision(k, o, acc, fmt._3, fmt._1, fmt._2, convert_int64, fmt._0);
      case /* Float */8 :
          var fmt$1 = fmt._3;
          var pad = fmt._1;
          var prec = fmt._2;
          var fconv = fmt._0;
          if (typeof pad === "number") {
            if (typeof prec === "number") {
              if (prec !== 0) {
                return (function(k,acc,fmt$1,fconv){
                return function (p, x) {
                  var str = convert_float(fconv, p, x);
                  return make_printf(k, o, {
                              TAG: /* Acc_data_string */4,
                              _0: acc,
                              _1: str
                            }, fmt$1);
                }
                }(k,acc,fmt$1,fconv));
              } else {
                return (function(k,acc,fmt$1,fconv){
                return function (x) {
                  var str = convert_float(fconv, -6, x);
                  return make_printf(k, o, {
                              TAG: /* Acc_data_string */4,
                              _0: acc,
                              _1: str
                            }, fmt$1);
                }
                }(k,acc,fmt$1,fconv));
              }
            }
            var p = prec._0;
            return (function(k,acc,fmt$1,fconv,p){
            return function (x) {
              var str = convert_float(fconv, p, x);
              return make_printf(k, o, {
                          TAG: /* Acc_data_string */4,
                          _0: acc,
                          _1: str
                        }, fmt$1);
            }
            }(k,acc,fmt$1,fconv,p));
          }
          if (pad.TAG === /* Lit_padding */0) {
            var w = pad._1;
            var padty = pad._0;
            if (typeof prec === "number") {
              if (prec !== 0) {
                return (function(k,acc,fmt$1,fconv,padty,w){
                return function (p, x) {
                  var str = fix_padding(padty, w, convert_float(fconv, p, x));
                  return make_printf(k, o, {
                              TAG: /* Acc_data_string */4,
                              _0: acc,
                              _1: str
                            }, fmt$1);
                }
                }(k,acc,fmt$1,fconv,padty,w));
              } else {
                return (function(k,acc,fmt$1,fconv,padty,w){
                return function (x) {
                  var str = convert_float(fconv, -6, x);
                  var str$prime = fix_padding(padty, w, str);
                  return make_printf(k, o, {
                              TAG: /* Acc_data_string */4,
                              _0: acc,
                              _1: str$prime
                            }, fmt$1);
                }
                }(k,acc,fmt$1,fconv,padty,w));
              }
            }
            var p$1 = prec._0;
            return (function(k,acc,fmt$1,fconv,padty,w,p$1){
            return function (x) {
              var str = fix_padding(padty, w, convert_float(fconv, p$1, x));
              return make_printf(k, o, {
                          TAG: /* Acc_data_string */4,
                          _0: acc,
                          _1: str
                        }, fmt$1);
            }
            }(k,acc,fmt$1,fconv,padty,w,p$1));
          }
          var padty$1 = pad._0;
          if (typeof prec === "number") {
            if (prec !== 0) {
              return (function(k,acc,fmt$1,fconv,padty$1){
              return function (w, p, x) {
                var str = fix_padding(padty$1, w, convert_float(fconv, p, x));
                return make_printf(k, o, {
                            TAG: /* Acc_data_string */4,
                            _0: acc,
                            _1: str
                          }, fmt$1);
              }
              }(k,acc,fmt$1,fconv,padty$1));
            } else {
              return (function(k,acc,fmt$1,fconv,padty$1){
              return function (w, x) {
                var str = convert_float(fconv, -6, x);
                var str$prime = fix_padding(padty$1, w, str);
                return make_printf(k, o, {
                            TAG: /* Acc_data_string */4,
                            _0: acc,
                            _1: str$prime
                          }, fmt$1);
              }
              }(k,acc,fmt$1,fconv,padty$1));
            }
          }
          var p$2 = prec._0;
          return (function(k,acc,fmt$1,fconv,padty$1,p$2){
          return function (w, x) {
            var str = fix_padding(padty$1, w, convert_float(fconv, p$2, x));
            return make_printf(k, o, {
                        TAG: /* Acc_data_string */4,
                        _0: acc,
                        _1: str
                      }, fmt$1);
          }
          }(k,acc,fmt$1,fconv,padty$1,p$2));
      case /* Bool */9 :
          return make_padding(k, o, acc, fmt._1, fmt._0, pervasives.string_of_bool);
      case /* Flush */10 :
          _fmt = fmt._0;
          _acc = {
            TAG: /* Acc_flush */7,
            _0: acc
          };
          continue ;
      case /* String_literal */11 :
          _fmt = fmt._1;
          _acc = {
            TAG: /* Acc_string_literal */2,
            _0: acc,
            _1: fmt._0
          };
          continue ;
      case /* Char_literal */12 :
          _fmt = fmt._1;
          _acc = {
            TAG: /* Acc_char_literal */3,
            _0: acc,
            _1: fmt._0
          };
          continue ;
      case /* Format_arg */13 :
          var rest$2 = fmt._2;
          var ty = string_of_fmtty(fmt._1);
          return (function(k,acc,rest$2,ty){
          return function (str) {
            return make_printf(k, o, {
                        TAG: /* Acc_data_string */4,
                        _0: acc,
                        _1: ty
                      }, rest$2);
          }
          }(k,acc,rest$2,ty));
      case /* Format_subst */14 :
          var rest$3 = fmt._2;
          var fmtty = fmt._1;
          return (function(k,acc,fmtty,rest$3){
          return function (param) {
            return make_printf(k, o, acc, camlinternalFormatBasics.concat_fmt(recast(param._0, fmtty), rest$3));
          }
          }(k,acc,fmtty,rest$3));
      case /* Alpha */15 :
          var rest$4 = fmt._0;
          return (function(k,acc,rest$4){
          return function (f, x) {
            return make_printf(k, o, {
                        TAG: /* Acc_delay */6,
                        _0: acc,
                        _1: (function (o) {
                            return curry._2(f, o, x);
                          })
                      }, rest$4);
          }
          }(k,acc,rest$4));
      case /* Theta */16 :
          var rest$5 = fmt._0;
          return (function(k,acc,rest$5){
          return function (f) {
            return make_printf(k, o, {
                        TAG: /* Acc_delay */6,
                        _0: acc,
                        _1: f
                      }, rest$5);
          }
          }(k,acc,rest$5));
      case /* Formatting_lit */17 :
          _fmt = fmt._1;
          _acc = {
            TAG: /* Acc_formatting_lit */0,
            _0: acc,
            _1: fmt._0
          };
          continue ;
      case /* Formatting_gen */18 :
          var match = fmt._0;
          if (match.TAG === /* Open_tag */0) {
            var rest$6 = fmt._1;
            var k$prime = (function(k,acc,rest$6){
            return function k$prime(koc, kacc) {
              return make_printf(k, koc, {
                          TAG: /* Acc_formatting_gen */1,
                          _0: acc,
                          _1: {
                            TAG: /* Acc_open_tag */0,
                            _0: kacc
                          }
                        }, rest$6);
            }
            }(k,acc,rest$6));
            _fmt = match._0._0;
            _acc = /* End_of_acc */0;
            _k = k$prime;
            continue ;
          }
          var rest$7 = fmt._1;
          var k$prime$1 = (function(k,acc,rest$7){
          return function k$prime$1(koc, kacc) {
            return make_printf(k, koc, {
                        TAG: /* Acc_formatting_gen */1,
                        _0: acc,
                        _1: {
                          TAG: /* Acc_open_box */1,
                          _0: kacc
                        }
                      }, rest$7);
          }
          }(k,acc,rest$7));
          _fmt = match._0._0;
          _acc = /* End_of_acc */0;
          _k = k$prime$1;
          continue ;
      case /* Reader */19 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.ml",
                  1525,
                  4
                ],
                Error: new Error()
              };
      case /* Scan_char_set */20 :
          var rest$8 = fmt._2;
          var new_acc = {
            TAG: /* Acc_invalid_arg */8,
            _0: acc,
            _1: "Printf: bad conversion %["
          };
          return (function(k,rest$8,new_acc){
          return function (param) {
            return make_printf(k, o, new_acc, rest$8);
          }
          }(k,rest$8,new_acc));
      case /* Scan_get_counter */21 :
          var rest$9 = fmt._1;
          return (function(k,acc,rest$9){
          return function (n) {
            var new_acc_1 = caml_format.caml_format_int("%u", n);
            var new_acc = {
              TAG: /* Acc_data_string */4,
              _0: acc,
              _1: new_acc_1
            };
            return make_printf(k, o, new_acc, rest$9);
          }
          }(k,acc,rest$9));
      case /* Scan_next_char */22 :
          var rest$10 = fmt._0;
          return (function(k,acc,rest$10){
          return function (c) {
            var new_acc = {
              TAG: /* Acc_data_char */5,
              _0: acc,
              _1: c
            };
            return make_printf(k, o, new_acc, rest$10);
          }
          }(k,acc,rest$10));
      case /* Ignored_param */23 :
          return make_ignored_param(k, o, acc, fmt._0, fmt._1);
      case /* Custom */24 :
          return make_custom(k, o, acc, fmt._2, fmt._0, curry._1(fmt._1, undefined));
      
    }
  }}

function make_ignored_param(k, o, acc, ign, fmt) {
  if (typeof ign !== "number") {
    if (ign.TAG === /* Ignored_format_subst */9) {
      return make_from_fmtty(k, o, acc, ign._1, fmt);
    } else {
      return make_invalid_arg(k, o, acc, fmt);
    }
  }
  if (ign !== /* Ignored_reader */2) {
    return make_invalid_arg(k, o, acc, fmt);
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalFormat.ml",
          1593,
          39
        ],
        Error: new Error()
      };
}

function make_from_fmtty(k, o, acc, fmtty, fmt) {
  if (typeof fmtty === "number") {
    return make_invalid_arg(k, o, acc, fmt);
  }
  switch (fmtty.TAG | 0) {
    case /* Char_ty */0 :
        var rest = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest, fmt);
        };
    case /* String_ty */1 :
        var rest$1 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest$1, fmt);
        };
    case /* Int_ty */2 :
        var rest$2 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest$2, fmt);
        };
    case /* Int32_ty */3 :
        var rest$3 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest$3, fmt);
        };
    case /* Nativeint_ty */4 :
        var rest$4 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest$4, fmt);
        };
    case /* Int64_ty */5 :
        var rest$5 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest$5, fmt);
        };
    case /* Float_ty */6 :
        var rest$6 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest$6, fmt);
        };
    case /* Bool_ty */7 :
        var rest$7 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest$7, fmt);
        };
    case /* Format_arg_ty */8 :
        var rest$8 = fmtty._1;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest$8, fmt);
        };
    case /* Format_subst_ty */9 :
        var rest$9 = fmtty._2;
        var ty = trans(symm(fmtty._0), fmtty._1);
        return function (param) {
          return make_from_fmtty(k, o, acc, camlinternalFormatBasics.concat_fmtty(ty, rest$9), fmt);
        };
    case /* Alpha_ty */10 :
        var rest$10 = fmtty._0;
        return function (param, param$1) {
          return make_from_fmtty(k, o, acc, rest$10, fmt);
        };
    case /* Theta_ty */11 :
        var rest$11 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest$11, fmt);
        };
    case /* Any_ty */12 :
        var rest$12 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, o, acc, rest$12, fmt);
        };
    case /* Reader_ty */13 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                1616,
                31
              ],
              Error: new Error()
            };
    case /* Ignored_reader_ty */14 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                1617,
                31
              ],
              Error: new Error()
            };
    
  }
}

function make_invalid_arg(k, o, acc, fmt) {
  return make_printf(k, o, {
              TAG: /* Acc_invalid_arg */8,
              _0: acc,
              _1: "Printf: bad conversion %_"
            }, fmt);
}

function make_padding(k, o, acc, fmt, pad, trans) {
  if (typeof pad === "number") {
    return function (x) {
      var new_acc_1 = curry._1(trans, x);
      var new_acc = {
        TAG: /* Acc_data_string */4,
        _0: acc,
        _1: new_acc_1
      };
      return make_printf(k, o, new_acc, fmt);
    };
  }
  if (pad.TAG === /* Lit_padding */0) {
    var width = pad._1;
    var padty = pad._0;
    return function (x) {
      var new_acc_1 = fix_padding(padty, width, curry._1(trans, x));
      var new_acc = {
        TAG: /* Acc_data_string */4,
        _0: acc,
        _1: new_acc_1
      };
      return make_printf(k, o, new_acc, fmt);
    };
  }
  var padty$1 = pad._0;
  return function (w, x) {
    var new_acc_1 = fix_padding(padty$1, w, curry._1(trans, x));
    var new_acc = {
      TAG: /* Acc_data_string */4,
      _0: acc,
      _1: new_acc_1
    };
    return make_printf(k, o, new_acc, fmt);
  };
}

function make_int_padding_precision(k, o, acc, fmt, pad, prec, trans, iconv) {
  if (typeof pad === "number") {
    if (typeof prec === "number") {
      if (prec !== 0) {
        return function (p, x) {
          var str = fix_int_precision(p, curry._2(trans, iconv, x));
          return make_printf(k, o, {
                      TAG: /* Acc_data_string */4,
                      _0: acc,
                      _1: str
                    }, fmt);
        };
      } else {
        return function (x) {
          var str = curry._2(trans, iconv, x);
          return make_printf(k, o, {
                      TAG: /* Acc_data_string */4,
                      _0: acc,
                      _1: str
                    }, fmt);
        };
      }
    }
    var p = prec._0;
    return function (x) {
      var str = fix_int_precision(p, curry._2(trans, iconv, x));
      return make_printf(k, o, {
                  TAG: /* Acc_data_string */4,
                  _0: acc,
                  _1: str
                }, fmt);
    };
  }
  if (pad.TAG === /* Lit_padding */0) {
    var w = pad._1;
    var padty = pad._0;
    if (typeof prec === "number") {
      if (prec !== 0) {
        return function (p, x) {
          var str = fix_padding(padty, w, fix_int_precision(p, curry._2(trans, iconv, x)));
          return make_printf(k, o, {
                      TAG: /* Acc_data_string */4,
                      _0: acc,
                      _1: str
                    }, fmt);
        };
      } else {
        return function (x) {
          var str = fix_padding(padty, w, curry._2(trans, iconv, x));
          return make_printf(k, o, {
                      TAG: /* Acc_data_string */4,
                      _0: acc,
                      _1: str
                    }, fmt);
        };
      }
    }
    var p$1 = prec._0;
    return function (x) {
      var str = fix_padding(padty, w, fix_int_precision(p$1, curry._2(trans, iconv, x)));
      return make_printf(k, o, {
                  TAG: /* Acc_data_string */4,
                  _0: acc,
                  _1: str
                }, fmt);
    };
  }
  var padty$1 = pad._0;
  if (typeof prec === "number") {
    if (prec !== 0) {
      return function (w, p, x) {
        var str = fix_padding(padty$1, w, fix_int_precision(p, curry._2(trans, iconv, x)));
        return make_printf(k, o, {
                    TAG: /* Acc_data_string */4,
                    _0: acc,
                    _1: str
                  }, fmt);
      };
    } else {
      return function (w, x) {
        var str = fix_padding(padty$1, w, curry._2(trans, iconv, x));
        return make_printf(k, o, {
                    TAG: /* Acc_data_string */4,
                    _0: acc,
                    _1: str
                  }, fmt);
      };
    }
  }
  var p$2 = prec._0;
  return function (w, x) {
    var str = fix_padding(padty$1, w, fix_int_precision(p$2, curry._2(trans, iconv, x)));
    return make_printf(k, o, {
                TAG: /* Acc_data_string */4,
                _0: acc,
                _1: str
              }, fmt);
  };
}

function make_custom(k, o, acc, rest, arity, f) {
  if (!arity) {
    return make_printf(k, o, {
                TAG: /* Acc_data_string */4,
                _0: acc,
                _1: f
              }, rest);
  }
  var arity$1 = arity._0;
  return function (x) {
    return make_custom(k, o, acc, rest, arity$1, curry._1(f, x));
  };
}

function make_iprintf(_k, o, _fmt) {
  while(true) {
    var fmt = _fmt;
    var k = _k;
    var exit = 0;
    if (typeof fmt === "number") {
      return curry._1(k, o);
    }
    switch (fmt.TAG | 0) {
      case /* String */2 :
          var exit$1 = 0;
          var tmp = fmt._0;
          if (typeof tmp === "number" || tmp.TAG === /* Lit_padding */0) {
            exit$1 = 4;
          } else {
            var partial_arg = make_iprintf(k, o, fmt._1);
            var partial_arg$1 = (function(partial_arg){
            return function partial_arg$1(param) {
              return partial_arg;
            }
            }(partial_arg));
            return function (param) {
              return partial_arg$1;
            };
          }
          if (exit$1 === 4) {
            var partial_arg$2 = make_iprintf(k, o, fmt._1);
            return (function(partial_arg$2){
            return function (param) {
              return partial_arg$2;
            }
            }(partial_arg$2));
          }
          break;
      case /* Caml_string */3 :
          var exit$2 = 0;
          var tmp$1 = fmt._0;
          if (typeof tmp$1 === "number" || tmp$1.TAG === /* Lit_padding */0) {
            exit$2 = 4;
          } else {
            var partial_arg$3 = make_iprintf(k, o, fmt._1);
            var partial_arg$4 = (function(partial_arg$3){
            return function partial_arg$4(param) {
              return partial_arg$3;
            }
            }(partial_arg$3));
            return function (param) {
              return partial_arg$4;
            };
          }
          if (exit$2 === 4) {
            var partial_arg$5 = make_iprintf(k, o, fmt._1);
            return (function(partial_arg$5){
            return function (param) {
              return partial_arg$5;
            }
            }(partial_arg$5));
          }
          break;
      case /* Bool */9 :
          var exit$3 = 0;
          var tmp$2 = fmt._0;
          if (typeof tmp$2 === "number" || tmp$2.TAG === /* Lit_padding */0) {
            exit$3 = 4;
          } else {
            var partial_arg$6 = make_iprintf(k, o, fmt._1);
            var partial_arg$7 = (function(partial_arg$6){
            return function partial_arg$7(param) {
              return partial_arg$6;
            }
            }(partial_arg$6));
            return function (param) {
              return partial_arg$7;
            };
          }
          if (exit$3 === 4) {
            var partial_arg$8 = make_iprintf(k, o, fmt._1);
            return (function(partial_arg$8){
            return function (param) {
              return partial_arg$8;
            }
            }(partial_arg$8));
          }
          break;
      case /* Flush */10 :
          _fmt = fmt._0;
          continue ;
      case /* Format_subst */14 :
          var rest = fmt._2;
          var fmtty = fmt._1;
          return (function(k,fmtty,rest){
          return function (param) {
            return make_iprintf(k, o, camlinternalFormatBasics.concat_fmt(recast(param._0, fmtty), rest));
          }
          }(k,fmtty,rest));
      case /* Alpha */15 :
          var partial_arg$9 = make_iprintf(k, o, fmt._0);
          var partial_arg$10 = (function(partial_arg$9){
          return function partial_arg$10(param) {
            return partial_arg$9;
          }
          }(partial_arg$9));
          return function (param) {
            return partial_arg$10;
          };
      case /* String_literal */11 :
      case /* Char_literal */12 :
      case /* Formatting_lit */17 :
          exit = 2;
          break;
      case /* Formatting_gen */18 :
          var match = fmt._0;
          if (match.TAG === /* Open_tag */0) {
            var rest$1 = fmt._1;
            _fmt = match._0._0;
            _k = (function(k,rest$1){
            return function (koc) {
              return make_iprintf(k, koc, rest$1);
            }
            }(k,rest$1));
            continue ;
          }
          var rest$2 = fmt._1;
          _fmt = match._0._0;
          _k = (function(k,rest$2){
          return function (koc) {
            return make_iprintf(k, koc, rest$2);
          }
          }(k,rest$2));
          continue ;
      case /* Reader */19 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.ml",
                  1797,
                  8
                ],
                Error: new Error()
              };
      case /* Format_arg */13 :
      case /* Scan_char_set */20 :
          exit = 3;
          break;
      case /* Scan_get_counter */21 :
          var partial_arg$11 = make_iprintf(k, o, fmt._1);
          return (function(partial_arg$11){
          return function (param) {
            return partial_arg$11;
          }
          }(partial_arg$11));
      case /* Char */0 :
      case /* Caml_char */1 :
      case /* Theta */16 :
      case /* Scan_next_char */22 :
          exit = 1;
          break;
      case /* Ignored_param */23 :
          return make_ignored_param((function(k){
                    return function (x, param) {
                      return curry._1(k, x);
                    }
                    }(k)), o, /* End_of_acc */0, fmt._0, fmt._1);
      case /* Custom */24 :
          return fn_of_custom_arity(k, o, fmt._2, fmt._0);
      default:
        var fmt$1 = fmt._3;
        var pad = fmt._1;
        var prec = fmt._2;
        if (typeof pad === "number") {
          if (typeof prec === "number") {
            if (prec !== 0) {
              var partial_arg$12 = make_iprintf(k, o, fmt$1);
              var partial_arg$13 = (function(partial_arg$12){
              return function partial_arg$13(param) {
                return partial_arg$12;
              }
              }(partial_arg$12));
              return function (param) {
                return partial_arg$13;
              };
            }
            var partial_arg$14 = make_iprintf(k, o, fmt$1);
            return (function(partial_arg$14){
            return function (param) {
              return partial_arg$14;
            }
            }(partial_arg$14));
          }
          var partial_arg$15 = make_iprintf(k, o, fmt$1);
          return (function(partial_arg$15){
          return function (param) {
            return partial_arg$15;
          }
          }(partial_arg$15));
        }
        if (pad.TAG === /* Lit_padding */0) {
          if (typeof prec === "number") {
            if (prec !== 0) {
              var partial_arg$16 = make_iprintf(k, o, fmt$1);
              var partial_arg$17 = (function(partial_arg$16){
              return function partial_arg$17(param) {
                return partial_arg$16;
              }
              }(partial_arg$16));
              return function (param) {
                return partial_arg$17;
              };
            }
            var partial_arg$18 = make_iprintf(k, o, fmt$1);
            return (function(partial_arg$18){
            return function (param) {
              return partial_arg$18;
            }
            }(partial_arg$18));
          }
          var partial_arg$19 = make_iprintf(k, o, fmt$1);
          return (function(partial_arg$19){
          return function (param) {
            return partial_arg$19;
          }
          }(partial_arg$19));
        }
        if (typeof prec === "number") {
          if (prec !== 0) {
            var partial_arg$20 = make_iprintf(k, o, fmt$1);
            var partial_arg$21 = (function(partial_arg$20){
            return function partial_arg$21(param) {
              return partial_arg$20;
            }
            }(partial_arg$20));
            var partial_arg$22 = function (param) {
              return partial_arg$21;
            };
            return function (param) {
              return partial_arg$22;
            };
          }
          var partial_arg$23 = make_iprintf(k, o, fmt$1);
          var partial_arg$24 = (function(partial_arg$23){
          return function partial_arg$24(param) {
            return partial_arg$23;
          }
          }(partial_arg$23));
          return function (param) {
            return partial_arg$24;
          };
        }
        var partial_arg$25 = make_iprintf(k, o, fmt$1);
        var partial_arg$26 = (function(partial_arg$25){
        return function partial_arg$26(param) {
          return partial_arg$25;
        }
        }(partial_arg$25));
        return function (param) {
          return partial_arg$26;
        };
    }
    switch (exit) {
      case 1 :
          var partial_arg$27 = make_iprintf(k, o, fmt._0);
          return (function(partial_arg$27){
          return function (param) {
            return partial_arg$27;
          }
          }(partial_arg$27));
      case 2 :
          _fmt = fmt._1;
          continue ;
      case 3 :
          var partial_arg$28 = make_iprintf(k, o, fmt._2);
          return (function(partial_arg$28){
          return function (param) {
            return partial_arg$28;
          }
          }(partial_arg$28));
      
    }
  }}

function fn_of_custom_arity(k, o, fmt, arity) {
  if (!arity) {
    return make_iprintf(k, o, fmt);
  }
  var partial_arg = fn_of_custom_arity(k, o, fmt, arity._0);
  return function (param) {
    return partial_arg;
  };
}

function output_acc(o, _acc) {
  while(true) {
    var acc = _acc;
    var exit = 0;
    if (typeof acc === "number") {
      return ;
    }
    switch (acc.TAG | 0) {
      case /* Acc_formatting_lit */0 :
          var s = string_of_formatting_lit(acc._1);
          output_acc(o, acc._0);
          return pervasives.output_string(o, s);
      case /* Acc_formatting_gen */1 :
          var acc$prime = acc._1;
          var p = acc._0;
          if (acc$prime.TAG === /* Acc_open_tag */0) {
            output_acc(o, p);
            pervasives.output_string(o, "@{");
            _acc = acc$prime._0;
            continue ;
          }
          output_acc(o, p);
          pervasives.output_string(o, "@[");
          _acc = acc$prime._0;
          continue ;
      case /* Acc_string_literal */2 :
      case /* Acc_data_string */4 :
          exit = 1;
          break;
      case /* Acc_char_literal */3 :
      case /* Acc_data_char */5 :
          exit = 2;
          break;
      case /* Acc_delay */6 :
          output_acc(o, acc._0);
          return curry._1(acc._1, o);
      case /* Acc_flush */7 :
          output_acc(o, acc._0);
          return caml_io.caml_ml_flush(o);
      case /* Acc_invalid_arg */8 :
          output_acc(o, acc._0);
          throw {
                RE_EXN_ID: "Invalid_argument",
                _1: acc._1,
                Error: new Error()
              };
      
    }
    switch (exit) {
      case 1 :
          output_acc(o, acc._0);
          return pervasives.output_string(o, acc._1);
      case 2 :
          output_acc(o, acc._0);
          return caml_io.caml_ml_output_char(o, acc._1);
      
    }
  }}

function bufput_acc(b, _acc) {
  while(true) {
    var acc = _acc;
    var exit = 0;
    if (typeof acc === "number") {
      return ;
    }
    switch (acc.TAG | 0) {
      case /* Acc_formatting_lit */0 :
          var s = string_of_formatting_lit(acc._1);
          bufput_acc(b, acc._0);
          return buffer.add_string(b, s);
      case /* Acc_formatting_gen */1 :
          var acc$prime = acc._1;
          var p = acc._0;
          if (acc$prime.TAG === /* Acc_open_tag */0) {
            bufput_acc(b, p);
            buffer.add_string(b, "@{");
            _acc = acc$prime._0;
            continue ;
          }
          bufput_acc(b, p);
          buffer.add_string(b, "@[");
          _acc = acc$prime._0;
          continue ;
      case /* Acc_string_literal */2 :
      case /* Acc_data_string */4 :
          exit = 1;
          break;
      case /* Acc_char_literal */3 :
      case /* Acc_data_char */5 :
          exit = 2;
          break;
      case /* Acc_delay */6 :
          bufput_acc(b, acc._0);
          return curry._1(acc._1, b);
      case /* Acc_flush */7 :
          _acc = acc._0;
          continue ;
      case /* Acc_invalid_arg */8 :
          bufput_acc(b, acc._0);
          throw {
                RE_EXN_ID: "Invalid_argument",
                _1: acc._1,
                Error: new Error()
              };
      
    }
    switch (exit) {
      case 1 :
          bufput_acc(b, acc._0);
          return buffer.add_string(b, acc._1);
      case 2 :
          bufput_acc(b, acc._0);
          return buffer.add_char(b, acc._1);
      
    }
  }}

function strput_acc(b, _acc) {
  while(true) {
    var acc = _acc;
    var exit = 0;
    if (typeof acc === "number") {
      return ;
    }
    switch (acc.TAG | 0) {
      case /* Acc_formatting_lit */0 :
          var s = string_of_formatting_lit(acc._1);
          strput_acc(b, acc._0);
          return buffer.add_string(b, s);
      case /* Acc_formatting_gen */1 :
          var acc$prime = acc._1;
          var p = acc._0;
          if (acc$prime.TAG === /* Acc_open_tag */0) {
            strput_acc(b, p);
            buffer.add_string(b, "@{");
            _acc = acc$prime._0;
            continue ;
          }
          strput_acc(b, p);
          buffer.add_string(b, "@[");
          _acc = acc$prime._0;
          continue ;
      case /* Acc_string_literal */2 :
      case /* Acc_data_string */4 :
          exit = 1;
          break;
      case /* Acc_char_literal */3 :
      case /* Acc_data_char */5 :
          exit = 2;
          break;
      case /* Acc_delay */6 :
          strput_acc(b, acc._0);
          return buffer.add_string(b, curry._1(acc._1, undefined));
      case /* Acc_flush */7 :
          _acc = acc._0;
          continue ;
      case /* Acc_invalid_arg */8 :
          strput_acc(b, acc._0);
          throw {
                RE_EXN_ID: "Invalid_argument",
                _1: acc._1,
                Error: new Error()
              };
      
    }
    switch (exit) {
      case 1 :
          strput_acc(b, acc._0);
          return buffer.add_string(b, acc._1);
      case 2 :
          strput_acc(b, acc._0);
          return buffer.add_char(b, acc._1);
      
    }
  }}

function failwith_message(param) {
  var buf = buffer.create(256);
  var k = function (param, acc) {
    strput_acc(buf, acc);
    var s = buffer.contents(buf);
    throw {
          RE_EXN_ID: "Failure",
          _1: s,
          Error: new Error()
        };
  };
  return make_printf(k, undefined, /* End_of_acc */0, param._0);
}

function open_box_of_string(str) {
  if (str === "") {
    return [
            0,
            /* Pp_box */4
          ];
  }
  var len = str.length;
  var invalid_box = function (param) {
    return curry._1(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid box description ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "invalid box description %S"
                  }), str);
  };
  var parse_spaces = function (_i) {
    while(true) {
      var i = _i;
      if (i === len) {
        return i;
      }
      var match = caml_string.get(str, i);
      if (match !== 9) {
        if (match !== 32) {
          return i;
        }
        _i = i + 1 | 0;
        continue ;
      }
      _i = i + 1 | 0;
      continue ;
    }  };
  var parse_lword = function (i, _j) {
    while(true) {
      var j = _j;
      if (j === len) {
        return j;
      }
      var match = caml_string.get(str, j);
      if (match > 122 || match < 97) {
        return j;
      }
      _j = j + 1 | 0;
      continue ;
    }  };
  var parse_int = function (i, _j) {
    while(true) {
      var j = _j;
      if (j === len) {
        return j;
      }
      var match = caml_string.get(str, j);
      if (match >= 48) {
        if (match >= 58) {
          return j;
        }
        _j = j + 1 | 0;
        continue ;
      }
      if (match !== 45) {
        return j;
      }
      _j = j + 1 | 0;
      continue ;
    }  };
  var wstart = parse_spaces(0);
  var wend = parse_lword(wstart, wstart);
  var box_name = string.sub(str, wstart, wend - wstart | 0);
  var nstart = parse_spaces(wend);
  var nend = parse_int(nstart, nstart);
  var indent;
  if (nstart === nend) {
    indent = 0;
  } else {
    try {
      indent = caml_format.caml_int_of_string(string.sub(str, nstart, nend - nstart | 0));
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Failure") {
        indent = invalid_box();
      } else {
        throw exn;
      }
    }
  }
  var exp_end = parse_spaces(nend);
  if (exp_end !== len) {
    invalid_box();
  }
  var box_type;
  switch (box_name) {
    case "" :
    case "b" :
        box_type = /* Pp_box */4;
        break;
    case "h" :
        box_type = /* Pp_hbox */0;
        break;
    case "hov" :
        box_type = /* Pp_hovbox */3;
        break;
    case "hv" :
        box_type = /* Pp_hvbox */2;
        break;
    case "v" :
        box_type = /* Pp_vbox */1;
        break;
    default:
      box_type = invalid_box();
  }
  return [
          indent,
          box_type
        ];
}

function make_padding_fmt_ebb(pad, fmt) {
  if (typeof pad === "number") {
    return /* Padding_fmt_EBB */{
            _0: /* No_padding */0,
            _1: fmt
          };
  } else if (pad.TAG === /* Lit_padding */0) {
    return /* Padding_fmt_EBB */{
            _0: {
              TAG: /* Lit_padding */0,
              _0: pad._0,
              _1: pad._1
            },
            _1: fmt
          };
  } else {
    return /* Padding_fmt_EBB */{
            _0: {
              TAG: /* Arg_padding */1,
              _0: pad._0
            },
            _1: fmt
          };
  }
}

function make_precision_fmt_ebb(prec, fmt) {
  if (typeof prec === "number") {
    if (prec !== 0) {
      return /* Precision_fmt_EBB */{
              _0: /* Arg_precision */1,
              _1: fmt
            };
    } else {
      return /* Precision_fmt_EBB */{
              _0: /* No_precision */0,
              _1: fmt
            };
    }
  } else {
    return /* Precision_fmt_EBB */{
            _0: /* Lit_precision */{
              _0: prec._0
            },
            _1: fmt
          };
  }
}

function make_padprec_fmt_ebb(pad, prec, fmt) {
  var match = make_precision_fmt_ebb(prec, fmt);
  var fmt$prime = match._1;
  var prec$1 = match._0;
  if (typeof pad === "number") {
    return /* Padprec_fmt_EBB */{
            _0: /* No_padding */0,
            _1: prec$1,
            _2: fmt$prime
          };
  } else if (pad.TAG === /* Lit_padding */0) {
    return /* Padprec_fmt_EBB */{
            _0: {
              TAG: /* Lit_padding */0,
              _0: pad._0,
              _1: pad._1
            },
            _1: prec$1,
            _2: fmt$prime
          };
  } else {
    return /* Padprec_fmt_EBB */{
            _0: {
              TAG: /* Arg_padding */1,
              _0: pad._0
            },
            _1: prec$1,
            _2: fmt$prime
          };
  }
}

function fmt_ebb_of_string(legacy_behavior, str) {
  var legacy_behavior$1 = legacy_behavior !== undefined ? legacy_behavior : true;
  var invalid_format_message = function (str_ind, msg) {
    return curry._3(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid format ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": at character number ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: ", ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "invalid format %S: at character number %d, %s"
                  }), str, str_ind, msg);
  };
  var invalid_format_without = function (str_ind, c, s) {
    return curry._4(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid format ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": at character number ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: ", '",
                              _1: {
                                TAG: /* Char */0,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "' without ",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "invalid format %S: at character number %d, '%c' without %s"
                  }), str, str_ind, c, s);
  };
  var expected_character = function (str_ind, expected, read) {
    return curry._4(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid format ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": at character number ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: ", ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: " expected, read ",
                                  _1: {
                                    TAG: /* Caml_char */1,
                                    _0: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "invalid format %S: at character number %d, %s expected, read %C"
                  }), str, str_ind, expected, read);
  };
  var incompatible_flag = function (pct_ind, str_ind, symb, option) {
    var subfmt = string.sub(str, pct_ind, str_ind - pct_ind | 0);
    return curry._5(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid format ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": at character number ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: ", ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: " is incompatible with '",
                                  _1: {
                                    TAG: /* Char */0,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "' in sub-format ",
                                      _1: {
                                        TAG: /* Caml_string */3,
                                        _0: /* No_padding */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"
                  }), str, pct_ind, option, symb, subfmt);
  };
  var parse_positive = function (_str_ind, end_ind, _acc) {
    while(true) {
      var acc = _acc;
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var c = caml_string.get(str, str_ind);
      if (c > 57 || c < 48) {
        return [
                str_ind,
                acc
              ];
      }
      var new_acc = Math.imul(acc, 10) + (c - /* "0" */48 | 0) | 0;
      _acc = new_acc;
      _str_ind = str_ind + 1 | 0;
      continue ;
    }  };
  var parse_after_padding = function (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var symb = caml_string.get(str, str_ind);
    if (symb !== 46) {
      return parse_conversion(pct_ind, str_ind + 1 | 0, end_ind, plus, hash, space, ign, pad, /* No_precision */0, pad, symb);
    } else {
      var str_ind$1 = str_ind + 1 | 0;
      if (str_ind$1 === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var parse_literal = function (minus, str_ind) {
        var match = parse_positive(str_ind, end_ind, 0);
        return parse_after_precision(pct_ind, match[0], end_ind, minus, plus, hash, space, ign, pad, /* Lit_precision */{
                    _0: match[1]
                  });
      };
      var symb$1 = caml_string.get(str, str_ind$1);
      var exit = 0;
      if (symb$1 >= 48) {
        if (symb$1 < 58) {
          return parse_literal(minus, str_ind$1);
        }
        
      } else if (symb$1 >= 42) {
        switch (symb$1 - 42 | 0) {
          case 0 :
              return parse_after_precision(pct_ind, str_ind$1 + 1 | 0, end_ind, minus, plus, hash, space, ign, pad, /* Arg_precision */1);
          case 1 :
          case 3 :
              exit = 2;
              break;
          
        }
      }
      if (exit === 2 && legacy_behavior$1) {
        return parse_literal(minus || symb$1 === /* "-" */45, str_ind$1 + 1 | 0);
      }
      if (legacy_behavior$1) {
        return parse_after_precision(pct_ind, str_ind$1, end_ind, minus, plus, hash, space, ign, pad, /* Lit_precision */{
                    _0: 0
                  });
      } else {
        return invalid_format_without(str_ind$1 - 1 | 0, /* "." */46, "precision");
      }
    }
  };
  var parse_spaces = function (_str_ind, end_ind) {
    while(true) {
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      if (caml_string.get(str, str_ind) !== /* " " */32) {
        return str_ind;
      }
      _str_ind = str_ind + 1 | 0;
      continue ;
    }  };
  var search_subformat_end = function (_str_ind, end_ind, c) {
    while(true) {
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        curry._3(failwith_message(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "invalid format ",
                    _1: {
                      TAG: /* Caml_string */3,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": unclosed sub-format, expected \"",
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* "%" */37,
                          _1: {
                            TAG: /* Char */0,
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "\" at character number ",
                              _1: {
                                TAG: /* Int */4,
                                _0: /* Int_d */0,
                                _1: /* No_padding */0,
                                _2: /* No_precision */0,
                                _3: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "invalid format %S: unclosed sub-format, expected \"%%%c\" at character number %d"
                }), str, c, end_ind);
      }
      var match = caml_string.get(str, str_ind);
      if (match !== 37) {
        _str_ind = str_ind + 1 | 0;
        continue ;
      }
      if ((str_ind + 1 | 0) === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      if (caml_string.get(str, str_ind + 1 | 0) === c) {
        return str_ind;
      }
      var match$1 = caml_string.get(str, str_ind + 1 | 0);
      if (match$1 >= 95) {
        if (match$1 >= 123) {
          if (match$1 < 126) {
            switch (match$1 - 123 | 0) {
              case 0 :
                  var sub_end = search_subformat_end(str_ind + 2 | 0, end_ind, /* "}" */125);
                  _str_ind = sub_end + 2 | 0;
                  continue ;
              case 1 :
                  break;
              case 2 :
                  return expected_character(str_ind + 1 | 0, "character ')'", /* "}" */125);
              
            }
          }
          
        } else if (match$1 < 96) {
          if ((str_ind + 2 | 0) === end_ind) {
            invalid_format_message(end_ind, "unexpected end of format");
          }
          var match$2 = caml_string.get(str, str_ind + 2 | 0);
          if (match$2 !== 40) {
            if (match$2 !== 123) {
              _str_ind = str_ind + 3 | 0;
              continue ;
            }
            var sub_end$1 = search_subformat_end(str_ind + 3 | 0, end_ind, /* "}" */125);
            _str_ind = sub_end$1 + 2 | 0;
            continue ;
          }
          var sub_end$2 = search_subformat_end(str_ind + 3 | 0, end_ind, /* ")" */41);
          _str_ind = sub_end$2 + 2 | 0;
          continue ;
        }
        
      } else if (match$1 !== 40) {
        if (match$1 === 41) {
          return expected_character(str_ind + 1 | 0, "character '}'", /* ")" */41);
        }
        
      } else {
        var sub_end$3 = search_subformat_end(str_ind + 2 | 0, end_ind, /* ")" */41);
        _str_ind = sub_end$3 + 2 | 0;
        continue ;
      }
      _str_ind = str_ind + 2 | 0;
      continue ;
    }  };
  var compute_int_conv = function (pct_ind, str_ind, _plus, _hash, _space, symb) {
    while(true) {
      var space = _space;
      var hash = _hash;
      var plus = _plus;
      var exit = 0;
      if (plus) {
        if (hash) {
          exit = 2;
        } else if (!space) {
          if (symb === 100) {
            return /* Int_pd */1;
          }
          if (symb === 105) {
            return /* Int_pi */4;
          }
          
        }
        
      } else if (hash) {
        if (space) {
          exit = 2;
        } else {
          if (symb === 88) {
            return /* Int_CX */9;
          }
          if (symb === 111) {
            return /* Int_Co */11;
          }
          if (symb === 120) {
            return /* Int_Cx */7;
          }
          exit = 2;
        }
      } else if (space) {
        if (symb === 100) {
          return /* Int_sd */2;
        }
        if (symb === 105) {
          return /* Int_si */5;
        }
        
      } else {
        switch (symb) {
          case 88 :
              return /* Int_X */8;
          case 100 :
              return /* Int_d */0;
          case 105 :
              return /* Int_i */3;
          case 111 :
              return /* Int_o */10;
          case 117 :
              return /* Int_u */12;
          case 89 :
          case 90 :
          case 91 :
          case 92 :
          case 93 :
          case 94 :
          case 95 :
          case 96 :
          case 97 :
          case 98 :
          case 99 :
          case 101 :
          case 102 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 112 :
          case 113 :
          case 114 :
          case 115 :
          case 116 :
          case 118 :
          case 119 :
              break;
          case 120 :
              return /* Int_x */6;
            
        }
      }
      if (exit === 2) {
        var exit$1 = 0;
        switch (symb) {
          case 88 :
              if (legacy_behavior$1) {
                return /* Int_CX */9;
              }
              break;
          case 111 :
              if (legacy_behavior$1) {
                return /* Int_Co */11;
              }
              break;
          case 100 :
          case 105 :
          case 117 :
              exit$1 = 3;
              break;
          case 89 :
          case 90 :
          case 91 :
          case 92 :
          case 93 :
          case 94 :
          case 95 :
          case 96 :
          case 97 :
          case 98 :
          case 99 :
          case 101 :
          case 102 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 112 :
          case 113 :
          case 114 :
          case 115 :
          case 116 :
          case 118 :
          case 119 :
              break;
          case 120 :
              if (legacy_behavior$1) {
                return /* Int_Cx */7;
              }
              break;
            
        }
        if (exit$1 === 3) {
          if (!legacy_behavior$1) {
            return incompatible_flag(pct_ind, str_ind, symb, "'#'");
          }
          _hash = false;
          continue ;
        }
        
      }
      if (plus) {
        if (space) {
          if (!legacy_behavior$1) {
            return incompatible_flag(pct_ind, str_ind, /* " " */32, "'+'");
          }
          _space = false;
          continue ;
        }
        if (!legacy_behavior$1) {
          return incompatible_flag(pct_ind, str_ind, symb, "'+'");
        }
        _plus = false;
        continue ;
      }
      if (space) {
        if (!legacy_behavior$1) {
          return incompatible_flag(pct_ind, str_ind, symb, "' '");
        }
        _space = false;
        continue ;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.ml",
              2909,
              28
            ],
            Error: new Error()
          };
    }  };
  var parse_literal = function (lit_start, _str_ind, end_ind) {
    while(true) {
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        return add_literal(lit_start, str_ind, /* End_of_format */0);
      }
      var match = caml_string.get(str, str_ind);
      if (match !== 37) {
        if (match !== 64) {
          _str_ind = str_ind + 1 | 0;
          continue ;
        }
        var fmt_rest = parse_after_at(str_ind + 1 | 0, end_ind);
        return add_literal(lit_start, str_ind, fmt_rest._0);
      }
      var fmt_rest$1 = parse_format(str_ind, end_ind);
      return add_literal(lit_start, str_ind, fmt_rest$1._0);
    }  };
  var parse_integer = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var match = caml_string.get(str, str_ind);
    if (match >= 48) {
      if (match >= 58) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                2814,
                11
              ],
              Error: new Error()
            };
      }
      return parse_positive(str_ind, end_ind, 0);
    }
    if (match !== 45) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.ml",
              2814,
              11
            ],
            Error: new Error()
          };
    }
    if ((str_ind + 1 | 0) === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var c = caml_string.get(str, str_ind + 1 | 0);
    if (c > 57 || c < 48) {
      return expected_character(str_ind + 1 | 0, "digit", c);
    }
    var match$1 = parse_positive(str_ind + 1 | 0, end_ind, 0);
    return [
            match$1[0],
            -match$1[1] | 0
          ];
  };
  var parse_after_precision = function (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var parse_conv = function (padprec) {
      return parse_conversion(pct_ind, str_ind + 1 | 0, end_ind, plus, hash, space, ign, pad, prec, padprec, caml_string.get(str, str_ind));
    };
    if (typeof pad !== "number") {
      return parse_conv(pad);
    }
    if (typeof prec === "number" && prec === 0) {
      return parse_conv(/* No_padding */0);
    }
    if (minus) {
      if (typeof prec === "number") {
        return parse_conv({
                    TAG: /* Arg_padding */1,
                    _0: /* Left */0
                  });
      } else {
        return parse_conv({
                    TAG: /* Lit_padding */0,
                    _0: /* Left */0,
                    _1: prec._0
                  });
      }
    } else if (typeof prec === "number") {
      return parse_conv({
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                });
    } else {
      return parse_conv({
                  TAG: /* Lit_padding */0,
                  _0: /* Right */1,
                  _1: prec._0
                });
    }
  };
  var parse_flags = function (pct_ind, str_ind, end_ind, ign) {
    var zero = {
      contents: false
    };
    var minus = {
      contents: false
    };
    var plus = {
      contents: false
    };
    var space = {
      contents: false
    };
    var hash = {
      contents: false
    };
    var set_flag = function (str_ind, flag) {
      if (flag.contents && !legacy_behavior$1) {
        curry._3(failwith_message(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "invalid format ",
                    _1: {
                      TAG: /* Caml_string */3,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": at character number ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: ", duplicate flag ",
                            _1: {
                              TAG: /* Caml_char */1,
                              _0: /* End_of_format */0
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "invalid format %S: at character number %d, duplicate flag %C"
                }), str, str_ind, caml_string.get(str, str_ind));
      }
      flag.contents = true;
      
    };
    var _str_ind = str_ind;
    while(true) {
      var str_ind$1 = _str_ind;
      if (str_ind$1 === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var match = caml_string.get(str, str_ind$1);
      switch (match) {
        case 32 :
            set_flag(str_ind$1, space);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 35 :
            set_flag(str_ind$1, hash);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 43 :
            set_flag(str_ind$1, plus);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 45 :
            set_flag(str_ind$1, minus);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 33 :
        case 34 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 40 :
        case 41 :
        case 42 :
        case 44 :
        case 46 :
        case 47 :
            break;
        case 48 :
            set_flag(str_ind$1, zero);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
          
      }
      var zero$1 = zero.contents;
      var minus$1 = minus.contents;
      var plus$1 = plus.contents;
      var hash$1 = hash.contents;
      var space$1 = space.contents;
      if (str_ind$1 === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var padty = zero$1 ? (
          minus$1 ? (
              legacy_behavior$1 ? /* Left */0 : incompatible_flag(pct_ind, str_ind$1, /* "-" */45, "0")
            ) : /* Zeros */2
        ) : (
          minus$1 ? /* Left */0 : /* Right */1
        );
      var match$1 = caml_string.get(str, str_ind$1);
      if (match$1 >= 48) {
        if (match$1 < 58) {
          var match$2 = parse_positive(str_ind$1, end_ind, 0);
          return parse_after_padding(pct_ind, match$2[0], end_ind, minus$1, plus$1, hash$1, space$1, ign, {
                      TAG: /* Lit_padding */0,
                      _0: padty,
                      _1: match$2[1]
                    });
        }
        
      } else if (match$1 === 42) {
        return parse_after_padding(pct_ind, str_ind$1 + 1 | 0, end_ind, minus$1, plus$1, hash$1, space$1, ign, {
                    TAG: /* Arg_padding */1,
                    _0: padty
                  });
      }
      switch (padty) {
        case /* Left */0 :
            if (!legacy_behavior$1) {
              invalid_format_without(str_ind$1 - 1 | 0, /* "-" */45, "padding");
            }
            return parse_after_padding(pct_ind, str_ind$1, end_ind, minus$1, plus$1, hash$1, space$1, ign, /* No_padding */0);
        case /* Right */1 :
            return parse_after_padding(pct_ind, str_ind$1, end_ind, minus$1, plus$1, hash$1, space$1, ign, /* No_padding */0);
        case /* Zeros */2 :
            return parse_after_padding(pct_ind, str_ind$1, end_ind, minus$1, plus$1, hash$1, space$1, ign, {
                        TAG: /* Lit_padding */0,
                        _0: /* Right */1,
                        _1: 0
                      });
        
      }
    }  };
  var parse_conversion = function (pct_ind, str_ind, end_ind, plus, hash, space, ign, pad, prec, padprec, symb) {
    var plus_used = false;
    var hash_used = false;
    var space_used = false;
    var ign_used = {
      contents: false
    };
    var pad_used = {
      contents: false
    };
    var prec_used = {
      contents: false
    };
    var get_int_pad = function (param) {
      pad_used.contents = true;
      prec_used.contents = true;
      if (typeof prec === "number" && prec === 0) {
        return pad;
      }
      if (typeof pad === "number") {
        return /* No_padding */0;
      } else if (pad.TAG === /* Lit_padding */0) {
        if (pad._0 >= 2) {
          if (legacy_behavior$1) {
            return {
                    TAG: /* Lit_padding */0,
                    _0: /* Right */1,
                    _1: pad._1
                  };
          } else {
            return incompatible_flag(pct_ind, str_ind, /* "0" */48, "precision");
          }
        } else {
          return pad;
        }
      } else if (pad._0 >= 2) {
        if (legacy_behavior$1) {
          return {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                };
        } else {
          return incompatible_flag(pct_ind, str_ind, /* "0" */48, "precision");
        }
      } else {
        return pad;
      }
    };
    var check_no_0 = function (symb, pad) {
      if (typeof pad === "number") {
        return pad;
      } else if (pad.TAG === /* Lit_padding */0) {
        if (pad._0 >= 2) {
          if (legacy_behavior$1) {
            return {
                    TAG: /* Lit_padding */0,
                    _0: /* Right */1,
                    _1: pad._1
                  };
          } else {
            return incompatible_flag(pct_ind, str_ind, symb, "0");
          }
        } else {
          return pad;
        }
      } else if (pad._0 >= 2) {
        if (legacy_behavior$1) {
          return {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                };
        } else {
          return incompatible_flag(pct_ind, str_ind, symb, "0");
        }
      } else {
        return pad;
      }
    };
    var opt_of_pad = function (c, pad) {
      if (typeof pad === "number") {
        return ;
      }
      if (pad.TAG !== /* Lit_padding */0) {
        return incompatible_flag(pct_ind, str_ind, c, "'*'");
      }
      switch (pad._0) {
        case /* Left */0 :
            if (legacy_behavior$1) {
              return pad._1;
            } else {
              return incompatible_flag(pct_ind, str_ind, c, "'-'");
            }
        case /* Right */1 :
            return pad._1;
        case /* Zeros */2 :
            if (legacy_behavior$1) {
              return pad._1;
            } else {
              return incompatible_flag(pct_ind, str_ind, c, "'0'");
            }
        
      }
    };
    var get_prec_opt = function (param) {
      prec_used.contents = true;
      if (typeof prec === "number") {
        if (prec !== 0) {
          return incompatible_flag(pct_ind, str_ind, /* "_" */95, "'*'");
        } else {
          return ;
        }
      } else {
        return prec._0;
      }
    };
    var fmt_result;
    var exit = 0;
    var exit$1 = 0;
    var exit$2 = 0;
    if (symb >= 124) {
      exit$1 = 6;
    } else {
      switch (symb) {
        case 33 :
            var fmt_rest = parse_literal(str_ind, str_ind, end_ind);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Flush */10,
                _0: fmt_rest._0
              }
            };
            break;
        case 40 :
            var sub_end = search_subformat_end(str_ind, end_ind, /* ")" */41);
            var beg_ind = sub_end + 2 | 0;
            var fmt_rest$1 = parse_literal(beg_ind, beg_ind, end_ind);
            var fmt_rest$2 = fmt_rest$1._0;
            var sub_fmt = parse_literal(str_ind, str_ind, sub_end);
            var sub_fmtty = fmtty_of_fmt(sub_fmt._0);
            if (ign_used.contents = true, ign) {
              var ignored_0 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
              var ignored = {
                TAG: /* Ignored_format_subst */9,
                _0: ignored_0,
                _1: sub_fmtty
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored,
                  _1: fmt_rest$2
                }
              };
            } else {
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Format_subst */14,
                  _0: opt_of_pad(/* "(" */40, (pad_used.contents = true, pad)),
                  _1: sub_fmtty,
                  _2: fmt_rest$2
                }
              };
            }
            break;
        case 44 :
            fmt_result = parse_literal(str_ind, str_ind, end_ind);
            break;
        case 37 :
        case 64 :
            exit$1 = 4;
            break;
        case 67 :
            var fmt_rest$3 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$4 = fmt_rest$3._0;
            fmt_result = (ign_used.contents = true, ign) ? /* Fmt_EBB */({
                  _0: {
                    TAG: /* Ignored_param */23,
                    _0: /* Ignored_caml_char */1,
                    _1: fmt_rest$4
                  }
                }) : /* Fmt_EBB */({
                  _0: {
                    TAG: /* Caml_char */1,
                    _0: fmt_rest$4
                  }
                });
            break;
        case 78 :
            var fmt_rest$5 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$6 = fmt_rest$5._0;
            if (ign_used.contents = true, ign) {
              var ignored$1 = {
                TAG: /* Ignored_scan_get_counter */11,
                _0: /* Token_counter */2
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$1,
                  _1: fmt_rest$6
                }
              };
            } else {
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Scan_get_counter */21,
                  _0: /* Token_counter */2,
                  _1: fmt_rest$6
                }
              };
            }
            break;
        case 83 :
            var pad$1 = check_no_0(symb, (pad_used.contents = true, padprec));
            var fmt_rest$7 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$8 = fmt_rest$7._0;
            if (ign_used.contents = true, ign) {
              var ignored$2 = {
                TAG: /* Ignored_caml_string */1,
                _0: opt_of_pad(/* "_" */95, (pad_used.contents = true, padprec))
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$2,
                  _1: fmt_rest$8
                }
              };
            } else {
              var match = make_padding_fmt_ebb(pad$1, fmt_rest$8);
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Caml_string */3,
                  _0: match._0,
                  _1: match._1
                }
              };
            }
            break;
        case 91 :
            var match$1 = parse_char_set(str_ind, end_ind);
            var char_set = match$1[1];
            var next_ind = match$1[0];
            var fmt_rest$9 = parse_literal(next_ind, next_ind, end_ind);
            var fmt_rest$10 = fmt_rest$9._0;
            if (ign_used.contents = true, ign) {
              var ignored_0$1 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
              var ignored$3 = {
                TAG: /* Ignored_scan_char_set */10,
                _0: ignored_0$1,
                _1: char_set
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$3,
                  _1: fmt_rest$10
                }
              };
            } else {
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Scan_char_set */20,
                  _0: opt_of_pad(/* "[" */91, (pad_used.contents = true, pad)),
                  _1: char_set,
                  _2: fmt_rest$10
                }
              };
            }
            break;
        case 32 :
        case 35 :
        case 43 :
        case 45 :
        case 95 :
            exit$1 = 5;
            break;
        case 97 :
            var fmt_rest$11 = parse_literal(str_ind, str_ind, end_ind);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Alpha */15,
                _0: fmt_rest$11._0
              }
            };
            break;
        case 66 :
        case 98 :
            exit$1 = 3;
            break;
        case 99 :
            var char_format = function (fmt_rest) {
              if (ign_used.contents = true, ign) {
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Ignored_param */23,
                          _0: /* Ignored_char */0,
                          _1: fmt_rest
                        }
                      };
              } else {
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Char */0,
                          _0: fmt_rest
                        }
                      };
              }
            };
            var scan_format = function (fmt_rest) {
              if (ign_used.contents = true, ign) {
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Ignored_param */23,
                          _0: /* Ignored_scan_next_char */3,
                          _1: fmt_rest
                        }
                      };
              } else {
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Scan_next_char */22,
                          _0: fmt_rest
                        }
                      };
              }
            };
            var fmt_rest$12 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$13 = fmt_rest$12._0;
            var _n = opt_of_pad(/* "c" */99, (pad_used.contents = true, pad));
            fmt_result = _n !== undefined ? (
                _n !== 0 ? (
                    legacy_behavior$1 ? char_format(fmt_rest$13) : invalid_format_message(str_ind, "non-zero widths are unsupported for %c conversions")
                  ) : scan_format(fmt_rest$13)
              ) : char_format(fmt_rest$13);
            break;
        case 69 :
        case 70 :
        case 71 :
        case 72 :
        case 101 :
        case 102 :
        case 103 :
        case 104 :
            exit$1 = 2;
            break;
        case 76 :
        case 108 :
        case 110 :
            exit$2 = 8;
            break;
        case 114 :
            var fmt_rest$14 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$15 = fmt_rest$14._0;
            fmt_result = (ign_used.contents = true, ign) ? /* Fmt_EBB */({
                  _0: {
                    TAG: /* Ignored_param */23,
                    _0: /* Ignored_reader */2,
                    _1: fmt_rest$15
                  }
                }) : /* Fmt_EBB */({
                  _0: {
                    TAG: /* Reader */19,
                    _0: fmt_rest$15
                  }
                });
            break;
        case 115 :
            var pad$2 = check_no_0(symb, (pad_used.contents = true, padprec));
            var fmt_rest$16 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$17 = fmt_rest$16._0;
            if (ign_used.contents = true, ign) {
              var ignored$4 = {
                TAG: /* Ignored_string */0,
                _0: opt_of_pad(/* "_" */95, (pad_used.contents = true, padprec))
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$4,
                  _1: fmt_rest$17
                }
              };
            } else {
              var match$2 = make_padding_fmt_ebb(pad$2, fmt_rest$17);
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* String */2,
                  _0: match$2._0,
                  _1: match$2._1
                }
              };
            }
            break;
        case 116 :
            var fmt_rest$18 = parse_literal(str_ind, str_ind, end_ind);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Theta */16,
                _0: fmt_rest$18._0
              }
            };
            break;
        case 88 :
        case 100 :
        case 105 :
        case 111 :
        case 117 :
        case 120 :
            exit$2 = 7;
            break;
        case 0 :
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
        case 6 :
        case 7 :
        case 8 :
        case 9 :
        case 10 :
        case 11 :
        case 12 :
        case 13 :
        case 14 :
        case 15 :
        case 16 :
        case 17 :
        case 18 :
        case 19 :
        case 20 :
        case 21 :
        case 22 :
        case 23 :
        case 24 :
        case 25 :
        case 26 :
        case 27 :
        case 28 :
        case 29 :
        case 30 :
        case 31 :
        case 34 :
        case 36 :
        case 38 :
        case 39 :
        case 41 :
        case 42 :
        case 46 :
        case 47 :
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
        case 58 :
        case 59 :
        case 60 :
        case 61 :
        case 62 :
        case 63 :
        case 65 :
        case 68 :
        case 73 :
        case 74 :
        case 75 :
        case 77 :
        case 79 :
        case 80 :
        case 81 :
        case 82 :
        case 84 :
        case 85 :
        case 86 :
        case 87 :
        case 89 :
        case 90 :
        case 92 :
        case 93 :
        case 94 :
        case 96 :
        case 106 :
        case 107 :
        case 109 :
        case 112 :
        case 113 :
        case 118 :
        case 119 :
        case 121 :
        case 122 :
            exit$1 = 6;
            break;
        case 123 :
            var sub_end$1 = search_subformat_end(str_ind, end_ind, /* "}" */125);
            var sub_fmt$1 = parse_literal(str_ind, str_ind, sub_end$1);
            var beg_ind$1 = sub_end$1 + 2 | 0;
            var fmt_rest$19 = parse_literal(beg_ind$1, beg_ind$1, end_ind);
            var fmt_rest$20 = fmt_rest$19._0;
            var sub_fmtty$1 = fmtty_of_fmt(sub_fmt$1._0);
            if (ign_used.contents = true, ign) {
              var ignored_0$2 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
              var ignored$5 = {
                TAG: /* Ignored_format_arg */8,
                _0: ignored_0$2,
                _1: sub_fmtty$1
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$5,
                  _1: fmt_rest$20
                }
              };
            } else {
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Format_arg */13,
                  _0: opt_of_pad(/* "{" */123, (pad_used.contents = true, pad)),
                  _1: sub_fmtty$1,
                  _2: fmt_rest$20
                }
              };
            }
            break;
        
      }
    }
    switch (exit$2) {
      case 7 :
          plus_used = true;
          hash_used = true;
          space_used = true;
          var iconv = compute_int_conv(pct_ind, str_ind, plus, hash, space, symb);
          var fmt_rest$21 = parse_literal(str_ind, str_ind, end_ind);
          var fmt_rest$22 = fmt_rest$21._0;
          if (ign_used.contents = true, ign) {
            var ignored_1 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
            var ignored$6 = {
              TAG: /* Ignored_int */2,
              _0: iconv,
              _1: ignored_1
            };
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Ignored_param */23,
                _0: ignored$6,
                _1: fmt_rest$22
              }
            };
          } else {
            var match$3 = make_padprec_fmt_ebb(get_int_pad(), (prec_used.contents = true, prec), fmt_rest$22);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Int */4,
                _0: iconv,
                _1: match$3._0,
                _2: match$3._1,
                _3: match$3._2
              }
            };
          }
          break;
      case 8 :
          if (str_ind === end_ind || !is_int_base(caml_string.get(str, str_ind))) {
            var fmt_rest$23 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$24 = fmt_rest$23._0;
            var counter = counter_of_char(symb);
            if (ign_used.contents = true, ign) {
              var ignored$7 = {
                TAG: /* Ignored_scan_get_counter */11,
                _0: counter
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$7,
                  _1: fmt_rest$24
                }
              };
            } else {
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Scan_get_counter */21,
                  _0: counter,
                  _1: fmt_rest$24
                }
              };
            }
          } else {
            exit$1 = 6;
          }
          break;
      
    }
    switch (exit$1) {
      case 2 :
          plus_used = true;
          space_used = true;
          var fconv = compute_float_conv(pct_ind, str_ind, plus, space, symb);
          var fmt_rest$25 = parse_literal(str_ind, str_ind, end_ind);
          var fmt_rest$26 = fmt_rest$25._0;
          if (ign_used.contents = true, ign) {
            var ignored_0$3 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
            var ignored_1$1 = get_prec_opt();
            var ignored$8 = {
              TAG: /* Ignored_float */6,
              _0: ignored_0$3,
              _1: ignored_1$1
            };
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Ignored_param */23,
                _0: ignored$8,
                _1: fmt_rest$26
              }
            };
          } else {
            var match$4 = make_padprec_fmt_ebb((pad_used.contents = true, pad), (prec_used.contents = true, prec), fmt_rest$26);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Float */8,
                _0: fconv,
                _1: match$4._0,
                _2: match$4._1,
                _3: match$4._2
              }
            };
          }
          break;
      case 3 :
          var pad$3 = check_no_0(symb, (pad_used.contents = true, padprec));
          var fmt_rest$27 = parse_literal(str_ind, str_ind, end_ind);
          var fmt_rest$28 = fmt_rest$27._0;
          if (ign_used.contents = true, ign) {
            var ignored$9 = {
              TAG: /* Ignored_bool */7,
              _0: opt_of_pad(/* "_" */95, (pad_used.contents = true, padprec))
            };
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Ignored_param */23,
                _0: ignored$9,
                _1: fmt_rest$28
              }
            };
          } else {
            var match$5 = make_padding_fmt_ebb(pad$3, fmt_rest$28);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Bool */9,
                _0: match$5._0,
                _1: match$5._1
              }
            };
          }
          break;
      case 4 :
          var fmt_rest$29 = parse_literal(str_ind, str_ind, end_ind);
          fmt_result = /* Fmt_EBB */{
            _0: {
              TAG: /* Char_literal */12,
              _0: symb,
              _1: fmt_rest$29._0
            }
          };
          break;
      case 5 :
          fmt_result = curry._3(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid format ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": at character number ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: ", flag ",
                              _1: {
                                TAG: /* Caml_char */1,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " is only allowed after the '",
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* "%" */37,
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: "', before padding and precision",
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"
                  }), str, pct_ind, symb);
          break;
      case 6 :
          if (symb >= 108) {
            if (symb >= 111) {
              exit = 1;
            } else {
              switch (symb - 108 | 0) {
                case 0 :
                    plus_used = true;
                    hash_used = true;
                    space_used = true;
                    var iconv$1 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, caml_string.get(str, str_ind));
                    var beg_ind$2 = str_ind + 1 | 0;
                    var fmt_rest$30 = parse_literal(beg_ind$2, beg_ind$2, end_ind);
                    var fmt_rest$31 = fmt_rest$30._0;
                    if (ign_used.contents = true, ign) {
                      var ignored_1$2 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
                      var ignored$10 = {
                        TAG: /* Ignored_int32 */3,
                        _0: iconv$1,
                        _1: ignored_1$2
                      };
                      fmt_result = /* Fmt_EBB */{
                        _0: {
                          TAG: /* Ignored_param */23,
                          _0: ignored$10,
                          _1: fmt_rest$31
                        }
                      };
                    } else {
                      var match$6 = make_padprec_fmt_ebb(get_int_pad(), (prec_used.contents = true, prec), fmt_rest$31);
                      fmt_result = /* Fmt_EBB */{
                        _0: {
                          TAG: /* Int32 */5,
                          _0: iconv$1,
                          _1: match$6._0,
                          _2: match$6._1,
                          _3: match$6._2
                        }
                      };
                    }
                    break;
                case 1 :
                    exit = 1;
                    break;
                case 2 :
                    plus_used = true;
                    hash_used = true;
                    space_used = true;
                    var iconv$2 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, caml_string.get(str, str_ind));
                    var beg_ind$3 = str_ind + 1 | 0;
                    var fmt_rest$32 = parse_literal(beg_ind$3, beg_ind$3, end_ind);
                    var fmt_rest$33 = fmt_rest$32._0;
                    if (ign_used.contents = true, ign) {
                      var ignored_1$3 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
                      var ignored$11 = {
                        TAG: /* Ignored_nativeint */4,
                        _0: iconv$2,
                        _1: ignored_1$3
                      };
                      fmt_result = /* Fmt_EBB */{
                        _0: {
                          TAG: /* Ignored_param */23,
                          _0: ignored$11,
                          _1: fmt_rest$33
                        }
                      };
                    } else {
                      var match$7 = make_padprec_fmt_ebb(get_int_pad(), (prec_used.contents = true, prec), fmt_rest$33);
                      fmt_result = /* Fmt_EBB */{
                        _0: {
                          TAG: /* Nativeint */6,
                          _0: iconv$2,
                          _1: match$7._0,
                          _2: match$7._1,
                          _3: match$7._2
                        }
                      };
                    }
                    break;
                
              }
            }
          } else if (symb !== 76) {
            exit = 1;
          } else {
            plus_used = true;
            hash_used = true;
            space_used = true;
            var iconv$3 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, caml_string.get(str, str_ind));
            var beg_ind$4 = str_ind + 1 | 0;
            var fmt_rest$34 = parse_literal(beg_ind$4, beg_ind$4, end_ind);
            var fmt_rest$35 = fmt_rest$34._0;
            if (ign_used.contents = true, ign) {
              var ignored_1$4 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
              var ignored$12 = {
                TAG: /* Ignored_int64 */5,
                _0: iconv$3,
                _1: ignored_1$4
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$12,
                  _1: fmt_rest$35
                }
              };
            } else {
              var match$8 = make_padprec_fmt_ebb(get_int_pad(), (prec_used.contents = true, prec), fmt_rest$35);
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Int64 */7,
                  _0: iconv$3,
                  _1: match$8._0,
                  _2: match$8._1,
                  _3: match$8._2
                }
              };
            }
          }
          break;
      
    }
    if (exit === 1) {
      fmt_result = curry._3(failwith_message(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "invalid format ",
                  _1: {
                    TAG: /* Caml_string */3,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ": at character number ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ", invalid conversion \"",
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* "%" */37,
                            _1: {
                              TAG: /* Char */0,
                              _0: {
                                TAG: /* Char_literal */12,
                                _0: /* "\"" */34,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                _1: "invalid format %S: at character number %d, invalid conversion \"%%%c\""
              }), str, str_ind - 1 | 0, symb);
    }
    if (!legacy_behavior$1) {
      if (!plus_used && plus) {
        incompatible_flag(pct_ind, str_ind, symb, "'+'");
      }
      if (!hash_used && hash) {
        incompatible_flag(pct_ind, str_ind, symb, "'#'");
      }
      if (!space_used && space) {
        incompatible_flag(pct_ind, str_ind, symb, "' '");
      }
      if (!pad_used.contents && caml_obj.caml_notequal(/* Padding_EBB */{
              _0: pad
            }, /* Padding_EBB */{
              _0: /* No_padding */0
            })) {
        incompatible_flag(pct_ind, str_ind, symb, "`padding'");
      }
      if (!prec_used.contents && caml_obj.caml_notequal(/* Precision_EBB */{
              _0: prec
            }, /* Precision_EBB */{
              _0: /* No_precision */0
            })) {
        incompatible_flag(pct_ind, str_ind, ign ? /* "_" */95 : symb, "`precision'");
      }
      if (ign && plus) {
        incompatible_flag(pct_ind, str_ind, /* "_" */95, "'+'");
      }
      
    }
    if (!ign_used.contents && ign) {
      var exit$3 = 0;
      if (symb >= 38) {
        if (symb !== 44) {
          if (symb !== 64 || !legacy_behavior$1) {
            exit$3 = 1;
          }
          
        } else if (!legacy_behavior$1) {
          exit$3 = 1;
        }
        
      } else if (symb !== 33) {
        if (!(symb >= 37 && legacy_behavior$1)) {
          exit$3 = 1;
        }
        
      } else if (!legacy_behavior$1) {
        exit$3 = 1;
      }
      if (exit$3 === 1) {
        incompatible_flag(pct_ind, str_ind, symb, "'_'");
      }
      
    }
    return fmt_result;
  };
  var parse_tag = function (is_open_tag, str_ind, end_ind) {
    try {
      if (str_ind === end_ind) {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      var match = caml_string.get(str, str_ind);
      if (match !== 60) {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      var ind = string.index_from(str, str_ind + 1 | 0, /* ">" */62);
      if (ind >= end_ind) {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      var sub_str = string.sub(str, str_ind, (ind - str_ind | 0) + 1 | 0);
      var beg_ind = ind + 1 | 0;
      var fmt_rest = parse_literal(beg_ind, beg_ind, end_ind);
      var sub_fmt = parse_literal(str_ind, str_ind, ind + 1 | 0);
      var sub_fmt$1 = sub_fmt._0;
      var sub_format = /* Format */{
        _0: sub_fmt$1,
        _1: sub_str
      };
      var formatting = is_open_tag ? ({
            TAG: /* Open_tag */0,
            _0: sub_format
          }) : (check_open_box(sub_fmt$1), {
            TAG: /* Open_box */1,
            _0: sub_format
          });
      return /* Fmt_EBB */{
              _0: {
                TAG: /* Formatting_gen */18,
                _0: formatting,
                _1: fmt_rest._0
              }
            };
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        var fmt_rest$1 = parse_literal(str_ind, str_ind, end_ind);
        var sub_format$1 = /* Format */{
          _0: /* End_of_format */0,
          _1: ""
        };
        var formatting$1 = is_open_tag ? ({
              TAG: /* Open_tag */0,
              _0: sub_format$1
            }) : ({
              TAG: /* Open_box */1,
              _0: sub_format$1
            });
        return /* Fmt_EBB */{
                _0: {
                  TAG: /* Formatting_gen */18,
                  _0: formatting$1,
                  _1: fmt_rest$1._0
                }
              };
      }
      throw exn;
    }
  };
  var compute_float_conv = function (pct_ind, str_ind, _plus, _space, symb) {
    while(true) {
      var space = _space;
      var plus = _plus;
      if (plus) {
        if (space) {
          if (!legacy_behavior$1) {
            return incompatible_flag(pct_ind, str_ind, /* " " */32, "'+'");
          }
          _space = false;
          continue ;
        }
        if (symb >= 73) {
          switch (symb) {
            case 101 :
                return /* Float_pe */4;
            case 102 :
                return /* Float_pf */1;
            case 103 :
                return /* Float_pg */10;
            case 104 :
                return /* Float_ph */17;
              
          }
        } else if (symb >= 69) {
          switch (symb - 69 | 0) {
            case 0 :
                return /* Float_pE */7;
            case 1 :
                break;
            case 2 :
                return /* Float_pG */13;
            case 3 :
                return /* Float_pH */20;
            
          }
        }
        if (!legacy_behavior$1) {
          return incompatible_flag(pct_ind, str_ind, symb, "'+'");
        }
        _plus = false;
        continue ;
      }
      if (space) {
        if (symb >= 73) {
          switch (symb) {
            case 101 :
                return /* Float_se */5;
            case 102 :
                return /* Float_sf */2;
            case 103 :
                return /* Float_sg */11;
            case 104 :
                return /* Float_sh */18;
              
          }
        } else if (symb >= 69) {
          switch (symb - 69 | 0) {
            case 0 :
                return /* Float_sE */8;
            case 1 :
                break;
            case 2 :
                return /* Float_sG */14;
            case 3 :
                return /* Float_sH */21;
            
          }
        }
        if (!legacy_behavior$1) {
          return incompatible_flag(pct_ind, str_ind, symb, "' '");
        }
        _space = false;
        continue ;
      }
      if (symb >= 73) {
        switch (symb) {
          case 101 :
              return /* Float_e */3;
          case 102 :
              return /* Float_f */0;
          case 103 :
              return /* Float_g */9;
          case 104 :
              return /* Float_h */16;
          default:
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.ml",
                    2943,
                    25
                  ],
                  Error: new Error()
                };
        }
      } else if (symb >= 69) {
        switch (symb - 69 | 0) {
          case 0 :
              return /* Float_E */6;
          case 1 :
              return /* Float_F */15;
          case 2 :
              return /* Float_G */12;
          case 3 :
              return /* Float_H */19;
          
        }
      } else {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.ml",
                2943,
                25
              ],
              Error: new Error()
            };
      }
    }  };
  var parse_format = function (pct_ind, end_ind) {
    var str_ind = pct_ind + 1 | 0;
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var match = caml_string.get(str, str_ind);
    if (match !== 95) {
      return parse_flags(pct_ind, str_ind, end_ind, false);
    } else {
      return parse_flags(pct_ind, str_ind + 1 | 0, end_ind, true);
    }
  };
  var parse_after_at = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      return /* Fmt_EBB */{
              _0: {
                TAG: /* Char_literal */12,
                _0: /* "@" */64,
                _1: /* End_of_format */0
              }
            };
    }
    var c = caml_string.get(str, str_ind);
    if (c >= 65) {
      if (c >= 94) {
        switch (c) {
          case 123 :
              return parse_tag(true, str_ind + 1 | 0, end_ind);
          case 124 :
              break;
          case 125 :
              var beg_ind = str_ind + 1 | 0;
              var fmt_rest = parse_literal(beg_ind, beg_ind, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Close_tag */1,
                        _1: fmt_rest._0
                      }
                    };
            
        }
      } else if (c >= 91) {
        switch (c - 91 | 0) {
          case 0 :
              return parse_tag(false, str_ind + 1 | 0, end_ind);
          case 1 :
              break;
          case 2 :
              var beg_ind$1 = str_ind + 1 | 0;
              var fmt_rest$1 = parse_literal(beg_ind$1, beg_ind$1, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Close_box */0,
                        _1: fmt_rest$1._0
                      }
                    };
          
        }
      }
      
    } else if (c !== 10) {
      if (c >= 32) {
        switch (c - 32 | 0) {
          case 0 :
              var beg_ind$2 = str_ind + 1 | 0;
              var fmt_rest$2 = parse_literal(beg_ind$2, beg_ind$2, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: fmt_rest$2._0
                      }
                    };
          case 5 :
              if ((str_ind + 1 | 0) < end_ind && caml_string.get(str, str_ind + 1 | 0) === /* "%" */37) {
                var beg_ind$3 = str_ind + 2 | 0;
                var fmt_rest$3 = parse_literal(beg_ind$3, beg_ind$3, end_ind);
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Escaped_percent */6,
                          _1: fmt_rest$3._0
                        }
                      };
              }
              var fmt_rest$4 = parse_literal(str_ind, str_ind, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Char_literal */12,
                        _0: /* "@" */64,
                        _1: fmt_rest$4._0
                      }
                    };
          case 12 :
              var beg_ind$4 = str_ind + 1 | 0;
              var fmt_rest$5 = parse_literal(beg_ind$4, beg_ind$4, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@,",
                          _1: 0,
                          _2: 0
                        },
                        _1: fmt_rest$5._0
                      }
                    };
          case 14 :
              var beg_ind$5 = str_ind + 1 | 0;
              var fmt_rest$6 = parse_literal(beg_ind$5, beg_ind$5, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Flush_newline */4,
                        _1: fmt_rest$6._0
                      }
                    };
          case 27 :
              var str_ind$1 = str_ind + 1 | 0;
              var match;
              try {
                if (str_ind$1 === end_ind || caml_string.get(str, str_ind$1) !== /* "<" */60) {
                  throw {
                        RE_EXN_ID: "Not_found",
                        Error: new Error()
                      };
                }
                var str_ind_1 = parse_spaces(str_ind$1 + 1 | 0, end_ind);
                var match$1 = caml_string.get(str, str_ind_1);
                var exit = 0;
                if (match$1 >= 48) {
                  if (match$1 >= 58) {
                    throw {
                          RE_EXN_ID: "Not_found",
                          Error: new Error()
                        };
                  }
                  exit = 1;
                } else {
                  if (match$1 !== 45) {
                    throw {
                          RE_EXN_ID: "Not_found",
                          Error: new Error()
                        };
                  }
                  exit = 1;
                }
                if (exit === 1) {
                  var match$2 = parse_integer(str_ind_1, end_ind);
                  var width = match$2[1];
                  var str_ind_3 = parse_spaces(match$2[0], end_ind);
                  var match$3 = caml_string.get(str, str_ind_3);
                  var switcher = match$3 - 45 | 0;
                  if (switcher > 12 || switcher < 0) {
                    if (switcher !== 17) {
                      throw {
                            RE_EXN_ID: "Not_found",
                            Error: new Error()
                          };
                    }
                    var s = string.sub(str, str_ind$1 - 2 | 0, (str_ind_3 - str_ind$1 | 0) + 3 | 0);
                    match = [
                      str_ind_3 + 1 | 0,
                      {
                        TAG: /* Break */0,
                        _0: s,
                        _1: width,
                        _2: 0
                      }
                    ];
                  } else {
                    if (switcher === 2 || switcher === 1) {
                      throw {
                            RE_EXN_ID: "Not_found",
                            Error: new Error()
                          };
                    }
                    var match$4 = parse_integer(str_ind_3, end_ind);
                    var str_ind_5 = parse_spaces(match$4[0], end_ind);
                    if (caml_string.get(str, str_ind_5) !== /* ">" */62) {
                      throw {
                            RE_EXN_ID: "Not_found",
                            Error: new Error()
                          };
                    }
                    var s$1 = string.sub(str, str_ind$1 - 2 | 0, (str_ind_5 - str_ind$1 | 0) + 3 | 0);
                    match = [
                      str_ind_5 + 1 | 0,
                      {
                        TAG: /* Break */0,
                        _0: s$1,
                        _1: width,
                        _2: match$4[1]
                      }
                    ];
                  }
                }
                
              }
              catch (raw_exn){
                var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.RE_EXN_ID === "Not_found" || exn.RE_EXN_ID === "Failure") {
                  match = [
                    str_ind$1,
                    {
                      TAG: /* Break */0,
                      _0: "@;",
                      _1: 1,
                      _2: 0
                    }
                  ];
                } else {
                  throw exn;
                }
              }
              var next_ind = match[0];
              var fmt_rest$7 = parse_literal(next_ind, next_ind, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: match[1],
                        _1: fmt_rest$7._0
                      }
                    };
          case 28 :
              var str_ind$2 = str_ind + 1 | 0;
              var match$5;
              try {
                var str_ind_1$1 = parse_spaces(str_ind$2, end_ind);
                var match$6 = caml_string.get(str, str_ind_1$1);
                var exit$1 = 0;
                if (match$6 >= 48) {
                  if (match$6 >= 58) {
                    match$5 = undefined;
                  } else {
                    exit$1 = 1;
                  }
                } else if (match$6 !== 45) {
                  match$5 = undefined;
                } else {
                  exit$1 = 1;
                }
                if (exit$1 === 1) {
                  var match$7 = parse_integer(str_ind_1$1, end_ind);
                  var str_ind_3$1 = parse_spaces(match$7[0], end_ind);
                  if (caml_string.get(str, str_ind_3$1) !== /* ">" */62) {
                    throw {
                          RE_EXN_ID: "Not_found",
                          Error: new Error()
                        };
                  }
                  var s$2 = string.sub(str, str_ind$2 - 2 | 0, (str_ind_3$1 - str_ind$2 | 0) + 3 | 0);
                  match$5 = [
                    str_ind_3$1 + 1 | 0,
                    {
                      TAG: /* Magic_size */1,
                      _0: s$2,
                      _1: match$7[1]
                    }
                  ];
                }
                
              }
              catch (raw_exn$1){
                var exn$1 = caml_js_exceptions.internalToOCamlException(raw_exn$1);
                if (exn$1.RE_EXN_ID === "Not_found" || exn$1.RE_EXN_ID === "Failure") {
                  match$5 = undefined;
                } else {
                  throw exn$1;
                }
              }
              if (match$5 !== undefined) {
                var next_ind$1 = match$5[0];
                var fmt_rest$8 = parse_literal(next_ind$1, next_ind$1, end_ind);
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: match$5[1],
                          _1: fmt_rest$8._0
                        }
                      };
              }
              var fmt_rest$9 = parse_literal(str_ind$2, str_ind$2, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Scan_indic */2,
                          _0: /* "<" */60
                        },
                        _1: fmt_rest$9._0
                      }
                    };
          case 1 :
          case 2 :
          case 3 :
          case 4 :
          case 6 :
          case 7 :
          case 8 :
          case 9 :
          case 10 :
          case 11 :
          case 13 :
          case 15 :
          case 16 :
          case 17 :
          case 18 :
          case 19 :
          case 20 :
          case 21 :
          case 22 :
          case 23 :
          case 24 :
          case 25 :
          case 26 :
          case 29 :
          case 30 :
              break;
          case 31 :
              var beg_ind$6 = str_ind + 1 | 0;
              var fmt_rest$10 = parse_literal(beg_ind$6, beg_ind$6, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* FFlush */2,
                        _1: fmt_rest$10._0
                      }
                    };
          case 32 :
              var beg_ind$7 = str_ind + 1 | 0;
              var fmt_rest$11 = parse_literal(beg_ind$7, beg_ind$7, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Escaped_at */5,
                        _1: fmt_rest$11._0
                      }
                    };
          
        }
      }
      
    } else {
      var beg_ind$8 = str_ind + 1 | 0;
      var fmt_rest$12 = parse_literal(beg_ind$8, beg_ind$8, end_ind);
      return /* Fmt_EBB */{
              _0: {
                TAG: /* Formatting_lit */17,
                _0: /* Force_newline */3,
                _1: fmt_rest$12._0
              }
            };
    }
    var beg_ind$9 = str_ind + 1 | 0;
    var fmt_rest$13 = parse_literal(beg_ind$9, beg_ind$9, end_ind);
    return /* Fmt_EBB */{
            _0: {
              TAG: /* Formatting_lit */17,
              _0: {
                TAG: /* Scan_indic */2,
                _0: c
              },
              _1: fmt_rest$13._0
            }
          };
  };
  var add_literal = function (lit_start, str_ind, fmt) {
    var size = str_ind - lit_start | 0;
    if (size !== 0) {
      if (size !== 1) {
        return /* Fmt_EBB */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: string.sub(str, lit_start, size),
                  _1: fmt
                }
              };
      } else {
        return /* Fmt_EBB */{
                _0: {
                  TAG: /* Char_literal */12,
                  _0: caml_string.get(str, lit_start),
                  _1: fmt
                }
              };
      }
    } else {
      return /* Fmt_EBB */{
              _0: fmt
            };
    }
  };
  var check_open_box = function (fmt) {
    if (typeof fmt === "number") {
      return ;
    }
    if (fmt.TAG !== /* String_literal */11) {
      return ;
    }
    if (typeof fmt._1 !== "number") {
      return ;
    }
    try {
      open_box_of_string(fmt._0);
      return ;
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Failure") {
        return ;
      }
      throw exn;
    }
  };
  var parse_char_set = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var char_set = bytes.make(32, /* "\000" */0);
    var add_range = function (c, c$prime) {
      for(var i = c; i <= c$prime; ++i){
        add_in_char_set(char_set, pervasives.char_of_int(i));
      }
      
    };
    var fail_single_percent = function (str_ind) {
      return curry._2(failwith_message(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "invalid format ",
                        _1: {
                          TAG: /* Caml_string */3,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: ": '",
                            _1: {
                              TAG: /* Char_literal */12,
                              _0: /* "%" */37,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "' alone is not accepted in character sets, use ",
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* "%" */37,
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* "%" */37,
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: " instead at position ",
                                      _1: {
                                        TAG: /* Int */4,
                                        _0: /* Int_d */0,
                                        _1: /* No_padding */0,
                                        _2: /* No_precision */0,
                                        _3: {
                                          TAG: /* Char_literal */12,
                                          _0: /* "." */46,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."
                    }), str, str_ind);
    };
    var parse_char_set_content = function (_str_ind, end_ind) {
      while(true) {
        var str_ind = _str_ind;
        if (str_ind === end_ind) {
          invalid_format_message(end_ind, "unexpected end of format");
        }
        var c = caml_string.get(str, str_ind);
        if (c !== 45) {
          if (c !== 93) {
            return parse_char_set_after_char(str_ind + 1 | 0, end_ind, c);
          } else {
            return str_ind + 1 | 0;
          }
        }
        add_in_char_set(char_set, /* "-" */45);
        _str_ind = str_ind + 1 | 0;
        continue ;
      }    };
    var parse_char_set_after_char = function (_str_ind, end_ind, _c) {
      while(true) {
        var c = _c;
        var str_ind = _str_ind;
        if (str_ind === end_ind) {
          invalid_format_message(end_ind, "unexpected end of format");
        }
        var c$prime = caml_string.get(str, str_ind);
        var exit = 0;
        if (c$prime >= 46) {
          if (c$prime !== 64) {
            if (c$prime === 93) {
              add_in_char_set(char_set, c);
              return str_ind + 1 | 0;
            }
            
          } else {
            exit = 2;
          }
        } else if (c$prime !== 37) {
          if (c$prime >= 45) {
            var str_ind$1 = str_ind + 1 | 0;
            if (str_ind$1 === end_ind) {
              invalid_format_message(end_ind, "unexpected end of format");
            }
            var c$prime$1 = caml_string.get(str, str_ind$1);
            if (c$prime$1 !== 37) {
              if (c$prime$1 !== 93) {
                add_range(c, c$prime$1);
                return parse_char_set_content(str_ind$1 + 1 | 0, end_ind);
              } else {
                add_in_char_set(char_set, c);
                add_in_char_set(char_set, /* "-" */45);
                return str_ind$1 + 1 | 0;
              }
            }
            if ((str_ind$1 + 1 | 0) === end_ind) {
              invalid_format_message(end_ind, "unexpected end of format");
            }
            var c$prime$2 = caml_string.get(str, str_ind$1 + 1 | 0);
            if (c$prime$2 !== 37 && c$prime$2 !== 64) {
              return fail_single_percent(str_ind$1);
            }
            add_range(c, c$prime$2);
            return parse_char_set_content(str_ind$1 + 2 | 0, end_ind);
          }
          
        } else {
          exit = 2;
        }
        if (exit === 2 && c === /* "%" */37) {
          add_in_char_set(char_set, c$prime);
          return parse_char_set_content(str_ind + 1 | 0, end_ind);
        }
        if (c === /* "%" */37) {
          fail_single_percent(str_ind);
        }
        add_in_char_set(char_set, c);
        _c = c$prime;
        _str_ind = str_ind + 1 | 0;
        continue ;
      }    };
    var parse_char_set_start = function (str_ind, end_ind) {
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var c = caml_string.get(str, str_ind);
      return parse_char_set_after_char(str_ind + 1 | 0, end_ind, c);
    };
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var match = caml_string.get(str, str_ind);
    var match$1 = match !== 94 ? [
        str_ind,
        false
      ] : [
        str_ind + 1 | 0,
        true
      ];
    var next_ind = parse_char_set_start(match$1[0], end_ind);
    var char_set$1 = bytes.to_string(char_set);
    return [
            next_ind,
            match$1[1] ? rev_char_set(char_set$1) : char_set$1
          ];
  };
  var counter_of_char = function (symb) {
    if (symb >= 108) {
      if (symb < 111) {
        switch (symb - 108 | 0) {
          case 0 :
              return /* Line_counter */0;
          case 1 :
              break;
          case 2 :
              return /* Char_counter */1;
          
        }
      }
      
    } else if (symb === 76) {
      return /* Token_counter */2;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "camlinternalFormat.ml",
            2876,
            34
          ],
          Error: new Error()
        };
  };
  var is_int_base = function (symb) {
    switch (symb) {
      case 89 :
      case 90 :
      case 91 :
      case 92 :
      case 93 :
      case 94 :
      case 95 :
      case 96 :
      case 97 :
      case 98 :
      case 99 :
      case 101 :
      case 102 :
      case 103 :
      case 104 :
      case 106 :
      case 107 :
      case 108 :
      case 109 :
      case 110 :
      case 112 :
      case 113 :
      case 114 :
      case 115 :
      case 116 :
      case 118 :
      case 119 :
          return false;
      case 88 :
      case 100 :
      case 105 :
      case 111 :
      case 117 :
      case 120 :
          return true;
      default:
        return false;
    }
  };
  return parse_literal(0, 0, str.length);
}

function format_of_string_fmtty(str, fmtty) {
  var fmt = fmt_ebb_of_string(undefined, str);
  try {
    return /* Format */{
            _0: type_format(fmt._0, fmtty),
            _1: str
          };
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Type_mismatch) {
      return curry._2(failwith_message(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "bad input: format type mismatch between ",
                        _1: {
                          TAG: /* Caml_string */3,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " and ",
                            _1: {
                              TAG: /* Caml_string */3,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      },
                      _1: "bad input: format type mismatch between %S and %S"
                    }), str, string_of_fmtty(fmtty));
    }
    throw exn;
  }
}

function format_of_string_format(str, param) {
  var fmt = fmt_ebb_of_string(undefined, str);
  try {
    return /* Format */{
            _0: type_format(fmt._0, fmtty_of_fmt(param._0)),
            _1: str
          };
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Type_mismatch) {
      return curry._2(failwith_message(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "bad input: format type mismatch between ",
                        _1: {
                          TAG: /* Caml_string */3,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " and ",
                            _1: {
                              TAG: /* Caml_string */3,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      },
                      _1: "bad input: format type mismatch between %S and %S"
                    }), str, param._1);
    }
    throw exn;
  }
}

var is_in_char_set_1 = is_in_char_set;
var rev_char_set_1 = rev_char_set;
var create_char_set_1 = create_char_set;
var add_in_char_set_1 = add_in_char_set;
var freeze_char_set_1 = freeze_char_set;
var param_format_of_ignored_format_1 = param_format_of_ignored_format;
var make_printf_1 = make_printf;
var make_iprintf_1 = make_iprintf;
var output_acc_1 = output_acc;
var bufput_acc_1 = bufput_acc;
var strput_acc_1 = strput_acc;
var type_format_1 = type_format;
var fmt_ebb_of_string_1 = fmt_ebb_of_string;
var format_of_string_fmtty_1 = format_of_string_fmtty;
var format_of_string_format_1 = format_of_string_format;
var char_of_iconv_1 = char_of_iconv;
var string_of_formatting_lit_1 = string_of_formatting_lit;
var string_of_formatting_gen_1 = string_of_formatting_gen;
var string_of_fmtty_1 = string_of_fmtty;
var string_of_fmt_1 = string_of_fmt;
var open_box_of_string_1 = open_box_of_string;
var symm_1 = symm;
var trans_1 = trans;
var recast_1 = recast;
/* No side effect */

var camlinternalFormat = {
	is_in_char_set: is_in_char_set_1,
	rev_char_set: rev_char_set_1,
	create_char_set: create_char_set_1,
	add_in_char_set: add_in_char_set_1,
	freeze_char_set: freeze_char_set_1,
	param_format_of_ignored_format: param_format_of_ignored_format_1,
	make_printf: make_printf_1,
	make_iprintf: make_iprintf_1,
	output_acc: output_acc_1,
	bufput_acc: bufput_acc_1,
	strput_acc: strput_acc_1,
	type_format: type_format_1,
	fmt_ebb_of_string: fmt_ebb_of_string_1,
	format_of_string_fmtty: format_of_string_fmtty_1,
	format_of_string_format: format_of_string_format_1,
	char_of_iconv: char_of_iconv_1,
	string_of_formatting_lit: string_of_formatting_lit_1,
	string_of_formatting_gen: string_of_formatting_gen_1,
	string_of_fmtty: string_of_fmtty_1,
	string_of_fmt: string_of_fmt_1,
	open_box_of_string: open_box_of_string_1,
	symm: symm_1,
	trans: trans_1,
	recast: recast_1
};

function kfprintf(k, o, param) {
  return camlinternalFormat.make_printf((function (o, acc) {
                camlinternalFormat.output_acc(o, acc);
                return curry._1(k, o);
              }), o, /* End_of_acc */0, param._0);
}

function kbprintf(k, b, param) {
  return camlinternalFormat.make_printf((function (b, acc) {
                camlinternalFormat.bufput_acc(b, acc);
                return curry._1(k, b);
              }), b, /* End_of_acc */0, param._0);
}

function ikfprintf(k, oc, param) {
  return camlinternalFormat.make_iprintf(k, oc, param._0);
}

function fprintf(oc, fmt) {
  return kfprintf((function (prim) {
                
              }), oc, fmt);
}

function bprintf(b, fmt) {
  return kbprintf((function (prim) {
                
              }), b, fmt);
}

function ifprintf(oc, fmt) {
  return ikfprintf((function (prim) {
                
              }), oc, fmt);
}

function printf(fmt) {
  return fprintf(pervasives.stdout, fmt);
}

function eprintf(fmt) {
  return fprintf(pervasives.stderr, fmt);
}

function ksprintf(k, param) {
  var k$prime = function (param, acc) {
    var buf = buffer.create(64);
    camlinternalFormat.strput_acc(buf, acc);
    return curry._1(k, buffer.contents(buf));
  };
  return camlinternalFormat.make_printf(k$prime, undefined, /* End_of_acc */0, param._0);
}

function sprintf(fmt) {
  return ksprintf((function (s) {
                return s;
              }), fmt);
}

var kprintf = ksprintf;

var fprintf_1 = fprintf;
var printf_2 = printf;
var eprintf_1 = eprintf;
var sprintf_1 = sprintf;
var bprintf_1 = bprintf;
var ifprintf_1 = ifprintf;
var kfprintf_1 = kfprintf;
var ikfprintf_1 = ikfprintf;
var ksprintf_1 = ksprintf;
var kbprintf_1 = kbprintf;
var kprintf_1 = kprintf;
/* No side effect */

var printf_1 = {
	fprintf: fprintf_1,
	printf: printf_2,
	eprintf: eprintf_1,
	sprintf: sprintf_1,
	bprintf: bprintf_1,
	ifprintf: ifprintf_1,
	kfprintf: kfprintf_1,
	ikfprintf: ikfprintf_1,
	ksprintf: ksprintf_1,
	kbprintf: kbprintf_1,
	kprintf: kprintf_1
};

var $$Error$1 = caml_exceptions.create("Parse_error.Error");

function error(loc, e) {
  throw {
        RE_EXN_ID: $$Error$1,
        _1: {
          hd: [
            loc,
            e
          ],
          tl: /* [] */0
        },
        Error: new Error()
      };
}

function error$1(str) {
  if (typeof str === "number") {
    switch (str) {
      case /* UnexpectedNumber */0 :
          return "Unexpected number";
      case /* UnexpectedString */1 :
          return "Unexpected string";
      case /* UnexpectedIdentifier */2 :
          return "Unexpected identifier";
      case /* UnexpectedReserved */3 :
          return "Unexpected reserved word";
      case /* UnexpectedEOS */4 :
          return "Unexpected end of input";
      case /* UnexpectedVariance */5 :
          return "Unexpected variance sigil";
      case /* UnexpectedTypeAlias */6 :
          return "Type aliases are not allowed in untyped mode";
      case /* UnexpectedTypeAnnotation */7 :
          return "Type annotations are not allowed in untyped mode";
      case /* UnexpectedTypeDeclaration */8 :
          return "Type declarations are not allowed in untyped mode";
      case /* UnexpectedTypeImport */9 :
          return "Type imports are not allowed in untyped mode";
      case /* UnexpectedTypeExport */10 :
          return "Type exports are not allowed in untyped mode";
      case /* UnexpectedTypeInterface */11 :
          return "Interfaces are not allowed in untyped mode";
      case /* NewlineAfterThrow */12 :
          return "Illegal newline after throw";
      case /* InvalidRegExp */13 :
          return "Invalid regular expression";
      case /* UnterminatedRegExp */14 :
          return "Invalid regular expression: missing /";
      case /* InvalidLHSInAssignment */15 :
          return "Invalid left-hand side in assignment";
      case /* InvalidLHSInExponentiation */16 :
          return "Invalid left-hand side in exponentiation expression";
      case /* InvalidLHSInForIn */17 :
          return "Invalid left-hand side in for-in";
      case /* InvalidLHSInForOf */18 :
          return "Invalid left-hand side in for-of";
      case /* ExpectedPatternFoundExpression */19 :
          return "Expected an object pattern, array pattern, or an identifier but found an expression instead";
      case /* MultipleDefaultsInSwitch */20 :
          return "More than one default clause in switch statement";
      case /* NoCatchOrFinally */21 :
          return "Missing catch or finally after try";
      case /* IllegalContinue */22 :
          return "Illegal continue statement";
      case /* IllegalBreak */23 :
          return "Illegal break statement";
      case /* IllegalReturn */24 :
          return "Illegal return statement";
      case /* IllegalYield */25 :
          return "Illegal yield expression";
      case /* StrictModeWith */26 :
          return "Strict mode code may not include a with statement";
      case /* StrictCatchVariable */27 :
          return "Catch variable may not be eval or arguments in strict mode";
      case /* StrictVarName */28 :
          return "Variable name may not be eval or arguments in strict mode";
      case /* StrictParamName */29 :
          return "Parameter name eval or arguments is not allowed in strict mode";
      case /* StrictParamDupe */30 :
          return "Strict mode function may not have duplicate parameter names";
      case /* StrictFunctionName */31 :
          return "Function name may not be eval or arguments in strict mode";
      case /* StrictOctalLiteral */32 :
          return "Octal literals are not allowed in strict mode.";
      case /* StrictDelete */33 :
          return "Delete of an unqualified identifier in strict mode.";
      case /* StrictDuplicateProperty */34 :
          return "Duplicate data property in object literal not allowed in strict mode";
      case /* AccessorDataProperty */35 :
          return "Object literal may not have data and accessor property with the same name";
      case /* AccessorGetSet */36 :
          return "Object literal may not have multiple get/set accessors with the same name";
      case /* StrictLHSAssignment */37 :
          return "Assignment to eval or arguments is not allowed in strict mode";
      case /* StrictLHSPostfix */38 :
          return "Postfix increment/decrement may not have eval or arguments operand in strict mode";
      case /* StrictLHSPrefix */39 :
          return "Prefix increment/decrement may not have eval or arguments operand in strict mode";
      case /* StrictReservedWord */40 :
          return "Use of future reserved word in strict mode";
      case /* JSXAttributeValueEmptyExpression */41 :
          return "JSX attributes must only be assigned a non-empty expression";
      case /* InvalidJSXAttributeValue */42 :
          return "JSX value should be either an expression or a quoted JSX text";
      case /* NoUninitializedConst */43 :
          return "Const must be initialized";
      case /* NoUninitializedDestructuring */44 :
          return "Destructuring assignment must be initialized";
      case /* NewlineBeforeArrow */45 :
          return "Illegal newline before arrow";
      case /* StrictFunctionStatement */46 :
          return "In strict mode code, functions can only be declared at top level or immediately within another function.";
      case /* AdjacentJSXElements */47 :
          return "Unexpected token <. Remember, adjacent JSX elements must be wrapped in an enclosing parent tag";
      case /* ParameterAfterRestParameter */48 :
          return "Rest parameter must be final parameter of an argument list";
      case /* DeclareAsync */49 :
          return "async is an implementation detail and isn't necessary for your declare function statement. It is sufficient for your declare function to just have a Promise return type.";
      case /* DeclareExportLet */50 :
          return "`declare export let` is not supported. Use `declare export var` instead.";
      case /* DeclareExportConst */51 :
          return "`declare export const` is not supported. Use `declare export var` instead.";
      case /* DeclareExportType */52 :
          return "`declare export type` is not supported. Use `export type` instead.";
      case /* DeclareExportInterface */53 :
          return "`declare export interface` is not supported. Use `export interface` instead.";
      case /* UnexpectedExportStarAs */54 :
          return "`export * as` is an early-stage proposal and is not enabled by default. To enable support in the parser, use the `esproposal_export_star_as` option";
      case /* ExportNamelessClass */55 :
          return "When exporting a class as a named export, you must specify a class name. Did you mean `export default class ...`?";
      case /* ExportNamelessFunction */56 :
          return "When exporting a function as a named export, you must specify a function name. Did you mean `export default function ...`?";
      case /* UnsupportedDecorator */57 :
          return "Found a decorator in an unsupported position.";
      case /* MissingTypeParamDefault */58 :
          return "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.";
      case /* WindowsFloatOfString */59 :
          return "The Windows version of OCaml has a bug in how it parses hexidecimal numbers. It is fixed in OCaml 4.03.0. Until we can switch to 4.03.0, please avoid either hexidecimal notation or Windows.";
      case /* DuplicateDeclareModuleExports */60 :
          return "Duplicate `declare module.exports` statement!";
      case /* AmbiguousDeclareModuleKind */61 :
          return "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module xor they are a CommonJS module.";
      case /* GetterArity */62 :
          return "Getter should have zero parameters";
      case /* SetterArity */63 :
          return "Setter should have exactly one parameter";
      case /* InvalidNonTypeImportInDeclareModule */64 :
          return "Imports within a `declare module` body must always be `import type` or `import typeof`!";
      case /* ImportTypeShorthandOnlyInPureImport */65 :
          return "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements";
      case /* ImportSpecifierMissingComma */66 :
          return "Missing comma between import specifiers";
      
    }
  } else {
    switch (str.TAG | 0) {
      case /* Assertion */0 :
          return "Unexpected parser state: " + str._0;
      case /* UnexpectedToken */1 :
          return "Unexpected token " + str._0;
      case /* UnexpectedTokenWithSuggestion */2 :
          return curry._2(printf_1.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Unexpected token `",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "`. Did you mean `",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "`?",
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          },
                          _1: "Unexpected token `%s`. Did you mean `%s`?"
                        }), str._0, str._1);
      case /* InvalidRegExpFlags */3 :
          return "Invalid flags supplied to RegExp constructor '" + (str._0 + "'");
      case /* UnknownLabel */4 :
          return "Undefined label '" + (str._0 + "'");
      case /* Redeclaration */5 :
          return str._0 + (" '" + (str._1 + "' has already been declared"));
      case /* ExpectedJSXClosingTag */6 :
          return "Expected corresponding JSX closing tag for " + str._0;
      case /* DuplicateExport */7 :
          return curry._1(printf_1.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Duplicate export for `",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* "`" */96,
                                _1: /* End_of_format */0
                              }
                            }
                          },
                          _1: "Duplicate export for `%s`"
                        }), str._0);
      
    }
  }
}

var PP = {
  error: error$1
};

var $$Error_1$1 = $$Error$1;
var error_1 = error;
var PP_1 = PP;
/* No side effect */

var parse_error_bs = {
	$$Error: $$Error_1$1,
	error: error_1,
	PP: PP_1
};

/***********************************************************************/
/*                                                                     */
/*                           Objective Caml                            */
/*                                                                     */
/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */
/*                                                                     */
/*  Copyright 1996 Institut National de Recherche en Informatique et   */
/*  en Automatique.  All rights reserved.  This file is distributed    */
/*  under the terms of the GNU Library General Public License, with    */
/*  the special exception on linking described in file ../LICENSE.     */
/*                                                                     */
/***********************************************************************/

/* $Id: lexing.c 6045 2004-01-01 16:42:43Z doligez $ */

/* The table-driven automaton for lexers generated by camllex. */

function caml_lex_array(s) {
    var l = s.length / 2;
    var a = new Array(l);
    // when s.charCodeAt(2 * i + 1 ) > 128 (0x80)
    // a[i] < 0  
    // for(var i = 0 ; i <= 0xffff; ++i) { if (i << 16 >> 16 !==i){console.log(i<<16>>16, 'vs',i)}}
    // 
    for (var i = 0; i < l; i++)
        a[i] = (s.charCodeAt(2 * i) | (s.charCodeAt(2 * i + 1) << 8)) << 16 >> 16;
    return a;
}

var caml_lex_engine_aux = (function (tbl, start_state, lexbuf, exn){

    if (!Array.isArray(tbl.lex_default)) {
        tbl.lex_base = caml_lex_array(tbl.lex_base);
        tbl.lex_backtrk = caml_lex_array(tbl.lex_backtrk);
        tbl.lex_check = caml_lex_array(tbl.lex_check);
        tbl.lex_trans = caml_lex_array(tbl.lex_trans);
        tbl.lex_default = caml_lex_array(tbl.lex_default);  
    }
    var c;
    var state = start_state;
    //var buffer = bytes_of_string(lexbuf.lex_buffer);
    var buffer = lexbuf.lex_buffer;
    if (state >= 0) {
        /* First entry */
        lexbuf.lex_last_pos = lexbuf.lex_start_pos = lexbuf.lex_curr_pos;
        lexbuf.lex_last_action = -1;
    }
    else {
        /* Reentry after refill */
        state = -state - 1;
    }
    for (;;) {
        /* Lookup base address or action number for current state */
        var base = tbl.lex_base[state];
        if (base < 0)
            return -base - 1;
        /* See if it's a backtrack point */
        var backtrk = tbl.lex_backtrk[state];
        if (backtrk >= 0) {
            lexbuf.lex_last_pos = lexbuf.lex_curr_pos;
            lexbuf.lex_last_action = backtrk;
        }
        /* See if we need a refill */
        if (lexbuf.lex_curr_pos >= lexbuf.lex_buffer_len) {
            if (lexbuf.lex_eof_reached === 0)
                return -state - 1;
            else
                c = 256;
        }
        else {
            /* Read next input char */
            c = buffer[lexbuf.lex_curr_pos];
            lexbuf.lex_curr_pos++;
        }
        /* Determine next state */
        if (tbl.lex_check[base + c] === state) {
            state = tbl.lex_trans[base + c];
        }
        else {
            state = tbl.lex_default[state];
        }
        /* If no transition on this char, return to last backtrack point */
        if (state < 0) {
            lexbuf.lex_curr_pos = lexbuf.lex_last_pos;
            if (lexbuf.lex_last_action == -1)
                throw exn
            else
                return lexbuf.lex_last_action;
        }
        else {
            /* Erase the EOF condition only if the EOF pseudo-character was
             consumed by the automaton (i.e. there was no backtrack above)
             */
            if (c == 256)
                lexbuf.lex_eof_reached = 0;
        }
    }
});

var empty_token_lit = "lexing: empty token";

function caml_lex_engine(tbls, i, buf) {
  return caml_lex_engine_aux(tbls, i, buf, {
              RE_EXN_ID: "Failure",
              _1: empty_token_lit
            });
}

/***********************************************/
/* New lexer engine, with memory of positions  */
/***********************************************/

/**
 * s -> Lexing.lex_tables.lex_code
 * mem -> Lexing.lexbuf.lex_mem (* int array *)
 */          
          
function caml_lex_run_mem(s, i, mem, curr_pos) {
    for (;;) {
        var dst = s.charCodeAt(i);
        i++;
        if (dst == 0xff)
            return;
        var src = s.charCodeAt(i);
        i++;
        if (src == 0xff)
            mem[dst] = curr_pos;
        else
            mem[dst] = mem[src];
    }
}


/**
 * s -> Lexing.lex_tables.lex_code
 * mem -> Lexing.lexbuf.lex_mem (* int array *)
 */
  
function caml_lex_run_tag(s, i, mem) {
    for (;;) {
        var dst = s.charCodeAt(i);
        i++;
        if (dst == 0xff)
            return;
        var src = s.charCodeAt(i);
        i++;
        if (src == 0xff)
            mem[dst] = -1;
        else
            mem[dst] = mem[src];
    }
}

var caml_new_lex_engine_aux = (function (tbl, start_state, lexbuf, exn) {

    if (!Array.isArray(tbl.lex_default)) {
        tbl.lex_base = caml_lex_array(tbl.lex_base);
        tbl.lex_backtrk = caml_lex_array(tbl.lex_backtrk);
        tbl.lex_check = caml_lex_array(tbl.lex_check);
        tbl.lex_trans = caml_lex_array(tbl.lex_trans);
        tbl.lex_default = caml_lex_array(tbl.lex_default);
    }
    if(!Array.isArray(tbl.lex_default_code)){    
        tbl.lex_base_code = caml_lex_array(tbl.lex_base_code);
        tbl.lex_backtrk_code = caml_lex_array(tbl.lex_backtrk_code);
        tbl.lex_check_code = caml_lex_array(tbl.lex_check_code);
        tbl.lex_trans_code = caml_lex_array(tbl.lex_trans_code);
        tbl.lex_default_code = caml_lex_array(tbl.lex_default_code);
    }
    var c, state = start_state;
    //var buffer = caml_bytes_of_string(lexbuf.lex_buffer);
    var buffer = lexbuf.lex_buffer;
    if (state >= 0) {
        /* First entry */
        lexbuf.lex_last_pos = lexbuf.lex_start_pos = lexbuf.lex_curr_pos;
        lexbuf.lex_last_action = -1;
    }
    else {
        /* Reentry after refill */
        state = -state - 1;
    }
    for (;;) {
        /* Lookup base address or action number for current state */
        var base = tbl.lex_base[state];
        if (base < 0) {
            var pc_off = tbl.lex_base_code[state];
            caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf.lex_mem);
            return -base - 1;
        }
        /* See if it's a backtrack point */
        var backtrk = tbl.lex_backtrk[state];
        if (backtrk >= 0) {
            var pc_off = tbl.lex_backtrk_code[state];
            caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf.lex_mem);
            lexbuf.lex_last_pos = lexbuf.lex_curr_pos;
            lexbuf.lex_last_action = backtrk;
        }
        /* See if we need a refill */
        if (lexbuf.lex_curr_pos >= lexbuf.lex_buffer_len) {
            if (lexbuf.lex_eof_reached == 0)
                return -state - 1;
            else
                c = 256;
        }
        else {
            /* Read next input char */
            c = buffer[lexbuf.lex_curr_pos];
            lexbuf.lex_curr_pos++;
        }
        /* Determine next state */
        var pstate = state;
        if (tbl.lex_check[base + c] == state)
            state = tbl.lex_trans[base + c];
        else
            state = tbl.lex_default[state];
        /* If no transition on this char, return to last backtrack point */
        if (state < 0) {
            lexbuf.lex_curr_pos = lexbuf.lex_last_pos;
            if (lexbuf.lex_last_action == -1)
                throw exn;
            else
                return lexbuf.lex_last_action;
        }
        else {
            /* If some transition, get and perform memory moves */
            var base_code = tbl.lex_base_code[pstate], pc_off;
            if (tbl.lex_check_code[base_code + c] == pstate)
                pc_off = tbl.lex_trans_code[base_code + c];
            else
                pc_off = tbl.lex_default_code[pstate];
            if (pc_off > 0)
                caml_lex_run_mem(tbl.lex_code, pc_off, lexbuf.lex_mem, lexbuf.lex_curr_pos);
            /* Erase the EOF condition only if the EOF pseudo-character was
             consumed by the automaton (i.e. there was no backtrack above)
             */
            if (c == 256)
                lexbuf.lex_eof_reached = 0;
        }
    }
    });

function caml_new_lex_engine(tbl, i, buf) {
  return caml_new_lex_engine_aux(tbl, i, buf, {
              RE_EXN_ID: "Failure",
              _1: empty_token_lit
            });
}

var caml_lex_engine_1 = caml_lex_engine;
var caml_new_lex_engine_1 = caml_new_lex_engine;
/*  Not a pure module */

var caml_lexer = {
	caml_lex_engine: caml_lex_engine_1,
	caml_new_lex_engine: caml_new_lex_engine_1
};

function engine(tbl, state, buf) {
  var result = caml_lexer.caml_lex_engine(tbl, state, buf);
  if (result >= 0) {
    buf.lex_start_p = buf.lex_curr_p;
    var init = buf.lex_curr_p;
    buf.lex_curr_p = {
      pos_fname: init.pos_fname,
      pos_lnum: init.pos_lnum,
      pos_bol: init.pos_bol,
      pos_cnum: buf.lex_abs_pos + buf.lex_curr_pos | 0
    };
  }
  return result;
}

function new_engine(tbl, state, buf) {
  var result = caml_lexer.caml_new_lex_engine(tbl, state, buf);
  if (result >= 0) {
    buf.lex_start_p = buf.lex_curr_p;
    var init = buf.lex_curr_p;
    buf.lex_curr_p = {
      pos_fname: init.pos_fname,
      pos_lnum: init.pos_lnum,
      pos_bol: init.pos_bol,
      pos_cnum: buf.lex_abs_pos + buf.lex_curr_pos | 0
    };
  }
  return result;
}

var zero_pos = {
  pos_fname: "",
  pos_lnum: 1,
  pos_bol: 0,
  pos_cnum: 0
};

function from_function(f) {
  var partial_arg = caml_bytes.caml_create_bytes(512);
  return {
          refill_buff: (function (param) {
              var read = curry._2(f, partial_arg, partial_arg.length);
              var n = read > 0 ? read : (param.lex_eof_reached = true, 0);
              if ((param.lex_buffer_len + n | 0) > param.lex_buffer.length) {
                if (((param.lex_buffer_len - param.lex_start_pos | 0) + n | 0) <= param.lex_buffer.length) {
                  bytes.blit(param.lex_buffer, param.lex_start_pos, param.lex_buffer, 0, param.lex_buffer_len - param.lex_start_pos | 0);
                } else {
                  var newlen = (param.lex_buffer.length << 1);
                  if (((param.lex_buffer_len - param.lex_start_pos | 0) + n | 0) > newlen) {
                    throw {
                          RE_EXN_ID: "Failure",
                          _1: "Lexing.lex_refill: cannot grow buffer",
                          Error: new Error()
                        };
                  }
                  var newbuf = caml_bytes.caml_create_bytes(newlen);
                  bytes.blit(param.lex_buffer, param.lex_start_pos, newbuf, 0, param.lex_buffer_len - param.lex_start_pos | 0);
                  param.lex_buffer = newbuf;
                }
                var s = param.lex_start_pos;
                param.lex_abs_pos = param.lex_abs_pos + s | 0;
                param.lex_curr_pos = param.lex_curr_pos - s | 0;
                param.lex_start_pos = 0;
                param.lex_last_pos = param.lex_last_pos - s | 0;
                param.lex_buffer_len = param.lex_buffer_len - s | 0;
                var t = param.lex_mem;
                for(var i = 0 ,i_finish = t.length; i < i_finish; ++i){
                  var v = caml_array.get(t, i);
                  if (v >= 0) {
                    caml_array.set(t, i, v - s | 0);
                  }
                  
                }
              }
              bytes.blit(partial_arg, 0, param.lex_buffer, param.lex_buffer_len, n);
              param.lex_buffer_len = param.lex_buffer_len + n | 0;
              
            }),
          lex_buffer: caml_bytes.caml_create_bytes(1024),
          lex_buffer_len: 0,
          lex_abs_pos: 0,
          lex_start_pos: 0,
          lex_curr_pos: 0,
          lex_last_pos: 0,
          lex_last_action: 0,
          lex_eof_reached: false,
          lex_mem: [],
          lex_start_p: zero_pos,
          lex_curr_p: zero_pos
        };
}

function from_channel(ic) {
  return from_function(function (buf, n) {
              return pervasives.input(ic, buf, 0, n);
            });
}

function from_string(s) {
  return {
          refill_buff: (function (lexbuf) {
              lexbuf.lex_eof_reached = true;
              
            }),
          lex_buffer: bytes.of_string(s),
          lex_buffer_len: s.length,
          lex_abs_pos: 0,
          lex_start_pos: 0,
          lex_curr_pos: 0,
          lex_last_pos: 0,
          lex_last_action: 0,
          lex_eof_reached: true,
          lex_mem: [],
          lex_start_p: zero_pos,
          lex_curr_p: zero_pos
        };
}

function lexeme(lexbuf) {
  var len = lexbuf.lex_curr_pos - lexbuf.lex_start_pos | 0;
  return bytes.sub_string(lexbuf.lex_buffer, lexbuf.lex_start_pos, len);
}

function sub_lexeme(lexbuf, i1, i2) {
  var len = i2 - i1 | 0;
  return bytes.sub_string(lexbuf.lex_buffer, i1, len);
}

function sub_lexeme_opt(lexbuf, i1, i2) {
  if (i1 < 0) {
    return ;
  }
  var len = i2 - i1 | 0;
  return bytes.sub_string(lexbuf.lex_buffer, i1, len);
}

function sub_lexeme_char(lexbuf, i) {
  return caml_bytes.get(lexbuf.lex_buffer, i);
}

function sub_lexeme_char_opt(lexbuf, i) {
  if (i >= 0) {
    return caml_bytes.get(lexbuf.lex_buffer, i);
  }
  
}

function lexeme_char(lexbuf, i) {
  return caml_bytes.get(lexbuf.lex_buffer, lexbuf.lex_start_pos + i | 0);
}

function lexeme_start(lexbuf) {
  return lexbuf.lex_start_p.pos_cnum;
}

function lexeme_end(lexbuf) {
  return lexbuf.lex_curr_p.pos_cnum;
}

function lexeme_start_p(lexbuf) {
  return lexbuf.lex_start_p;
}

function lexeme_end_p(lexbuf) {
  return lexbuf.lex_curr_p;
}

function new_line(lexbuf) {
  var lcp = lexbuf.lex_curr_p;
  lexbuf.lex_curr_p = {
    pos_fname: lcp.pos_fname,
    pos_lnum: lcp.pos_lnum + 1 | 0,
    pos_bol: lcp.pos_cnum,
    pos_cnum: lcp.pos_cnum
  };
  
}

function flush_input(lb) {
  lb.lex_curr_pos = 0;
  lb.lex_abs_pos = 0;
  var init = lb.lex_curr_p;
  lb.lex_curr_p = {
    pos_fname: init.pos_fname,
    pos_lnum: init.pos_lnum,
    pos_bol: init.pos_bol,
    pos_cnum: 0
  };
  lb.lex_buffer_len = 0;
  
}

var dummy_pos = {
  pos_fname: "",
  pos_lnum: 0,
  pos_bol: 0,
  pos_cnum: -1
};

var dummy_pos_1 = dummy_pos;
var from_channel_1 = from_channel;
var from_string_1 = from_string;
var from_function_1 = from_function;
var lexeme_1 = lexeme;
var lexeme_char_1 = lexeme_char;
var lexeme_start_1 = lexeme_start;
var lexeme_end_1 = lexeme_end;
var lexeme_start_p_1 = lexeme_start_p;
var lexeme_end_p_1 = lexeme_end_p;
var new_line_1 = new_line;
var flush_input_1 = flush_input;
var sub_lexeme_1 = sub_lexeme;
var sub_lexeme_opt_1 = sub_lexeme_opt;
var sub_lexeme_char_1 = sub_lexeme_char;
var sub_lexeme_char_opt_1 = sub_lexeme_char_opt;
var engine_1 = engine;
var new_engine_1 = new_engine;
/* No side effect */

var lexing = {
	dummy_pos: dummy_pos_1,
	from_channel: from_channel_1,
	from_string: from_string_1,
	from_function: from_function_1,
	lexeme: lexeme_1,
	lexeme_char: lexeme_char_1,
	lexeme_start: lexeme_start_1,
	lexeme_end: lexeme_end_1,
	lexeme_start_p: lexeme_start_p_1,
	lexeme_end_p: lexeme_end_p_1,
	new_line: new_line_1,
	flush_input: flush_input_1,
	sub_lexeme: sub_lexeme_1,
	sub_lexeme_opt: sub_lexeme_opt_1,
	sub_lexeme_char: sub_lexeme_char_1,
	sub_lexeme_char_opt: sub_lexeme_char_opt_1,
	engine: engine_1,
	new_engine: new_engine_1
};

var match = caml_sys.caml_sys_get_argv(undefined);

var os_type$1 = caml_sys.os_type(undefined);

var backend_type = /* Other */{
  _0: "BS"
};

var big_endian = false;

var unix = caml_sys.os_type(undefined) === "Unix";

var win32 = caml_sys.os_type(undefined) === "Win32";

function getenv_opt(s) {
  var x = typeof process === "undefined" ? undefined : process;
  if (x !== undefined) {
    return x.env[s];
  }
  
}

var interactive = {
  contents: false
};

function set_signal(sig_num, sig_beh) {
  
}

var Break = caml_exceptions.create("Sys.Break");

function catch_break(on) {
  
}

function enable_runtime_warnings(param) {
  
}

function runtime_warnings_enabled(param) {
  return false;
}

var argv = match[1];

var executable_name = match[0];

var cygwin = false;

var word_size = 32;

var int_size = 32;

var max_string_length = 2147483647;

var max_array_length = 2147483647;

var sigabrt = -1;

var sigalrm = -2;

var sigfpe = -3;

var sighup = -4;

var sigill = -5;

var sigint = -6;

var sigkill = -7;

var sigpipe = -8;

var sigquit = -9;

var sigsegv = -10;

var sigterm = -11;

var sigusr1 = -12;

var sigusr2 = -13;

var sigchld = -14;

var sigcont = -15;

var sigstop = -16;

var sigtstp = -17;

var sigttin = -18;

var sigttou = -19;

var sigvtalrm = -20;

var sigprof = -21;

var sigbus = -22;

var sigpoll = -23;

var sigsys = -24;

var sigtrap = -25;

var sigurg = -26;

var sigxcpu = -27;

var sigxfsz = -28;

var ocaml_version = "4.06.2+BS";

var argv_1 = argv;
var executable_name_1 = executable_name;
var getenv_opt_1 = getenv_opt;
var interactive_1 = interactive;
var os_type_1$1 = os_type$1;
var backend_type_1 = backend_type;
var unix_1 = unix;
var win32_1 = win32;
var cygwin_1 = cygwin;
var word_size_1 = word_size;
var int_size_1 = int_size;
var big_endian_1 = big_endian;
var max_string_length_1 = max_string_length;
var max_array_length_1 = max_array_length;
var set_signal_1 = set_signal;
var sigabrt_1 = sigabrt;
var sigalrm_1 = sigalrm;
var sigfpe_1 = sigfpe;
var sighup_1 = sighup;
var sigill_1 = sigill;
var sigint_1 = sigint;
var sigkill_1 = sigkill;
var sigpipe_1 = sigpipe;
var sigquit_1 = sigquit;
var sigsegv_1 = sigsegv;
var sigterm_1 = sigterm;
var sigusr1_1 = sigusr1;
var sigusr2_1 = sigusr2;
var sigchld_1 = sigchld;
var sigcont_1 = sigcont;
var sigstop_1 = sigstop;
var sigtstp_1 = sigtstp;
var sigttin_1 = sigttin;
var sigttou_1 = sigttou;
var sigvtalrm_1 = sigvtalrm;
var sigprof_1 = sigprof;
var sigbus_1 = sigbus;
var sigpoll_1 = sigpoll;
var sigsys_1 = sigsys;
var sigtrap_1 = sigtrap;
var sigurg_1 = sigurg;
var sigxcpu_1 = sigxcpu;
var sigxfsz_1 = sigxfsz;
var Break_1 = Break;
var catch_break_1 = catch_break;
var ocaml_version_1 = ocaml_version;
var enable_runtime_warnings_1 = enable_runtime_warnings;
var runtime_warnings_enabled_1 = runtime_warnings_enabled;
/* No side effect */

var sys = {
	argv: argv_1,
	executable_name: executable_name_1,
	getenv_opt: getenv_opt_1,
	interactive: interactive_1,
	os_type: os_type_1$1,
	backend_type: backend_type_1,
	unix: unix_1,
	win32: win32_1,
	cygwin: cygwin_1,
	word_size: word_size_1,
	int_size: int_size_1,
	big_endian: big_endian_1,
	max_string_length: max_string_length_1,
	max_array_length: max_array_length_1,
	set_signal: set_signal_1,
	sigabrt: sigabrt_1,
	sigalrm: sigalrm_1,
	sigfpe: sigfpe_1,
	sighup: sighup_1,
	sigill: sigill_1,
	sigint: sigint_1,
	sigkill: sigkill_1,
	sigpipe: sigpipe_1,
	sigquit: sigquit_1,
	sigsegv: sigsegv_1,
	sigterm: sigterm_1,
	sigusr1: sigusr1_1,
	sigusr2: sigusr2_1,
	sigchld: sigchld_1,
	sigcont: sigcont_1,
	sigstop: sigstop_1,
	sigtstp: sigtstp_1,
	sigttin: sigttin_1,
	sigttou: sigttou_1,
	sigvtalrm: sigvtalrm_1,
	sigprof: sigprof_1,
	sigbus: sigbus_1,
	sigpoll: sigpoll_1,
	sigsys: sigsys_1,
	sigtrap: sigtrap_1,
	sigurg: sigurg_1,
	sigxcpu: sigxcpu_1,
	sigxfsz: sigxfsz_1,
	Break: Break_1,
	catch_break: catch_break_1,
	ocaml_version: ocaml_version_1,
	enable_runtime_warnings: enable_runtime_warnings_1,
	runtime_warnings_enabled: runtime_warnings_enabled_1
};

var make_float = caml_array.caml_make_float_vect;

var Floatarray = {};

function init$3(l, f) {
  if (l === 0) {
    return [];
  }
  if (l < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.init",
          Error: new Error()
        };
  }
  var res = caml_array.caml_make_vect(l, curry._1(f, 0));
  for(var i = 1; i < l; ++i){
    res[i] = curry._1(f, i);
  }
  return res;
}

function make_matrix(sx, sy, init) {
  var res = caml_array.caml_make_vect(sx, []);
  for(var x = 0; x < sx; ++x){
    res[x] = caml_array.caml_make_vect(sy, init);
  }
  return res;
}

function copy$2(a) {
  var l = a.length;
  if (l === 0) {
    return [];
  } else {
    return caml_array.caml_array_sub(a, 0, l);
  }
}

function append$1(a1, a2) {
  var l1 = a1.length;
  if (l1 === 0) {
    return copy$2(a2);
  } else if (a2.length === 0) {
    return caml_array.caml_array_sub(a1, 0, l1);
  } else {
    return a1.concat(a2);
  }
}

function sub$4(a, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.sub",
          Error: new Error()
        };
  }
  return caml_array.caml_array_sub(a, ofs, len);
}

function fill$3(a, ofs, len, v) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.fill",
          Error: new Error()
        };
  }
  for(var i = ofs ,i_finish = ofs + len | 0; i < i_finish; ++i){
    a[i] = v;
  }
  
}

function blit$3(a1, ofs1, a2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (a1.length - len | 0) || ofs2 < 0 || ofs2 > (a2.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.blit",
          Error: new Error()
        };
  }
  return caml_array.caml_array_blit(a1, ofs1, a2, ofs2, len);
}

function iter$3(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    curry._1(f, a[i]);
  }
  
}

function iter2$1(f, a, b) {
  if (a.length !== b.length) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.iter2: arrays must have the same length",
          Error: new Error()
        };
  }
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    curry._2(f, a[i], b[i]);
  }
  
}

function map$3(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = caml_array.caml_make_vect(l, curry._1(f, a[0]));
  for(var i = 1; i < l; ++i){
    r[i] = curry._1(f, a[i]);
  }
  return r;
}

function map2$1(f, a, b) {
  var la = a.length;
  var lb = b.length;
  if (la !== lb) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Array.map2: arrays must have the same length",
          Error: new Error()
        };
  }
  if (la === 0) {
    return [];
  }
  var r = caml_array.caml_make_vect(la, curry._2(f, a[0], b[0]));
  for(var i = 1; i < la; ++i){
    r[i] = curry._2(f, a[i], b[i]);
  }
  return r;
}

function iteri$3(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    curry._2(f, i, a[i]);
  }
  
}

function mapi$4(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = caml_array.caml_make_vect(l, curry._2(f, 0, a[0]));
  for(var i = 1; i < l; ++i){
    r[i] = curry._2(f, i, a[i]);
  }
  return r;
}

function to_list(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue ;
  }}

function list_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = accu + 1 | 0;
    continue ;
  }}

function of_list(l) {
  if (!l) {
    return [];
  }
  var a = caml_array.caml_make_vect(list_length(0, l), l.hd);
  var _i = 1;
  var _param = l.tl;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return a;
    }
    a[i] = param.hd;
    _param = param.tl;
    _i = i + 1 | 0;
    continue ;
  }}

function fold_left$1(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = curry._2(f, r, a[i]);
  }
  return r;
}

function fold_right$1(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = curry._2(f, a[i], r);
  }
  return r;
}

function exists$1(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (curry._1(p, a[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  }}

function for_all$1(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return true;
    }
    if (!curry._1(p, a[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  }}

function mem$1(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (caml_obj.caml_equal(a[i], x)) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  }}

function memq$1(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (x === a[i]) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  }}

var Bottom = caml_exceptions.create("Array.Bottom");

function sort$1(cmp, a) {
  var maxson = function (l, i) {
    var i31 = ((i + i | 0) + i | 0) + 1 | 0;
    var x = i31;
    if ((i31 + 2 | 0) < l) {
      if (curry._2(cmp, caml_array.get(a, i31), caml_array.get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (curry._2(cmp, caml_array.get(a, x), caml_array.get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    }
    if ((i31 + 1 | 0) < l && curry._2(cmp, caml_array.get(a, i31), caml_array.get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    }
    if (i31 < l) {
      return i31;
    }
    throw {
          RE_EXN_ID: Bottom,
          _1: i,
          Error: new Error()
        };
  };
  var trickle = function (l, i, e) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        if (curry._2(cmp, caml_array.get(a, j), e) <= 0) {
          return caml_array.set(a, i$1, e);
        }
        caml_array.set(a, i$1, caml_array.get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_i){
      var i$2 = caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.RE_EXN_ID === Bottom) {
        return caml_array.set(a, i$2._1, e);
      }
      throw i$2;
    }
  };
  var bubble = function (l, i) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        caml_array.set(a, i$1, caml_array.get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_i){
      var i$2 = caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.RE_EXN_ID === Bottom) {
        return i$2._1;
      }
      throw i$2;
    }
  };
  var trickleup = function (_i, e) {
    while(true) {
      var i = _i;
      var father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "array.ml",
                238,
                4
              ],
              Error: new Error()
            };
      }
      if (curry._2(cmp, caml_array.get(a, father), e) >= 0) {
        return caml_array.set(a, i, e);
      }
      caml_array.set(a, i, caml_array.get(a, father));
      if (father <= 0) {
        return caml_array.set(a, 0, e);
      }
      _i = father;
      continue ;
    }  };
  var l = a.length;
  for(var i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i){
    trickle(l, i, caml_array.get(a, i));
  }
  for(var i$1 = l - 1 | 0; i$1 >= 2; --i$1){
    var e = caml_array.get(a, i$1);
    caml_array.set(a, i$1, caml_array.get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l <= 1) {
    return ;
  }
  var e$1 = caml_array.get(a, 1);
  caml_array.set(a, 1, caml_array.get(a, 0));
  return caml_array.set(a, 0, e$1);
}

function stable_sort$1(cmp, a) {
  var merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    var src1r = src1ofs + src1len | 0;
    var src2r = src2ofs + src2len | 0;
    var _i1 = src1ofs;
    var _s1 = caml_array.get(a, src1ofs);
    var _i2 = src2ofs;
    var _s2 = caml_array.get(src2, src2ofs);
    var _d = dstofs;
    while(true) {
      var d = _d;
      var s2 = _s2;
      var i2 = _i2;
      var s1 = _s1;
      var i1 = _i1;
      if (curry._2(cmp, s1, s2) <= 0) {
        caml_array.set(dst, d, s1);
        var i1$1 = i1 + 1 | 0;
        if (i1$1 >= src1r) {
          return blit$3(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
        _d = d + 1 | 0;
        _s1 = caml_array.get(a, i1$1);
        _i1 = i1$1;
        continue ;
      }
      caml_array.set(dst, d, s2);
      var i2$1 = i2 + 1 | 0;
      if (i2$1 >= src2r) {
        return blit$3(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
      }
      _d = d + 1 | 0;
      _s2 = caml_array.get(src2, i2$1);
      _i2 = i2$1;
      continue ;
    }  };
  var isortto = function (srcofs, dst, dstofs, len) {
    for(var i = 0; i < len; ++i){
      var e = caml_array.get(a, srcofs + i | 0);
      var j = (dstofs + i | 0) - 1 | 0;
      while(j >= dstofs && curry._2(cmp, caml_array.get(dst, j), e) > 0) {
        caml_array.set(dst, j + 1 | 0, caml_array.get(dst, j));
        j = j - 1 | 0;
      }      caml_array.set(dst, j + 1 | 0, e);
    }
    
  };
  var sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    }
    var l1 = len / 2 | 0;
    var l2 = len - l1 | 0;
    sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
    sortto(srcofs, a, srcofs + l2 | 0, l1);
    return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
  };
  var l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  }
  var l1 = l / 2 | 0;
  var l2 = l - l1 | 0;
  var t = caml_array.caml_make_vect(l2, caml_array.get(a, 0));
  sortto(l1, t, 0, l2);
  sortto(0, a, l2, l1);
  return merge(l2, l1, t, 0, l2, a, 0);
}

var create_matrix = make_matrix;

var concat$3 = caml_array.caml_array_concat;

var fast_sort$1 = stable_sort$1;

var make_float_1 = make_float;
var init_1$3 = init$3;
var make_matrix_1 = make_matrix;
var create_matrix_1 = create_matrix;
var append_1$1 = append$1;
var concat_1$3 = concat$3;
var sub_1$4 = sub$4;
var copy_1$2 = copy$2;
var fill_1$2 = fill$3;
var blit_1$3 = blit$3;
var to_list_1 = to_list;
var of_list_1 = of_list;
var iter_1$3 = iter$3;
var iteri_1$3 = iteri$3;
var map_1$3 = map$3;
var mapi_1$3 = mapi$4;
var fold_left_1$1 = fold_left$1;
var fold_right_1$1 = fold_right$1;
var iter2_1$1 = iter2$1;
var map2_1$1 = map2$1;
var for_all_1$1 = for_all$1;
var exists_1$1 = exists$1;
var mem_1$1 = mem$1;
var memq_1$1 = memq$1;
var sort_1$1 = sort$1;
var stable_sort_1$1 = stable_sort$1;
var fast_sort_1$1 = fast_sort$1;
var Floatarray_1 = Floatarray;
/* No side effect */

var array = {
	make_float: make_float_1,
	init: init_1$3,
	make_matrix: make_matrix_1,
	create_matrix: create_matrix_1,
	append: append_1$1,
	concat: concat_1$3,
	sub: sub_1$4,
	copy: copy_1$2,
	fill: fill_1$2,
	blit: blit_1$3,
	to_list: to_list_1,
	of_list: of_list_1,
	iter: iter_1$3,
	iteri: iteri_1$3,
	map: map_1$3,
	mapi: mapi_1$3,
	fold_left: fold_left_1$1,
	fold_right: fold_right_1$1,
	iter2: iter2_1$1,
	map2: map2_1$1,
	for_all: for_all_1$1,
	exists: exists_1$1,
	mem: mem_1$1,
	memq: memq_1$1,
	sort: sort_1$1,
	stable_sort: stable_sort_1$1,
	fast_sort: fast_sort_1$1,
	Floatarray: Floatarray_1
};

function succ$1(n) {
  return n + 1 | 0;
}

function pred(n) {
  return n - 1 | 0;
}

function abs$1(n) {
  if (n >= 0) {
    return n;
  } else {
    return -n | 0;
  }
}

function lognot(n) {
  return n ^ -1;
}

function to_string$2(n) {
  return caml_format.caml_int32_format("%d", n);
}

function of_string_opt(s) {
  try {
    return caml_format.caml_int32_of_string(s);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return ;
    }
    throw exn;
  }
}

var compare$4 = caml_primitive.caml_int32_compare;

function equal$3(x, y) {
  return x === y;
}

var zero$1 = 0;

var one$1 = 1;

var minus_one = -1;

var max_int$2 = 2147483647;

var min_int$2 = -2147483648;

var zero_1$1 = zero$1;
var one_1$1 = one$1;
var minus_one_1 = minus_one;
var succ_1$1 = succ$1;
var pred_1 = pred;
var abs_1$1 = abs$1;
var max_int_1$2 = max_int$2;
var min_int_1$2 = min_int$2;
var lognot_1 = lognot;
var of_string_opt_1 = of_string_opt;
var to_string_1$2 = to_string$2;
var compare_1$4 = compare$4;
var equal_1$3 = equal$3;
/* No side effect */

var int32 = {
	zero: zero_1$1,
	one: one_1$1,
	minus_one: minus_one_1,
	succ: succ_1$1,
	pred: pred_1,
	abs: abs_1$1,
	max_int: max_int_1$2,
	min_int: min_int_1$2,
	lognot: lognot_1,
	of_string_opt: of_string_opt_1,
	to_string: to_string_1$2,
	compare: compare_1$4,
	equal: equal_1$3
};

function pred$1(n) {
  return caml_int64.sub(n, caml_int64.one);
}

function abs$2(n) {
  if (caml_int64.ge(n, caml_int64.zero)) {
    return n;
  } else {
    return caml_int64.neg(n);
  }
}

function lognot$1(n) {
  return caml_int64.xor(n, caml_int64.neg_one);
}

function of_string_opt$1(s) {
  try {
    return caml_format.caml_int64_of_string(s);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return ;
    }
    throw exn;
  }
}

var compare$5 = caml_int64.compare;

function equal$4(x, y) {
  return caml_int64.compare(x, y) === 0;
}

var zero$2 = caml_int64.zero;

var one$2 = caml_int64.one;

var minus_one$1 = caml_int64.neg_one;

var succ$2 = caml_int64.succ;

var max_int$3 = caml_int64.max_int;

var min_int$3 = caml_int64.min_int;

var to_string$3 = caml_int64.to_string;

var zero_1$2 = zero$2;
var one_1$2 = one$2;
var minus_one_1$1 = minus_one$1;
var succ_1$2 = succ$2;
var pred_1$1 = pred$1;
var abs_1$2 = abs$2;
var max_int_1$3 = max_int$3;
var min_int_1$3 = min_int$3;
var lognot_1$1 = lognot$1;
var of_string_opt_1$1 = of_string_opt$1;
var to_string_1$3 = to_string$3;
var compare_1$5 = compare$5;
var equal_1$4 = equal$4;
/* No side effect */

var int64 = {
	zero: zero_1$2,
	one: one_1$2,
	minus_one: minus_one_1$1,
	succ: succ_1$2,
	pred: pred_1$1,
	abs: abs_1$2,
	max_int: max_int_1$3,
	min_int: min_int_1$3,
	lognot: lognot_1$1,
	of_string_opt: of_string_opt_1$1,
	to_string: to_string_1$3,
	compare: compare_1$5,
	equal: equal_1$4
};

function cmn(q, a, b, x, s, t) {
  var a$1 = ((a + q | 0) + x | 0) + t | 0;
  return ((a$1 << s) | (a$1 >>> (32 - s | 0)) | 0) + b | 0;
}

function f(a, b, c, d, x, s, t) {
  return cmn(b & c | (b ^ -1) & d, a, b, x, s, t);
}

function g(a, b, c, d, x, s, t) {
  return cmn(b & d | c & (d ^ -1), a, b, x, s, t);
}

function h(a, b, c, d, x, s, t) {
  return cmn(b ^ c ^ d, a, b, x, s, t);
}

function i(a, b, c, d, x, s, t) {
  return cmn(c ^ (b | d ^ -1), a, b, x, s, t);
}

function cycle(x, k) {
  var a = x[0];
  var b = x[1];
  var c = x[2];
  var d = x[3];
  a = f(a, b, c, d, k[0], 7, -680876936);
  d = f(d, a, b, c, k[1], 12, -389564586);
  c = f(c, d, a, b, k[2], 17, 606105819);
  b = f(b, c, d, a, k[3], 22, -1044525330);
  a = f(a, b, c, d, k[4], 7, -176418897);
  d = f(d, a, b, c, k[5], 12, 1200080426);
  c = f(c, d, a, b, k[6], 17, -1473231341);
  b = f(b, c, d, a, k[7], 22, -45705983);
  a = f(a, b, c, d, k[8], 7, 1770035416);
  d = f(d, a, b, c, k[9], 12, -1958414417);
  c = f(c, d, a, b, k[10], 17, -42063);
  b = f(b, c, d, a, k[11], 22, -1990404162);
  a = f(a, b, c, d, k[12], 7, 1804603682);
  d = f(d, a, b, c, k[13], 12, -40341101);
  c = f(c, d, a, b, k[14], 17, -1502002290);
  b = f(b, c, d, a, k[15], 22, 1236535329);
  a = g(a, b, c, d, k[1], 5, -165796510);
  d = g(d, a, b, c, k[6], 9, -1069501632);
  c = g(c, d, a, b, k[11], 14, 643717713);
  b = g(b, c, d, a, k[0], 20, -373897302);
  a = g(a, b, c, d, k[5], 5, -701558691);
  d = g(d, a, b, c, k[10], 9, 38016083);
  c = g(c, d, a, b, k[15], 14, -660478335);
  b = g(b, c, d, a, k[4], 20, -405537848);
  a = g(a, b, c, d, k[9], 5, 568446438);
  d = g(d, a, b, c, k[14], 9, -1019803690);
  c = g(c, d, a, b, k[3], 14, -187363961);
  b = g(b, c, d, a, k[8], 20, 1163531501);
  a = g(a, b, c, d, k[13], 5, -1444681467);
  d = g(d, a, b, c, k[2], 9, -51403784);
  c = g(c, d, a, b, k[7], 14, 1735328473);
  b = g(b, c, d, a, k[12], 20, -1926607734);
  a = h(a, b, c, d, k[5], 4, -378558);
  d = h(d, a, b, c, k[8], 11, -2022574463);
  c = h(c, d, a, b, k[11], 16, 1839030562);
  b = h(b, c, d, a, k[14], 23, -35309556);
  a = h(a, b, c, d, k[1], 4, -1530992060);
  d = h(d, a, b, c, k[4], 11, 1272893353);
  c = h(c, d, a, b, k[7], 16, -155497632);
  b = h(b, c, d, a, k[10], 23, -1094730640);
  a = h(a, b, c, d, k[13], 4, 681279174);
  d = h(d, a, b, c, k[0], 11, -358537222);
  c = h(c, d, a, b, k[3], 16, -722521979);
  b = h(b, c, d, a, k[6], 23, 76029189);
  a = h(a, b, c, d, k[9], 4, -640364487);
  d = h(d, a, b, c, k[12], 11, -421815835);
  c = h(c, d, a, b, k[15], 16, 530742520);
  b = h(b, c, d, a, k[2], 23, -995338651);
  a = i(a, b, c, d, k[0], 6, -198630844);
  d = i(d, a, b, c, k[7], 10, 1126891415);
  c = i(c, d, a, b, k[14], 15, -1416354905);
  b = i(b, c, d, a, k[5], 21, -57434055);
  a = i(a, b, c, d, k[12], 6, 1700485571);
  d = i(d, a, b, c, k[3], 10, -1894986606);
  c = i(c, d, a, b, k[10], 15, -1051523);
  b = i(b, c, d, a, k[1], 21, -2054922799);
  a = i(a, b, c, d, k[8], 6, 1873313359);
  d = i(d, a, b, c, k[15], 10, -30611744);
  c = i(c, d, a, b, k[6], 15, -1560198380);
  b = i(b, c, d, a, k[13], 21, 1309151649);
  a = i(a, b, c, d, k[4], 6, -145523070);
  d = i(d, a, b, c, k[11], 10, -1120210379);
  c = i(c, d, a, b, k[2], 15, 718787259);
  b = i(b, c, d, a, k[9], 21, -343485551);
  x[0] = a + x[0] | 0;
  x[1] = b + x[1] | 0;
  x[2] = c + x[2] | 0;
  x[3] = d + x[3] | 0;
  
}

var state = [
  1732584193,
  -271733879,
  -1732584194,
  271733878
];

var md5blk = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];

function caml_md5_string(s, start, len) {
  var s$1 = s.slice(start, len);
  var n = s$1.length;
  state[0] = 1732584193;
  state[1] = -271733879;
  state[2] = -1732584194;
  state[3] = 271733878;
  for(var i = 0; i <= 15; ++i){
    md5blk[i] = 0;
  }
  var i_end = n / 64 | 0;
  for(var i$1 = 1; i$1 <= i_end; ++i$1){
    for(var j = 0; j <= 15; ++j){
      var k = ((i$1 << 6) - 64 | 0) + (j << 2) | 0;
      md5blk[j] = ((s$1.charCodeAt(k) + (s$1.charCodeAt(k + 1 | 0) << 8) | 0) + (s$1.charCodeAt(k + 2 | 0) << 16) | 0) + (s$1.charCodeAt(k + 3 | 0) << 24) | 0;
    }
    cycle(state, md5blk);
  }
  var s_tail = s$1.slice((i_end << 6));
  for(var kk = 0; kk <= 15; ++kk){
    md5blk[kk] = 0;
  }
  var i_end$1 = s_tail.length - 1 | 0;
  for(var i$2 = 0; i$2 <= i_end$1; ++i$2){
    md5blk[i$2 / 4 | 0] = md5blk[i$2 / 4 | 0] | (s_tail.charCodeAt(i$2) << (i$2 % 4 << 3));
  }
  var i$3 = i_end$1 + 1 | 0;
  md5blk[i$3 / 4 | 0] = md5blk[i$3 / 4 | 0] | (128 << (i$3 % 4 << 3));
  if (i$3 > 55) {
    cycle(state, md5blk);
    for(var i$4 = 0; i$4 <= 15; ++i$4){
      md5blk[i$4] = 0;
    }
  }
  md5blk[14] = (n << 3);
  cycle(state, md5blk);
  return String.fromCharCode(state[0] & 255, (state[0] >> 8) & 255, (state[0] >> 16) & 255, (state[0] >> 24) & 255, state[1] & 255, (state[1] >> 8) & 255, (state[1] >> 16) & 255, (state[1] >> 24) & 255, state[2] & 255, (state[2] >> 8) & 255, (state[2] >> 16) & 255, (state[2] >> 24) & 255, state[3] & 255, (state[3] >> 8) & 255, (state[3] >> 16) & 255, (state[3] >> 24) & 255);
}

var caml_md5_string_1 = caml_md5_string;
/* No side effect */

var caml_md5 = {
	caml_md5_string: caml_md5_string_1
};

function string$1(str) {
  return caml_md5.caml_md5_string(str, 0, str.length);
}

function bytes$1(b) {
  return string$1(caml_bytes.bytes_to_string(b));
}

function substring(str, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (str.length - len | 0)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Digest.substring",
          Error: new Error()
        };
  }
  return caml_md5.caml_md5_string(str, ofs, len);
}

function subbytes(b, ofs, len) {
  return substring(caml_bytes.bytes_to_string(b), ofs, len);
}

function file(filename) {
  var ic = pervasives.open_in_bin(filename);
  var d;
  try {
    d = caml_external_polyfill.resolve("caml_md5_chan")(ic, -1);
  }
  catch (e){
    caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
    throw e;
  }
  caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  return d;
}

var output$1 = pervasives.output_string;

function input$1(chan) {
  return pervasives.really_input_string(chan, 16);
}

function char_hex(n) {
  return n + (
          n < 10 ? /* "0" */48 : 87
        ) | 0;
}

function to_hex$1(d) {
  if (d.length !== 16) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Digest.to_hex",
          Error: new Error()
        };
  }
  var result = caml_bytes.caml_create_bytes(32);
  for(var i = 0; i <= 15; ++i){
    var x = caml_string.get(d, i);
    result[(i << 1)] = char_hex((x >>> 4));
    result[(i << 1) + 1 | 0] = char_hex(x & 15);
  }
  return caml_bytes.bytes_to_string(result);
}

function from_hex(s) {
  if (s.length !== 32) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Digest.from_hex",
          Error: new Error()
        };
  }
  var digit = function (c) {
    if (c >= 65) {
      if (c >= 97) {
        if (c >= 103) {
          throw {
                RE_EXN_ID: "Invalid_argument",
                _1: "Digest.from_hex",
                Error: new Error()
              };
        }
        return (c - /* "a" */97 | 0) + 10 | 0;
      }
      if (c >= 71) {
        throw {
              RE_EXN_ID: "Invalid_argument",
              _1: "Digest.from_hex",
              Error: new Error()
            };
      }
      return (c - /* "A" */65 | 0) + 10 | 0;
    }
    if (c > 57 || c < 48) {
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "Digest.from_hex",
            Error: new Error()
          };
    }
    return c - /* "0" */48 | 0;
  };
  var $$byte = function (i) {
    return (digit(caml_string.get(s, i)) << 4) + digit(caml_string.get(s, i + 1 | 0)) | 0;
  };
  var result = caml_bytes.caml_create_bytes(16);
  for(var i = 0; i <= 15; ++i){
    caml_bytes.set(result, i, char.chr($$byte((i << 1))));
  }
  return caml_bytes.bytes_to_string(result);
}

var compare$6 = string.compare;

var equal$5 = string.equal;

var compare_1$6 = compare$6;
var equal_1$5 = equal$5;
var string_1 = string$1;
var bytes_1 = bytes$1;
var substring_1 = substring;
var subbytes_1 = subbytes;
var file_1 = file;
var output_1$1 = output$1;
var input_1$1 = input$1;
var to_hex_1$1 = to_hex$1;
var from_hex_1 = from_hex;
/* No side effect */

var digest = {
	compare: compare_1$6,
	equal: equal_1$5,
	string: string_1,
	bytes: bytes_1,
	substring: substring_1,
	subbytes: subbytes_1,
	file: file_1,
	output: output_1$1,
	input: input_1$1,
	to_hex: to_hex_1$1,
	from_hex: from_hex_1
};

function random_seed(param) {
  return [(Math.floor(Math.random()*0x7fffffff))];
}

function assign(st1, st2) {
  array.blit(st2.st, 0, st1.st, 0, 55);
  st1.idx = st2.idx;
  
}

function full_init(s, seed) {
  var combine = function (accu, x) {
    return digest.string(accu + String(x));
  };
  var extract = function (d) {
    return ((caml_string.get(d, 0) + (caml_string.get(d, 1) << 8) | 0) + (caml_string.get(d, 2) << 16) | 0) + (caml_string.get(d, 3) << 24) | 0;
  };
  var seed$1 = seed.length === 0 ? [0] : seed;
  var l = seed$1.length;
  for(var i = 0; i <= 54; ++i){
    caml_array.set(s.st, i, i);
  }
  var accu = "x";
  for(var i$1 = 0 ,i_finish = 54 + (
      55 > l ? 55 : l
    ) | 0; i$1 <= i_finish; ++i$1){
    var j = i$1 % 55;
    var k = i$1 % l;
    accu = combine(accu, caml_array.get(seed$1, k));
    caml_array.set(s.st, j, (caml_array.get(s.st, j) ^ extract(accu)) & 1073741823);
  }
  s.idx = 0;
  
}

function make$3(seed) {
  var result = {
    st: caml_array.caml_make_vect(55, 0),
    idx: 0
  };
  full_init(result, seed);
  return result;
}

function make_self_init(param) {
  return make$3(random_seed());
}

function copy$3(s) {
  var result = {
    st: caml_array.caml_make_vect(55, 0),
    idx: 0
  };
  assign(result, s);
  return result;
}

function bits(s) {
  s.idx = (s.idx + 1 | 0) % 55;
  var curval = caml_array.get(s.st, s.idx);
  var newval = caml_array.get(s.st, (s.idx + 24 | 0) % 55) + (curval ^ (curval >>> 25) & 31) | 0;
  var newval30 = newval & 1073741823;
  caml_array.set(s.st, s.idx, newval30);
  return newval30;
}

function $$int(s, bound) {
  if (bound > 1073741823 || bound <= 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Random.int",
          Error: new Error()
        };
  }
  while(true) {
    var r = bits(s);
    var v = r % bound;
    if ((r - v | 0) <= ((1073741823 - bound | 0) + 1 | 0)) {
      return v;
    }
    continue ;
  }}

function int32$1(s, bound) {
  if (bound <= 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Random.int32",
          Error: new Error()
        };
  }
  while(true) {
    var b1 = bits(s);
    var b2 = ((bits(s) & 1) << 30);
    var r = b1 | b2;
    var v = r % bound;
    if ((r - v | 0) <= ((int32.max_int - bound | 0) + 1 | 0)) {
      return v;
    }
    continue ;
  }}

function int64$1(s, bound) {
  if (caml_int64.le(bound, caml_int64.zero)) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Random.int64",
          Error: new Error()
        };
  }
  while(true) {
    var b1 = caml_int64.of_int32(bits(s));
    var b2 = caml_int64.lsl_(caml_int64.of_int32(bits(s)), 30);
    var b3 = caml_int64.lsl_(caml_int64.of_int32(bits(s) & 7), 60);
    var r = caml_int64.or_(b1, caml_int64.or_(b2, b3));
    var v = caml_int64.mod_(r, bound);
    if (!caml_int64.gt(caml_int64.sub(r, v), caml_int64.add(caml_int64.sub(int64.max_int, bound), caml_int64.one))) {
      return v;
    }
    continue ;
  }}

function rawfloat(s) {
  var r1 = bits(s);
  var r2 = bits(s);
  return (r1 / 1073741824.0 + r2) / 1073741824.0;
}

function $$float(s, bound) {
  return rawfloat(s) * bound;
}

function bool(s) {
  return (bits(s) & 1) === 0;
}

var $$default = {
  st: [
    987910699,
    495797812,
    364182224,
    414272206,
    318284740,
    990407751,
    383018966,
    270373319,
    840823159,
    24560019,
    536292337,
    512266505,
    189156120,
    730249596,
    143776328,
    51606627,
    140166561,
    366354223,
    1003410265,
    700563762,
    981890670,
    913149062,
    526082594,
    1021425055,
    784300257,
    667753350,
    630144451,
    949649812,
    48546892,
    415514493,
    258888527,
    511570777,
    89983870,
    283659902,
    308386020,
    242688715,
    482270760,
    865188196,
    1027664170,
    207196989,
    193777847,
    619708188,
    671350186,
    149669678,
    257044018,
    87658204,
    558145612,
    183450813,
    28133145,
    901332182,
    710253903,
    510646120,
    652377910,
    409934019,
    801085050
  ],
  idx: 0
};

function bits$1(param) {
  return bits($$default);
}

function $$int$1(bound) {
  return $$int($$default, bound);
}

function int32$1$1(bound) {
  return int32$1($$default, bound);
}

function int64$1$1(bound) {
  return int64$1($$default, bound);
}

function $$float$1(scale) {
  return rawfloat($$default) * scale;
}

function bool$1(param) {
  return bool($$default);
}

function full_init$1(seed) {
  return full_init($$default, seed);
}

function init$4(seed) {
  return full_init($$default, [seed]);
}

function self_init(param) {
  return full_init$1(random_seed());
}

function get_state(param) {
  return copy$3($$default);
}

function set_state(s) {
  return assign($$default, s);
}

var State = {
  make: make$3,
  make_self_init: make_self_init,
  copy: copy$3,
  bits: bits,
  $$int: $$int,
  int32: int32$1,
  int64: int64$1,
  $$float: $$float,
  bool: bool
};

var init_1$4 = init$4;
var full_init_1 = full_init$1;
var self_init_1 = self_init;
var bits_1 = bits$1;
var $$int_1 = $$int$1;
var int32_1 = int32$1$1;
var int64_1 = int64$1$1;
var $$float_1 = $$float$1;
var bool_1 = bool$1;
var State_1 = State;
var get_state_1 = get_state;
var set_state_1 = set_state;
/* No side effect */

var random = {
	init: init_1$4,
	full_init: full_init_1,
	self_init: self_init_1,
	bits: bits_1,
	$$int: $$int_1,
	int32: int32_1,
	int64: int64_1,
	$$float: $$float_1,
	bool: bool_1,
	State: State_1,
	get_state: get_state_1,
	set_state: set_state_1
};

function is_val(l) {
  return l.LAZY_DONE;
}

var Undefined = caml_exceptions.create("CamlinternalLazy.Undefined");

function forward_with_closure(blk, closure) {
  var result = closure();
  blk.VAL = result;
  blk.LAZY_DONE = true;
  return result;
}

function raise_undefined() {
  throw {
        RE_EXN_ID: Undefined,
        Error: new Error()
      };
}

function force(lzv) {
  if (lzv.LAZY_DONE) {
    return lzv.VAL;
  } else {
    var closure = lzv.VAL;
    lzv.VAL = raise_undefined;
    try {
      return forward_with_closure(lzv, closure);
    }
    catch (e){
      lzv.VAL = (function () {
          throw e;
        });
      throw e;
    }
  }
}

function force_val(lzv) {
  if (lzv.LAZY_DONE) {
    return lzv.VAL;
  } else {
    var closure = lzv.VAL;
    lzv.VAL = raise_undefined;
    return forward_with_closure(lzv, closure);
  }
}

var Undefined_1 = Undefined;
var force_1 = force;
var force_val_1 = force_val;
var is_val_1 = is_val;
/* No side effect */

var camlinternalLazy = {
	Undefined: Undefined_1,
	force: force_1,
	force_val: force_val_1,
	is_val: is_val_1
};

function generic_basename(is_dir_sep, current_dir_name, name) {
  if (name === "") {
    return current_dir_name;
  } else {
    var _n = name.length - 1 | 0;
    while(true) {
      var n = _n;
      if (n < 0) {
        return string.sub(name, 0, 1);
      }
      if (!curry._2(is_dir_sep, name, n)) {
        var _n$1 = n;
        var p = n + 1 | 0;
        while(true) {
          var n$1 = _n$1;
          if (n$1 < 0) {
            return string.sub(name, 0, p);
          }
          if (curry._2(is_dir_sep, name, n$1)) {
            return string.sub(name, n$1 + 1 | 0, (p - n$1 | 0) - 1 | 0);
          }
          _n$1 = n$1 - 1 | 0;
          continue ;
        }      }
      _n = n - 1 | 0;
      continue ;
    }  }
}

function generic_dirname(is_dir_sep, current_dir_name, name) {
  if (name === "") {
    return current_dir_name;
  } else {
    var _n = name.length - 1 | 0;
    while(true) {
      var n = _n;
      if (n < 0) {
        return string.sub(name, 0, 1);
      }
      if (!curry._2(is_dir_sep, name, n)) {
        var _n$1 = n;
        while(true) {
          var n$1 = _n$1;
          if (n$1 < 0) {
            return current_dir_name;
          }
          if (curry._2(is_dir_sep, name, n$1)) {
            var _n$2 = n$1;
            while(true) {
              var n$2 = _n$2;
              if (n$2 < 0) {
                return string.sub(name, 0, 1);
              }
              if (!curry._2(is_dir_sep, name, n$2)) {
                return string.sub(name, 0, n$2 + 1 | 0);
              }
              _n$2 = n$2 - 1 | 0;
              continue ;
            }          }
          _n$1 = n$1 - 1 | 0;
          continue ;
        }      }
      _n = n - 1 | 0;
      continue ;
    }  }
}

var current_dir_name = ".";

function is_dir_sep(s, i) {
  return caml_string.get(s, i) === /* "/" */47;
}

function is_relative(n) {
  if (n.length < 1) {
    return true;
  } else {
    return caml_string.get(n, 0) !== /* "/" */47;
  }
}

function is_implicit(n) {
  if (is_relative(n) && (n.length < 2 || string.sub(n, 0, 2) !== "./")) {
    if (n.length < 3) {
      return true;
    } else {
      return string.sub(n, 0, 3) !== "../";
    }
  } else {
    return false;
  }
}

function check_suffix(name, suff) {
  if (name.length >= suff.length) {
    return string.sub(name, name.length - suff.length | 0, suff.length) === suff;
  } else {
    return false;
  }
}

var temp_dir_name;

try {
  temp_dir_name = caml_sys.caml_sys_getenv("TMPDIR");
}
catch (raw_exn){
  var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
  if (exn.RE_EXN_ID === "Not_found") {
    temp_dir_name = "/tmp";
  } else {
    throw exn;
  }
}

function quote(param) {
  var quotequote = "'\\''";
  var l = param.length;
  var b = buffer.create(l + 20 | 0);
  buffer.add_char(b, /* "'" */39);
  for(var i = 0; i < l; ++i){
    if (caml_string.get(param, i) === /* "'" */39) {
      buffer.add_string(b, quotequote);
    } else {
      buffer.add_char(b, caml_string.get(param, i));
    }
  }
  buffer.add_char(b, /* "'" */39);
  return buffer.contents(b);
}

function basename(param) {
  return generic_basename(is_dir_sep, current_dir_name, param);
}

function dirname(param) {
  return generic_dirname(is_dir_sep, current_dir_name, param);
}

var current_dir_name$1 = ".";

function is_dir_sep$1(s, i) {
  var c = caml_string.get(s, i);
  if (c === /* "/" */47 || c === /* "\\" */92) {
    return true;
  } else {
    return c === /* ":" */58;
  }
}

function is_relative$1(n) {
  if ((n.length < 1 || caml_string.get(n, 0) !== /* "/" */47) && (n.length < 1 || caml_string.get(n, 0) !== /* "\\" */92)) {
    if (n.length < 2) {
      return true;
    } else {
      return caml_string.get(n, 1) !== /* ":" */58;
    }
  } else {
    return false;
  }
}

function is_implicit$1(n) {
  if (is_relative$1(n) && (n.length < 2 || string.sub(n, 0, 2) !== "./") && (n.length < 2 || string.sub(n, 0, 2) !== ".\\") && (n.length < 3 || string.sub(n, 0, 3) !== "../")) {
    if (n.length < 3) {
      return true;
    } else {
      return string.sub(n, 0, 3) !== "..\\";
    }
  } else {
    return false;
  }
}

function check_suffix$1(name, suff) {
  if (name.length < suff.length) {
    return false;
  }
  var s = string.sub(name, name.length - suff.length | 0, suff.length);
  return caml_bytes.bytes_to_string(bytes.lowercase_ascii(caml_bytes.bytes_of_string(s))) === caml_bytes.bytes_to_string(bytes.lowercase_ascii(caml_bytes.bytes_of_string(suff)));
}

var temp_dir_name$1;

try {
  temp_dir_name$1 = caml_sys.caml_sys_getenv("TEMP");
}
catch (raw_exn$1){
  var exn$1 = caml_js_exceptions.internalToOCamlException(raw_exn$1);
  if (exn$1.RE_EXN_ID === "Not_found") {
    temp_dir_name$1 = ".";
  } else {
    throw exn$1;
  }
}

function quote$1(s) {
  var l = s.length;
  var b = buffer.create(l + 20 | 0);
  buffer.add_char(b, /* "\"" */34);
  var loop = function (_i) {
    while(true) {
      var i = _i;
      if (i === l) {
        return buffer.add_char(b, /* "\"" */34);
      }
      var c = caml_string.get(s, i);
      if (c === 34) {
        return loop_bs(0, i);
      }
      if (c === 92) {
        return loop_bs(0, i);
      }
      buffer.add_char(b, c);
      _i = i + 1 | 0;
      continue ;
    }  };
  var loop_bs = function (_n, _i) {
    while(true) {
      var i = _i;
      var n = _n;
      if (i === l) {
        buffer.add_char(b, /* "\"" */34);
        return add_bs(n);
      }
      var match = caml_string.get(s, i);
      if (match !== 34) {
        if (match !== 92) {
          add_bs(n);
          return loop(i);
        }
        _i = i + 1 | 0;
        _n = n + 1 | 0;
        continue ;
      }
      add_bs((n << 1) + 1 | 0);
      buffer.add_char(b, /* "\"" */34);
      return loop(i + 1 | 0);
    }  };
  var add_bs = function (n) {
    for(var _j = 1; _j <= n; ++_j){
      buffer.add_char(b, /* "\\" */92);
    }
    
  };
  loop(0);
  return buffer.contents(b);
}

function has_drive(s) {
  var is_letter = function (param) {
    if (param >= 91) {
      return !(param > 122 || param < 97);
    } else {
      return param >= 65;
    }
  };
  if (s.length >= 2 && is_letter(caml_string.get(s, 0))) {
    return caml_string.get(s, 1) === /* ":" */58;
  } else {
    return false;
  }
}

function drive_and_path(s) {
  if (has_drive(s)) {
    return [
            string.sub(s, 0, 2),
            string.sub(s, 2, s.length - 2 | 0)
          ];
  } else {
    return [
            "",
            s
          ];
  }
}

function dirname$1(s) {
  var match = drive_and_path(s);
  var dir = generic_dirname(is_dir_sep$1, current_dir_name$1, match[1]);
  return match[0] + dir;
}

function basename$1(s) {
  var match = drive_and_path(s);
  return generic_basename(is_dir_sep$1, current_dir_name$1, match[1]);
}

var current_dir_name$2 = ".";

function basename$2(param) {
  return generic_basename(is_dir_sep$1, current_dir_name$2, param);
}

function dirname$2(param) {
  return generic_dirname(is_dir_sep$1, current_dir_name$2, param);
}

var match$1;

switch (sys.os_type) {
  case "Cygwin" :
      match$1 = [
        current_dir_name$2,
        "..",
        "/",
        is_dir_sep$1,
        is_relative$1,
        is_implicit$1,
        check_suffix$1,
        temp_dir_name,
        quote,
        basename$2,
        dirname$2
      ];
      break;
  case "Win32" :
      match$1 = [
        current_dir_name$1,
        "..",
        "\\",
        is_dir_sep$1,
        is_relative$1,
        is_implicit$1,
        check_suffix$1,
        temp_dir_name$1,
        quote$1,
        basename$1,
        dirname$1
      ];
      break;
  default:
    match$1 = [
      current_dir_name,
      "..",
      "/",
      is_dir_sep,
      is_relative,
      is_implicit,
      check_suffix,
      temp_dir_name,
      quote,
      basename,
      dirname
    ];
}

var temp_dir_name$2 = match$1[7];

var is_dir_sep$2 = match$1[3];

var dir_sep = match$1[2];

function concat$4(dirname, filename) {
  var l = dirname.length;
  if (l === 0 || curry._2(is_dir_sep$2, dirname, l - 1 | 0)) {
    return dirname + filename;
  } else {
    return dirname + (dir_sep + filename);
  }
}

function chop_suffix(name, suff) {
  var n = name.length - suff.length | 0;
  if (n < 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Filename.chop_suffix",
          Error: new Error()
        };
  }
  return string.sub(name, 0, n);
}

function extension_len(name) {
  var _i = name.length - 1 | 0;
  while(true) {
    var i = _i;
    if (i < 0 || curry._2(is_dir_sep$2, name, i)) {
      return 0;
    }
    if (caml_string.get(name, i) === /* "." */46) {
      var _i$1 = i - 1 | 0;
      while(true) {
        var i$1 = _i$1;
        if (i$1 < 0 || curry._2(is_dir_sep$2, name, i$1)) {
          return 0;
        }
        if (caml_string.get(name, i$1) !== /* "." */46) {
          return name.length - i | 0;
        }
        _i$1 = i$1 - 1 | 0;
        continue ;
      }    }
    _i = i - 1 | 0;
    continue ;
  }}

function extension(name) {
  var l = extension_len(name);
  if (l === 0) {
    return "";
  } else {
    return string.sub(name, name.length - l | 0, l);
  }
}

function chop_extension(name) {
  var l = extension_len(name);
  if (l === 0) {
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Filename.chop_extension",
          Error: new Error()
        };
  }
  return string.sub(name, 0, name.length - l | 0);
}

function remove_extension(name) {
  var l = extension_len(name);
  if (l === 0) {
    return name;
  } else {
    return string.sub(name, 0, name.length - l | 0);
  }
}

var prng = {
  LAZY_DONE: false,
  VAL: (function () {
      return random.State.make_self_init(undefined);
    })
};

function temp_file_name(temp_dir, prefix, suffix) {
  var rnd = random.State.bits(camlinternalLazy.force(prng)) & 16777215;
  return concat$4(temp_dir, curry._3(printf_1.sprintf(/* Format */{
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_x */6,
                          _1: {
                            TAG: /* Lit_padding */0,
                            _0: /* Zeros */2,
                            _1: 6
                          },
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "%s%06x%s"
                    }), prefix, rnd, suffix));
}

var current_temp_dir_name = {
  contents: temp_dir_name$2
};

function set_temp_dir_name(s) {
  current_temp_dir_name.contents = s;
  
}

function get_temp_dir_name(param) {
  return current_temp_dir_name.contents;
}

function temp_file(temp_dirOpt, prefix, suffix) {
  var temp_dir = temp_dirOpt !== undefined ? temp_dirOpt : current_temp_dir_name.contents;
  var _counter = 0;
  while(true) {
    var counter = _counter;
    var name = temp_file_name(temp_dir, prefix, suffix);
    try {
      caml_external_polyfill.resolve("caml_sys_close")(caml_external_polyfill.resolve("caml_sys_open")(name, {
                hd: /* Open_wronly */1,
                tl: {
                  hd: /* Open_creat */3,
                  tl: {
                    hd: /* Open_excl */5,
                    tl: /* [] */0
                  }
                }
              }, 384));
      return name;
    }
    catch (raw_e){
      var e = caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === "Sys_error") {
        if (counter >= 1000) {
          throw e;
        }
        _counter = counter + 1 | 0;
        continue ;
      }
      throw e;
    }
  }}

function open_temp_file(modeOpt, permsOpt, temp_dirOpt, prefix, suffix) {
  var mode = modeOpt !== undefined ? modeOpt : ({
        hd: /* Open_text */7,
        tl: /* [] */0
      });
  var perms = permsOpt !== undefined ? permsOpt : 384;
  var temp_dir = temp_dirOpt !== undefined ? temp_dirOpt : current_temp_dir_name.contents;
  var _counter = 0;
  while(true) {
    var counter = _counter;
    var name = temp_file_name(temp_dir, prefix, suffix);
    try {
      return [
              name,
              pervasives.open_out_gen({
                    hd: /* Open_wronly */1,
                    tl: {
                      hd: /* Open_creat */3,
                      tl: {
                        hd: /* Open_excl */5,
                        tl: mode
                      }
                    }
                  }, perms, name)
            ];
    }
    catch (raw_e){
      var e = caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === "Sys_error") {
        if (counter >= 1000) {
          throw e;
        }
        _counter = counter + 1 | 0;
        continue ;
      }
      throw e;
    }
  }}

var current_dir_name$3 = match$1[0];

var parent_dir_name = match$1[1];

var is_relative$2 = match$1[4];

var is_implicit$2 = match$1[5];

var check_suffix$2 = match$1[6];

var basename$3 = match$1[9];

var dirname$3 = match$1[10];

var quote$2 = match$1[8];

var current_dir_name_1 = current_dir_name$3;
var parent_dir_name_1 = parent_dir_name;
var dir_sep_1 = dir_sep;
var concat_1$4 = concat$4;
var is_relative_1 = is_relative$2;
var is_implicit_1 = is_implicit$2;
var check_suffix_1 = check_suffix$2;
var chop_suffix_1 = chop_suffix;
var extension_1 = extension;
var remove_extension_1 = remove_extension;
var chop_extension_1 = chop_extension;
var basename_1 = basename$3;
var dirname_1 = dirname$3;
var temp_file_1 = temp_file;
var open_temp_file_1 = open_temp_file;
var get_temp_dir_name_1 = get_temp_dir_name;
var set_temp_dir_name_1 = set_temp_dir_name;
var temp_dir_name_1 = temp_dir_name$2;
var quote_1 = quote$2;
/* temp_dir_name Not a pure module */

var filename = {
	current_dir_name: current_dir_name_1,
	parent_dir_name: parent_dir_name_1,
	dir_sep: dir_sep_1,
	concat: concat_1$4,
	is_relative: is_relative_1,
	is_implicit: is_implicit_1,
	check_suffix: check_suffix_1,
	chop_suffix: chop_suffix_1,
	extension: extension_1,
	remove_extension: remove_extension_1,
	chop_extension: chop_extension_1,
	basename: basename_1,
	dirname: dirname_1,
	temp_file: temp_file_1,
	open_temp_file: open_temp_file_1,
	get_temp_dir_name: get_temp_dir_name_1,
	set_temp_dir_name: set_temp_dir_name_1,
	temp_dir_name: temp_dir_name_1,
	quote: quote_1
};

function from_lb_p(source, start, _end) {
  return {
          source: source,
          start: {
            line: start.pos_lnum,
            column: start.pos_cnum - start.pos_bol | 0,
            offset: start.pos_cnum
          },
          _end: {
            line: _end.pos_lnum,
            column: caml_primitive.caml_int_max(0, _end.pos_cnum - _end.pos_bol | 0),
            offset: _end.pos_cnum
          }
        };
}

function from_lb(source, lb) {
  var start = lexing.lexeme_start_p(lb);
  var _end = lexing.lexeme_end_p(lb);
  return from_lb_p(source, start, _end);
}

function from_curr_lb(source, lb) {
  var curr = lb.lex_curr_p;
  return from_lb_p(source, curr, curr);
}

function btwn(loc1, loc2) {
  return {
          source: loc1.source,
          start: loc1.start,
          _end: loc2._end
        };
}

function btwn_exclusive(loc1, loc2) {
  return {
          source: loc1.source,
          start: loc1._end,
          _end: loc2.start
        };
}

function char_before(loc) {
  var match = loc.start;
  var offset = match.offset;
  var column = match.column;
  var match$1 = column > 0 ? [
      column - 1 | 0,
      offset - 1 | 0
    ] : [
      column,
      offset
    ];
  var start_line = match.line;
  var start_column = match$1[0];
  var start_offset = match$1[1];
  var start = {
    line: start_line,
    column: start_column,
    offset: start_offset
  };
  var _end = loc.start;
  return {
          source: loc.source,
          start: start,
          _end: _end
        };
}

function contains$2(loc1, loc2) {
  if (caml_obj.caml_equal(loc1.source, loc2.source) && loc1.start.offset <= loc2.start.offset) {
    return loc1._end.offset >= loc2._end.offset;
  } else {
    return false;
  }
}

function string_of_filename(param) {
  if (typeof param === "number") {
    return "(global)";
  } else {
    return param._0;
  }
}

function order_of_filename(param) {
  if (typeof param === "number") {
    return 1;
  }
  switch (param.TAG | 0) {
    case /* LibFile */0 :
        return 2;
    case /* SourceFile */1 :
    case /* JsonFile */2 :
        return 3;
    case /* ResourceFile */3 :
        return 4;
    
  }
}

function source_cmp(a, b) {
  if (a === undefined) {
    if (b !== undefined) {
      return 1;
    } else {
      return 0;
    }
  }
  if (b === undefined) {
    return -1;
  }
  var k = order_of_filename(a) - order_of_filename(b) | 0;
  if (k !== 0) {
    return k;
  } else {
    return string.compare(string_of_filename(a), string_of_filename(b));
  }
}

function pos_cmp(a, b) {
  var k = a.line - b.line | 0;
  if (k === 0) {
    return a.column - b.column | 0;
  } else {
    return k;
  }
}

function compare$7(loc1, loc2) {
  var k = source_cmp(loc1.source, loc2.source);
  if (k !== 0) {
    return k;
  }
  var k$1 = pos_cmp(loc1.start, loc2.start);
  if (k$1 === 0) {
    return pos_cmp(loc1._end, loc2._end);
  } else {
    return k$1;
  }
}

function to_string$4(include_sourceOpt, loc) {
  var include_source = include_sourceOpt !== undefined ? include_sourceOpt : false;
  var source;
  if (include_source) {
    var src = loc.source;
    source = curry._1(printf_1.sprintf(/* Format */{
              _0: {
                TAG: /* Caml_string */3,
                _0: /* No_padding */0,
                _1: {
                  TAG: /* String_literal */11,
                  _0: ": ",
                  _1: /* End_of_format */0
                }
              },
              _1: "%S: "
            }), src !== undefined ? string_of_filename(src) : "<NONE>");
  } else {
    source = "";
  }
  var pos = curry._4(printf_1.sprintf(/* Format */{
            _0: {
              TAG: /* Char_literal */12,
              _0: /* "(" */40,
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* String_literal */11,
                  _0: ", ",
                  _1: {
                    TAG: /* Int */4,
                    _0: /* Int_d */0,
                    _1: /* No_padding */0,
                    _2: /* No_precision */0,
                    _3: {
                      TAG: /* String_literal */11,
                      _0: ") to (",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ", ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* Char_literal */12,
                              _0: /* ")" */41,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            _1: "(%d, %d) to (%d, %d)"
          }), loc.start.line, loc.start.column, loc._end.line, loc._end.column);
  return source + pos;
}

function source(loc) {
  return loc.source;
}

function source_is_lib_file(param) {
  if (typeof param === "number" || param.TAG === /* LibFile */0) {
    return true;
  } else {
    return false;
  }
}

function filename_map(f, filename) {
  if (typeof filename === "number") {
    return /* Builtins */0;
  }
  switch (filename.TAG | 0) {
    case /* LibFile */0 :
        return {
                TAG: /* LibFile */0,
                _0: curry._1(f, filename._0)
              };
    case /* SourceFile */1 :
        return {
                TAG: /* SourceFile */1,
                _0: curry._1(f, filename._0)
              };
    case /* JsonFile */2 :
        return {
                TAG: /* JsonFile */2,
                _0: curry._1(f, filename._0)
              };
    case /* ResourceFile */3 :
        return {
                TAG: /* ResourceFile */3,
                _0: curry._1(f, filename._0)
              };
    
  }
}

function check_suffix$3(filename$1, suffix) {
  var f = function (fn) {
    return curry._2(filename.check_suffix, fn, suffix);
  };
  if (typeof filename$1 === "number") {
    return false;
  } else {
    return curry._1(f, filename$1._0);
  }
}

function chop_suffix$1(filename$1, suffix) {
  return filename_map((function (fn) {
                return filename.chop_suffix(fn, suffix);
              }), filename$1);
}

function with_suffix(filename, suffix) {
  return filename_map((function (fn) {
                return fn + suffix;
              }), filename);
}

var compare$1$1 = caml_obj.caml_compare;

var FilenameKey = {
  to_string: string_of_filename,
  compare: compare$1$1
};

var none = {
  source: undefined,
  start: {
    line: 0,
    column: 0,
    offset: 0
  },
  _end: {
    line: 0,
    column: 0,
    offset: 0
  }
};

var none_1 = none;
var from_lb_1 = from_lb;
var from_curr_lb_1 = from_curr_lb;
var btwn_1 = btwn;
var btwn_exclusive_1 = btwn_exclusive;
var char_before_1 = char_before;
var contains_1$2 = contains$2;
var filename_map_1 = filename_map;
var string_of_filename_1 = string_of_filename;
var compare_1$7 = compare$7;
var to_string_1$4 = to_string$4;
var source_1 = source;
var source_is_lib_file_1 = source_is_lib_file;
var check_suffix_1$1 = check_suffix$3;
var chop_suffix_1$1 = chop_suffix$1;
var with_suffix_1 = with_suffix;
var FilenameKey_1 = FilenameKey;
/* Filename Not a pure module */

var loc_bs = {
	none: none_1,
	from_lb: from_lb_1,
	from_curr_lb: from_curr_lb_1,
	btwn: btwn_1,
	btwn_exclusive: btwn_exclusive_1,
	char_before: char_before_1,
	contains: contains_1$2,
	filename_map: filename_map_1,
	string_of_filename: string_of_filename_1,
	compare: compare_1$7,
	to_string: to_string_1$4,
	source: source_1,
	source_is_lib_file: source_is_lib_file_1,
	check_suffix: check_suffix_1$1,
	chop_suffix: chop_suffix_1$1,
	with_suffix: with_suffix_1,
	FilenameKey: FilenameKey_1
};

function Make(funarg) {
  var height = function (param) {
    if (param) {
      return param.h;
    } else {
      return 0;
    }
  };
  var create = function (l, v, r) {
    var hl = l ? l.h : 0;
    var hr = r ? r.h : 0;
    return /* Node */{
            l: l,
            v: v,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  };
  var bal = function (l, v, r) {
    var hl = l ? l.h : 0;
    var hr = r ? r.h : 0;
    if (hl > (hr + 2 | 0)) {
      if (l) {
        var lr = l.r;
        var lv = l.v;
        var ll = l.l;
        if (height(ll) >= height(lr)) {
          return create(ll, lv, create(lr, v, r));
        }
        if (lr) {
          return create(create(ll, lv, lr.l), lr.v, create(lr.r, v, r));
        }
        throw {
              RE_EXN_ID: "Invalid_argument",
              _1: "Set.bal",
              Error: new Error()
            };
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "Set.bal",
            Error: new Error()
          };
    }
    if (hr <= (hl + 2 | 0)) {
      return /* Node */{
              l: l,
              v: v,
              r: r,
              h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            };
    }
    if (r) {
      var rr = r.r;
      var rv = r.v;
      var rl = r.l;
      if (height(rr) >= height(rl)) {
        return create(create(l, v, rl), rv, rr);
      }
      if (rl) {
        return create(create(l, v, rl.l), rl.v, create(rl.r, rv, rr));
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "Set.bal",
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Set.bal",
          Error: new Error()
        };
  };
  var add = function (x, t) {
    if (!t) {
      return /* Node */{
              l: /* Empty */0,
              v: x,
              r: /* Empty */0,
              h: 1
            };
    }
    var r = t.r;
    var v = t.v;
    var l = t.l;
    var c = curry._2(funarg.compare, x, v);
    if (c === 0) {
      return t;
    }
    if (c < 0) {
      var ll = add(x, l);
      if (l === ll) {
        return t;
      } else {
        return bal(ll, v, r);
      }
    }
    var rr = add(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal(l, v, rr);
    }
  };
  var singleton = function (x) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            r: /* Empty */0,
            h: 1
          };
  };
  var add_min_element = function (x, param) {
    if (param) {
      return bal(add_min_element(x, param.l), param.v, param.r);
    } else {
      return singleton(x);
    }
  };
  var add_max_element = function (x, param) {
    if (param) {
      return bal(param.l, param.v, add_max_element(x, param.r));
    } else {
      return singleton(x);
    }
  };
  var join = function (l, v, r) {
    if (!l) {
      return add_min_element(v, r);
    }
    if (!r) {
      return add_max_element(v, l);
    }
    var rh = r.h;
    var lh = l.h;
    if (lh > (rh + 2 | 0)) {
      return bal(l.l, l.v, join(l.r, v, r));
    } else if (rh > (lh + 2 | 0)) {
      return bal(join(l, v, r.l), r.v, r.r);
    } else {
      return create(l, v, r);
    }
  };
  var min_elt = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param.l;
        if (!l) {
          return param.v;
        }
        _param = l;
        continue ;
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }  };
  var min_elt_opt = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var l = param.l;
      if (!l) {
        return caml_option.some(param.v);
      }
      _param = l;
      continue ;
    }  };
  var max_elt = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var r = param.r;
        if (!r) {
          return param.v;
        }
        _param = r;
        continue ;
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }  };
  var max_elt_opt = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var r = param.r;
      if (!r) {
        return caml_option.some(param.v);
      }
      _param = r;
      continue ;
    }  };
  var remove_min_elt = function (param) {
    if (param) {
      var l = param.l;
      if (l) {
        return bal(remove_min_elt(l), param.v, param.r);
      } else {
        return param.r;
      }
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Set.remove_min_elt",
          Error: new Error()
        };
  };
  var concat = function (t1, t2) {
    if (t1) {
      if (t2) {
        return join(t1, min_elt(t2), remove_min_elt(t2));
      } else {
        return t1;
      }
    } else {
      return t2;
    }
  };
  var split = function (x, param) {
    if (!param) {
      return [
              /* Empty */0,
              false,
              /* Empty */0
            ];
    }
    var r = param.r;
    var v = param.v;
    var l = param.l;
    var c = curry._2(funarg.compare, x, v);
    if (c === 0) {
      return [
              l,
              true,
              r
            ];
    }
    if (c < 0) {
      var match = split(x, l);
      return [
              match[0],
              match[1],
              join(match[2], v, r)
            ];
    }
    var match$1 = split(x, r);
    return [
            join(l, v, match$1[0]),
            match$1[1],
            match$1[2]
          ];
  };
  var is_empty = function (param) {
    if (param) {
      return false;
    } else {
      return true;
    }
  };
  var mem = function (x, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      var c = curry._2(funarg.compare, x, param.v);
      if (c === 0) {
        return true;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }  };
  var remove = function (x, t) {
    if (!t) {
      return /* Empty */0;
    }
    var r = t.r;
    var v = t.v;
    var l = t.l;
    var c = curry._2(funarg.compare, x, v);
    if (c === 0) {
      if (l) {
        if (r) {
          return bal(l, min_elt(r), remove_min_elt(r));
        } else {
          return l;
        }
      } else {
        return r;
      }
    }
    if (c < 0) {
      var ll = remove(x, l);
      if (l === ll) {
        return t;
      } else {
        return bal(ll, v, r);
      }
    }
    var rr = remove(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal(l, v, rr);
    }
  };
  var union = function (s1, s2) {
    if (!s1) {
      return s2;
    }
    if (!s2) {
      return s1;
    }
    var h2 = s2.h;
    var v2 = s2.v;
    var h1 = s1.h;
    var v1 = s1.v;
    if (h1 >= h2) {
      if (h2 === 1) {
        return add(v2, s1);
      }
      var match = split(v1, s2);
      return join(union(s1.l, match[0]), v1, union(s1.r, match[2]));
    }
    if (h1 === 1) {
      return add(v1, s2);
    }
    var match$1 = split(v2, s1);
    return join(union(match$1[0], s2.l), v2, union(match$1[2], s2.r));
  };
  var inter = function (s1, s2) {
    if (!s1) {
      return /* Empty */0;
    }
    if (!s2) {
      return /* Empty */0;
    }
    var r1 = s1.r;
    var v1 = s1.v;
    var l1 = s1.l;
    var match = split(v1, s2);
    var l2 = match[0];
    if (match[1]) {
      return join(inter(l1, l2), v1, inter(r1, match[2]));
    } else {
      return concat(inter(l1, l2), inter(r1, match[2]));
    }
  };
  var diff = function (s1, s2) {
    if (!s1) {
      return /* Empty */0;
    }
    if (!s2) {
      return s1;
    }
    var r1 = s1.r;
    var v1 = s1.v;
    var l1 = s1.l;
    var match = split(v1, s2);
    var l2 = match[0];
    if (match[1]) {
      return concat(diff(l1, l2), diff(r1, match[2]));
    } else {
      return join(diff(l1, l2), v1, diff(r1, match[2]));
    }
  };
  var cons_enum = function (_s, _e) {
    while(true) {
      var e = _e;
      var s = _s;
      if (!s) {
        return e;
      }
      _e = /* More */{
        _0: s.v,
        _1: s.r,
        _2: e
      };
      _s = s.l;
      continue ;
    }  };
  var compare = function (s1, s2) {
    var _e1 = cons_enum(s1, /* End */0);
    var _e2 = cons_enum(s2, /* End */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (!e1) {
        if (e2) {
          return -1;
        } else {
          return 0;
        }
      }
      if (!e2) {
        return 1;
      }
      var c = curry._2(funarg.compare, e1._0, e2._0);
      if (c !== 0) {
        return c;
      }
      _e2 = cons_enum(e2._1, e2._2);
      _e1 = cons_enum(e1._1, e1._2);
      continue ;
    }  };
  var equal = function (s1, s2) {
    return compare(s1, s2) === 0;
  };
  var subset = function (_s1, _s2) {
    while(true) {
      var s2 = _s2;
      var s1 = _s1;
      if (!s1) {
        return true;
      }
      if (!s2) {
        return false;
      }
      var r2 = s2.r;
      var l2 = s2.l;
      var r1 = s1.r;
      var v1 = s1.v;
      var l1 = s1.l;
      var c = curry._2(funarg.compare, v1, s2.v);
      if (c === 0) {
        if (!subset(l1, l2)) {
          return false;
        }
        _s2 = r2;
        _s1 = r1;
        continue ;
      }
      if (c < 0) {
        if (!subset(/* Node */{
                l: l1,
                v: v1,
                r: /* Empty */0,
                h: 0
              }, l2)) {
          return false;
        }
        _s1 = r1;
        continue ;
      }
      if (!subset(/* Node */{
              l: /* Empty */0,
              v: v1,
              r: r1,
              h: 0
            }, r2)) {
        return false;
      }
      _s1 = l1;
      continue ;
    }  };
  var iter = function (f, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      iter(f, param.l);
      curry._1(f, param.v);
      _param = param.r;
      continue ;
    }  };
  var fold = function (f, _s, _accu) {
    while(true) {
      var accu = _accu;
      var s = _s;
      if (!s) {
        return accu;
      }
      _accu = curry._2(f, s.v, fold(f, s.l, accu));
      _s = s.r;
      continue ;
    }  };
  var for_all = function (p, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return true;
      }
      if (!curry._1(p, param.v)) {
        return false;
      }
      if (!for_all(p, param.l)) {
        return false;
      }
      _param = param.r;
      continue ;
    }  };
  var exists = function (p, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (curry._1(p, param.v)) {
        return true;
      }
      if (exists(p, param.l)) {
        return true;
      }
      _param = param.r;
      continue ;
    }  };
  var filter = function (p, t) {
    if (!t) {
      return /* Empty */0;
    }
    var r = t.r;
    var v = t.v;
    var l = t.l;
    var l$prime = filter(p, l);
    var pv = curry._1(p, v);
    var r$prime = filter(p, r);
    if (pv) {
      if (l === l$prime && r === r$prime) {
        return t;
      } else {
        return join(l$prime, v, r$prime);
      }
    } else {
      return concat(l$prime, r$prime);
    }
  };
  var partition = function (p, param) {
    if (!param) {
      return [
              /* Empty */0,
              /* Empty */0
            ];
    }
    var v = param.v;
    var match = partition(p, param.l);
    var lf = match[1];
    var lt = match[0];
    var pv = curry._1(p, v);
    var match$1 = partition(p, param.r);
    var rf = match$1[1];
    var rt = match$1[0];
    if (pv) {
      return [
              join(lt, v, rt),
              concat(lf, rf)
            ];
    } else {
      return [
              concat(lt, rt),
              join(lf, v, rf)
            ];
    }
  };
  var cardinal = function (param) {
    if (param) {
      return (cardinal(param.l) + 1 | 0) + cardinal(param.r) | 0;
    } else {
      return 0;
    }
  };
  var elements_aux = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param.l;
      _accu = {
        hd: param.v,
        tl: elements_aux(accu, param.r)
      };
      continue ;
    }  };
  var elements = function (s) {
    return elements_aux(/* [] */0, s);
  };
  var find = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param.v;
        var c = curry._2(funarg.compare, x, v);
        if (c === 0) {
          return v;
        }
        _param = c < 0 ? param.l : param.r;
        continue ;
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }  };
  var find_first = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param.v;
        if (curry._1(f, v)) {
          var _v0 = v;
          var _param$1 = param.l;
          while(true) {
            var param$1 = _param$1;
            var v0 = _v0;
            if (!param$1) {
              return v0;
            }
            var v$1 = param$1.v;
            if (curry._1(f, v$1)) {
              _param$1 = param$1.l;
              _v0 = v$1;
              continue ;
            }
            _param$1 = param$1.r;
            continue ;
          }        }
        _param = param.r;
        continue ;
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }  };
  var find_first_opt = function (f, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var v = param.v;
      if (curry._1(f, v)) {
        var _v0 = v;
        var _param$1 = param.l;
        while(true) {
          var param$1 = _param$1;
          var v0 = _v0;
          if (!param$1) {
            return caml_option.some(v0);
          }
          var v$1 = param$1.v;
          if (curry._1(f, v$1)) {
            _param$1 = param$1.l;
            _v0 = v$1;
            continue ;
          }
          _param$1 = param$1.r;
          continue ;
        }      }
      _param = param.r;
      continue ;
    }  };
  var find_last = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param.v;
        if (curry._1(f, v)) {
          var _v0 = v;
          var _param$1 = param.r;
          while(true) {
            var param$1 = _param$1;
            var v0 = _v0;
            if (!param$1) {
              return v0;
            }
            var v$1 = param$1.v;
            if (curry._1(f, v$1)) {
              _param$1 = param$1.r;
              _v0 = v$1;
              continue ;
            }
            _param$1 = param$1.l;
            continue ;
          }        }
        _param = param.l;
        continue ;
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }  };
  var find_last_opt = function (f, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var v = param.v;
      if (curry._1(f, v)) {
        var _v0 = v;
        var _param$1 = param.r;
        while(true) {
          var param$1 = _param$1;
          var v0 = _v0;
          if (!param$1) {
            return caml_option.some(v0);
          }
          var v$1 = param$1.v;
          if (curry._1(f, v$1)) {
            _param$1 = param$1.r;
            _v0 = v$1;
            continue ;
          }
          _param$1 = param$1.l;
          continue ;
        }      }
      _param = param.l;
      continue ;
    }  };
  var find_opt = function (x, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var v = param.v;
      var c = curry._2(funarg.compare, x, v);
      if (c === 0) {
        return caml_option.some(v);
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }  };
  var map = function (f, t) {
    if (!t) {
      return /* Empty */0;
    }
    var r = t.r;
    var v = t.v;
    var l = t.l;
    var l$prime = map(f, l);
    var v$prime = curry._1(f, v);
    var r$prime = map(f, r);
    if (l === l$prime && v === v$prime && r === r$prime) {
      return t;
    } else if ((l$prime === /* Empty */0 || curry._2(funarg.compare, max_elt(l$prime), v$prime) < 0) && (r$prime === /* Empty */0 || curry._2(funarg.compare, v$prime, min_elt(r$prime)) < 0)) {
      return join(l$prime, v$prime, r$prime);
    } else {
      return union(l$prime, add(v$prime, r$prime));
    }
  };
  var of_list = function (l) {
    if (!l) {
      return /* Empty */0;
    }
    var match = l.tl;
    var x0 = l.hd;
    if (!match) {
      return singleton(x0);
    }
    var match$1 = match.tl;
    var x1 = match.hd;
    if (!match$1) {
      return add(x1, singleton(x0));
    }
    var match$2 = match$1.tl;
    var x2 = match$1.hd;
    if (!match$2) {
      return add(x2, add(x1, singleton(x0)));
    }
    var match$3 = match$2.tl;
    var x3 = match$2.hd;
    if (match$3) {
      if (match$3.tl) {
        var l$1 = list.sort_uniq(funarg.compare, l);
        var sub = function (n, l) {
          switch (n) {
            case 0 :
                return [
                        /* Empty */0,
                        l
                      ];
            case 1 :
                if (l) {
                  return [
                          /* Node */{
                            l: /* Empty */0,
                            v: l.hd,
                            r: /* Empty */0,
                            h: 1
                          },
                          l.tl
                        ];
                }
                break;
            case 2 :
                if (l) {
                  var match = l.tl;
                  if (match) {
                    return [
                            /* Node */{
                              l: /* Node */{
                                l: /* Empty */0,
                                v: l.hd,
                                r: /* Empty */0,
                                h: 1
                              },
                              v: match.hd,
                              r: /* Empty */0,
                              h: 2
                            },
                            match.tl
                          ];
                  }
                  
                }
                break;
            case 3 :
                if (l) {
                  var match$1 = l.tl;
                  if (match$1) {
                    var match$2 = match$1.tl;
                    if (match$2) {
                      return [
                              /* Node */{
                                l: /* Node */{
                                  l: /* Empty */0,
                                  v: l.hd,
                                  r: /* Empty */0,
                                  h: 1
                                },
                                v: match$1.hd,
                                r: /* Node */{
                                  l: /* Empty */0,
                                  v: match$2.hd,
                                  r: /* Empty */0,
                                  h: 1
                                },
                                h: 2
                              },
                              match$2.tl
                            ];
                    }
                    
                  }
                  
                }
                break;
              
          }
          var nl = n / 2 | 0;
          var match$3 = sub(nl, l);
          var l$1 = match$3[1];
          if (l$1) {
            var match$4 = sub((n - nl | 0) - 1 | 0, l$1.tl);
            return [
                    create(match$3[0], l$1.hd, match$4[0]),
                    match$4[1]
                  ];
          }
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "set.ml",
                  510,
                  18
                ],
                Error: new Error()
              };
        };
        return sub(list.length(l$1), l$1)[0];
      } else {
        return add(match$3.hd, add(x3, add(x2, add(x1, singleton(x0)))));
      }
    } else {
      return add(x3, add(x2, add(x1, singleton(x0))));
    }
  };
  return {
          empty: /* Empty */0,
          is_empty: is_empty,
          mem: mem,
          add: add,
          singleton: singleton,
          remove: remove,
          union: union,
          inter: inter,
          diff: diff,
          compare: compare,
          equal: equal,
          subset: subset,
          iter: iter,
          map: map,
          fold: fold,
          for_all: for_all,
          exists: exists,
          filter: filter,
          partition: partition,
          cardinal: cardinal,
          elements: elements,
          min_elt: min_elt,
          min_elt_opt: min_elt_opt,
          max_elt: max_elt,
          max_elt_opt: max_elt_opt,
          choose: min_elt,
          choose_opt: min_elt_opt,
          split: split,
          find: find,
          find_opt: find_opt,
          find_first: find_first,
          find_first_opt: find_first_opt,
          find_last: find_last,
          find_last_opt: find_last_opt,
          of_list: of_list
        };
}

var Make_1 = Make;
/* No side effect */

var set$2 = {
	Make: Make_1
};

var Empty = caml_exceptions.create("Queue.Empty");

function create$2(param) {
  return {
          length: 0,
          first: /* Nil */0,
          last: /* Nil */0
        };
}

function clear$1(q) {
  q.length = 0;
  q.first = /* Nil */0;
  q.last = /* Nil */0;
  
}

function add$1(x, q) {
  var cell = /* Cons */{
    content: x,
    next: /* Nil */0
  };
  var last = q.last;
  if (last) {
    q.length = q.length + 1 | 0;
    last.next = cell;
    q.last = cell;
  } else {
    q.length = 1;
    q.first = cell;
    q.last = cell;
  }
  
}

function peek(q) {
  var match = q.first;
  if (match) {
    return match.content;
  }
  throw {
        RE_EXN_ID: Empty,
        Error: new Error()
      };
}

function take(q) {
  var match = q.first;
  if (match) {
    var content = match.content;
    var next = match.next;
    if (next) {
      q.length = q.length - 1 | 0;
      q.first = next;
      return content;
    } else {
      clear$1(q);
      return content;
    }
  }
  throw {
        RE_EXN_ID: Empty,
        Error: new Error()
      };
}

function copy$4(q) {
  var q_res = {
    length: q.length,
    first: /* Nil */0,
    last: /* Nil */0
  };
  var _prev = /* Nil */0;
  var _cell = q.first;
  while(true) {
    var cell = _cell;
    var prev = _prev;
    if (cell) {
      var next = cell.next;
      var res = /* Cons */{
        content: cell.content,
        next: /* Nil */0
      };
      if (prev) {
        prev.next = res;
      } else {
        q_res.first = res;
      }
      _cell = next;
      _prev = res;
      continue ;
    }
    q_res.last = prev;
    return q_res;
  }}

function is_empty(q) {
  return q.length === 0;
}

function length$2(q) {
  return q.length;
}

function iter$4(f, q) {
  var _cell = q.first;
  while(true) {
    var cell = _cell;
    if (!cell) {
      return ;
    }
    var next = cell.next;
    curry._1(f, cell.content);
    _cell = next;
    continue ;
  }}

function fold(f, accu, q) {
  var _accu = accu;
  var _cell = q.first;
  while(true) {
    var cell = _cell;
    var accu$1 = _accu;
    if (!cell) {
      return accu$1;
    }
    var next = cell.next;
    var accu$2 = curry._2(f, accu$1, cell.content);
    _cell = next;
    _accu = accu$2;
    continue ;
  }}

function transfer(q1, q2) {
  if (q1.length <= 0) {
    return ;
  }
  var last = q2.last;
  if (last) {
    q2.length = q2.length + q1.length | 0;
    last.next = q1.first;
    q2.last = q1.last;
    return clear$1(q1);
  } else {
    q2.length = q1.length;
    q2.first = q1.first;
    q2.last = q1.last;
    return clear$1(q1);
  }
}

var push = add$1;

var pop = take;

var top = peek;

var Empty_1 = Empty;
var create_1$2 = create$2;
var add_1$1 = add$1;
var push_1 = push;
var take_1 = take;
var pop_1 = pop;
var peek_1 = peek;
var top_1 = top;
var clear_1$1 = clear$1;
var copy_1$3 = copy$4;
var is_empty_1 = is_empty;
var length_1$2 = length$2;
var iter_1$4 = iter$4;
var fold_1 = fold;
var transfer_1 = transfer;
/* No side effect */

var queue = {
	Empty: Empty_1,
	create: create_1$2,
	add: add_1$1,
	push: push_1,
	take: take_1,
	pop: pop_1,
	peek: peek_1,
	top: top_1,
	clear: clear_1$1,
	copy: copy_1$3,
	is_empty: is_empty_1,
	length: length_1$2,
	iter: iter_1$4,
	fold: fold_1,
	transfer: transfer_1
};

function rotl32(x, n) {
  return (x << n) | (x >>> (32 - n | 0));
}

function caml_hash_mix_int(h, d) {
  var d$1 = d;
  d$1 = Math.imul(d$1, 3432918353);
  d$1 = rotl32(d$1, 15);
  d$1 = Math.imul(d$1, 461845907);
  var h$1 = h ^ d$1;
  h$1 = rotl32(h$1, 13);
  return (h$1 + (h$1 << 2) | 0) + 3864292196 | 0;
}

function caml_hash_final_mix(h) {
  var h$1 = h ^ (h >>> 16);
  h$1 = Math.imul(h$1, 2246822507);
  h$1 = h$1 ^ (h$1 >>> 13);
  h$1 = Math.imul(h$1, 3266489909);
  return h$1 ^ (h$1 >>> 16);
}

function caml_hash_mix_string(h, s) {
  var len = s.length;
  var block = (len / 4 | 0) - 1 | 0;
  var hash = h;
  for(var i = 0; i <= block; ++i){
    var j = (i << 2);
    var w = s.charCodeAt(j) | (s.charCodeAt(j + 1 | 0) << 8) | (s.charCodeAt(j + 2 | 0) << 16) | (s.charCodeAt(j + 3 | 0) << 24);
    hash = caml_hash_mix_int(hash, w);
  }
  var modulo = len & 3;
  if (modulo !== 0) {
    var w$1 = modulo === 3 ? (s.charCodeAt(len - 1 | 0) << 16) | (s.charCodeAt(len - 2 | 0) << 8) | s.charCodeAt(len - 3 | 0) : (
        modulo === 2 ? (s.charCodeAt(len - 1 | 0) << 8) | s.charCodeAt(len - 2 | 0) : s.charCodeAt(len - 1 | 0)
      );
    hash = caml_hash_mix_int(hash, w$1);
  }
  hash = hash ^ len;
  return hash;
}

var caml_hash_mix_int_1 = caml_hash_mix_int;
var caml_hash_mix_string_1 = caml_hash_mix_string;
var caml_hash_final_mix_1 = caml_hash_final_mix;
/* No side effect */

var caml_hash_primitive = {
	caml_hash_mix_int: caml_hash_mix_int_1,
	caml_hash_mix_string: caml_hash_mix_string_1,
	caml_hash_final_mix: caml_hash_final_mix_1
};

function push_back(q, v) {
  var cell = {
    content: v,
    next: undefined
  };
  var last = q.last;
  if (last !== undefined) {
    q.length = q.length + 1 | 0;
    last.next = cell;
    q.last = cell;
  } else {
    q.length = 1;
    q.first = cell;
    q.last = cell;
  }
  
}

function unsafe_pop(q) {
  var cell = q.first;
  var next = cell.next;
  if (next === undefined) {
    q.length = 0;
    q.first = undefined;
    q.last = undefined;
  } else {
    q.length = q.length - 1 | 0;
    q.first = next;
  }
  return cell.content;
}

function caml_hash(count, _limit, seed, obj) {
  var hash = seed;
  if (typeof obj === "number") {
    var u = obj | 0;
    hash = caml_hash_primitive.caml_hash_mix_int(hash, (u + u | 0) + 1 | 0);
    return caml_hash_primitive.caml_hash_final_mix(hash);
  }
  if (typeof obj === "string") {
    hash = caml_hash_primitive.caml_hash_mix_string(hash, obj);
    return caml_hash_primitive.caml_hash_final_mix(hash);
  }
  var queue = {
    length: 0,
    first: undefined,
    last: undefined
  };
  var num = count;
  push_back(queue, obj);
  num = num - 1 | 0;
  while(queue.length !== 0 && num > 0) {
    var obj$1 = unsafe_pop(queue);
    if (typeof obj$1 === "number") {
      var u$1 = obj$1 | 0;
      hash = caml_hash_primitive.caml_hash_mix_int(hash, (u$1 + u$1 | 0) + 1 | 0);
      num = num - 1 | 0;
    } else if (typeof obj$1 === "string") {
      hash = caml_hash_primitive.caml_hash_mix_string(hash, obj$1);
      num = num - 1 | 0;
    } else if (typeof obj$1 !== "boolean" && typeof obj$1 !== "undefined" && typeof obj$1 !== "symbol" && typeof obj$1 !== "function") {
      var size = obj$1.length | 0;
      if (size !== 0) {
        var obj_tag = obj$1.TAG | 0;
        var tag = (size << 10) | obj_tag;
        if (obj_tag === 248) {
          hash = caml_hash_primitive.caml_hash_mix_int(hash, obj$1[1]);
        } else {
          hash = caml_hash_primitive.caml_hash_mix_int(hash, tag);
          var v = size - 1 | 0;
          var block = v < num ? v : num;
          for(var i = 0; i <= block; ++i){
            push_back(queue, obj$1[i]);
          }
        }
      } else {
        var size$1 = (function(obj,cb){
            var size = 0;  
            for(var k in obj){
              cb(obj[k]);
              ++ size;
            }
            return size
          })(obj$1, (function (v) {
                return push_back(queue, v);
              }));
        hash = caml_hash_primitive.caml_hash_mix_int(hash, (size$1 << 10) | 0);
      }
    }
    
  }  return caml_hash_primitive.caml_hash_final_mix(hash);
}

var caml_hash_2 = caml_hash;
/* No side effect */

var caml_hash_1 = {
	caml_hash: caml_hash_2
};

function hash(x) {
  return caml_hash_1.caml_hash(10, 100, 0, x);
}

function hash_param(n1, n2, x) {
  return caml_hash_1.caml_hash(n1, n2, 0, x);
}

function seeded_hash(seed, x) {
  return caml_hash_1.caml_hash(10, 100, seed, x);
}

function flip_ongoing_traversal(h) {
  h.initial_size = -h.initial_size | 0;
  
}

var randomized = {
  contents: false
};

function randomize(param) {
  randomized.contents = true;
  
}

function is_randomized(param) {
  return randomized.contents;
}

var prng$1 = {
  LAZY_DONE: false,
  VAL: (function () {
      return random.State.make_self_init(undefined);
    })
};

function power_2_above(_x, n) {
  while(true) {
    var x = _x;
    if (x >= n) {
      return x;
    }
    if ((x << 1) < x) {
      return x;
    }
    _x = (x << 1);
    continue ;
  }}

function create$3(randomOpt, initial_size) {
  var random$1 = randomOpt !== undefined ? randomOpt : randomized.contents;
  var s = power_2_above(16, initial_size);
  var seed = random$1 ? random.State.bits(camlinternalLazy.force(prng$1)) : 0;
  return {
          size: 0,
          data: caml_array.caml_make_vect(s, /* Empty */0),
          seed: seed,
          initial_size: s
        };
}

function clear$2(h) {
  h.size = 0;
  var len = h.data.length;
  for(var i = 0; i < len; ++i){
    caml_array.set(h.data, i, /* Empty */0);
  }
  
}

function reset$1(h) {
  var len = h.data.length;
  if (len === pervasives.abs(h.initial_size)) {
    return clear$2(h);
  } else {
    h.size = 0;
    h.data = caml_array.caml_make_vect(pervasives.abs(h.initial_size), /* Empty */0);
    return ;
  }
}

function copy_bucketlist(param) {
  if (!param) {
    return /* Empty */0;
  }
  var key = param.key;
  var data = param.data;
  var next = param.next;
  var loop = function (_prec, _param) {
    while(true) {
      var param = _param;
      var prec = _prec;
      if (!param) {
        return ;
      }
      var key = param.key;
      var data = param.data;
      var next = param.next;
      var r = /* Cons */{
        key: key,
        data: data,
        next: next
      };
      if (prec) {
        prec.next = r;
      } else {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "hashtbl.ml",
                113,
                23
              ],
              Error: new Error()
            };
      }
      _param = next;
      _prec = r;
      continue ;
    }  };
  var r = /* Cons */{
    key: key,
    data: data,
    next: next
  };
  loop(r, next);
  return r;
}

function copy$5(h) {
  return {
          size: h.size,
          data: array.map(copy_bucketlist, h.data),
          seed: h.seed,
          initial_size: h.initial_size
        };
}

function length$3(h) {
  return h.size;
}

function resize$1(indexfun, h) {
  var odata = h.data;
  var osize = odata.length;
  var nsize = (osize << 1);
  if (nsize < osize) {
    return ;
  }
  var ndata = caml_array.caml_make_vect(nsize, /* Empty */0);
  var ndata_tail = caml_array.caml_make_vect(nsize, /* Empty */0);
  var inplace = h.initial_size >= 0;
  h.data = ndata;
  var insert_bucket = function (_cell) {
    while(true) {
      var cell = _cell;
      if (!cell) {
        return ;
      }
      var key = cell.key;
      var data = cell.data;
      var next = cell.next;
      var cell$1 = inplace ? cell : /* Cons */({
            key: key,
            data: data,
            next: /* Empty */0
          });
      var nidx = curry._2(indexfun, h, key);
      var tail = caml_array.get(ndata_tail, nidx);
      if (tail) {
        tail.next = cell$1;
      } else {
        caml_array.set(ndata, nidx, cell$1);
      }
      caml_array.set(ndata_tail, nidx, cell$1);
      _cell = next;
      continue ;
    }  };
  for(var i = 0; i < osize; ++i){
    insert_bucket(caml_array.get(odata, i));
  }
  if (!inplace) {
    return ;
  }
  for(var i$1 = 0; i$1 < nsize; ++i$1){
    var tail = caml_array.get(ndata_tail, i$1);
    if (tail) {
      tail.next = /* Empty */0;
    }
    
  }
  
}

function key_index(h, key) {
  return caml_hash_1.caml_hash(10, 100, h.seed, key) & (h.data.length - 1 | 0);
}

function add$2(h, key, data) {
  var i = key_index(h, key);
  var bucket = /* Cons */{
    key: key,
    data: data,
    next: caml_array.get(h.data, i)
  };
  caml_array.set(h.data, i, bucket);
  h.size = h.size + 1 | 0;
  if (h.size > (h.data.length << 1)) {
    return resize$1(key_index, h);
  }
  
}

function remove(h, key) {
  var i = key_index(h, key);
  var _prec = /* Empty */0;
  var _c = caml_array.get(h.data, i);
  while(true) {
    var c = _c;
    var prec = _prec;
    if (!c) {
      return ;
    }
    var k = c.key;
    var next = c.next;
    if (caml_obj.caml_equal(k, key)) {
      h.size = h.size - 1 | 0;
      if (prec) {
        prec.next = next;
        return ;
      } else {
        return caml_array.set(h.data, i, next);
      }
    }
    _c = next;
    _prec = c;
    continue ;
  }}

function find$1(h, key) {
  var match = caml_array.get(h.data, key_index(h, key));
  if (match) {
    var k1 = match.key;
    var d1 = match.data;
    var next1 = match.next;
    if (caml_obj.caml_equal(key, k1)) {
      return d1;
    }
    if (next1) {
      var k2 = next1.key;
      var d2 = next1.data;
      var next2 = next1.next;
      if (caml_obj.caml_equal(key, k2)) {
        return d2;
      }
      if (next2) {
        var k3 = next2.key;
        var d3 = next2.data;
        var next3 = next2.next;
        if (caml_obj.caml_equal(key, k3)) {
          return d3;
        } else {
          var _param = next3;
          while(true) {
            var param = _param;
            if (param) {
              var k = param.key;
              var data = param.data;
              var next = param.next;
              if (caml_obj.caml_equal(key, k)) {
                return data;
              }
              _param = next;
              continue ;
            }
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
          }        }
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function find_opt$1(h, key) {
  var match = caml_array.get(h.data, key_index(h, key));
  if (!match) {
    return ;
  }
  var k1 = match.key;
  var d1 = match.data;
  var next1 = match.next;
  if (caml_obj.caml_equal(key, k1)) {
    return caml_option.some(d1);
  }
  if (!next1) {
    return ;
  }
  var k2 = next1.key;
  var d2 = next1.data;
  var next2 = next1.next;
  if (caml_obj.caml_equal(key, k2)) {
    return caml_option.some(d2);
  }
  if (!next2) {
    return ;
  }
  var k3 = next2.key;
  var d3 = next2.data;
  var next3 = next2.next;
  if (caml_obj.caml_equal(key, k3)) {
    return caml_option.some(d3);
  } else {
    var _param = next3;
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var k = param.key;
      var data = param.data;
      var next = param.next;
      if (caml_obj.caml_equal(key, k)) {
        return caml_option.some(data);
      }
      _param = next;
      continue ;
    }  }
}

function find_all$1(h, key) {
  var find_in_bucket = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return /* [] */0;
      }
      var k = param.key;
      var data = param.data;
      var next = param.next;
      if (caml_obj.caml_equal(k, key)) {
        return {
                hd: data,
                tl: find_in_bucket(next)
              };
      }
      _param = next;
      continue ;
    }  };
  return find_in_bucket(caml_array.get(h.data, key_index(h, key)));
}

function replace_bucket(key, data, _slot) {
  while(true) {
    var slot = _slot;
    if (!slot) {
      return true;
    }
    var k = slot.key;
    var next = slot.next;
    if (caml_obj.caml_equal(k, key)) {
      slot.key = key;
      slot.data = data;
      return false;
    }
    _slot = next;
    continue ;
  }}

function replace(h, key, data) {
  var i = key_index(h, key);
  var l = caml_array.get(h.data, i);
  if (replace_bucket(key, data, l)) {
    caml_array.set(h.data, i, /* Cons */{
          key: key,
          data: data,
          next: l
        });
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize$1(key_index, h);
    } else {
      return ;
    }
  }
  
}

function mem$2(h, key) {
  var _param = caml_array.get(h.data, key_index(h, key));
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    var k = param.key;
    var next = param.next;
    if (caml_obj.caml_equal(k, key)) {
      return true;
    }
    _param = next;
    continue ;
  }}

function iter$5(f, h) {
  var do_bucket = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var key = param.key;
      var data = param.data;
      var next = param.next;
      curry._2(f, key, data);
      _param = next;
      continue ;
    }  };
  var old_trav = h.initial_size < 0;
  if (!old_trav) {
    flip_ongoing_traversal(h);
  }
  try {
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      do_bucket(caml_array.get(d, i));
    }
    if (!old_trav) {
      return flip_ongoing_traversal(h);
    } else {
      return ;
    }
  }
  catch (exn){
    if (old_trav) {
      throw exn;
    }
    flip_ongoing_traversal(h);
    throw exn;
  }
}

function filter_map_inplace_bucket(f, h, i, _prec, _slot) {
  while(true) {
    var slot = _slot;
    var prec = _prec;
    if (!slot) {
      if (prec) {
        prec.next = /* Empty */0;
        return ;
      } else {
        return caml_array.set(h.data, i, /* Empty */0);
      }
    }
    var key = slot.key;
    var data = slot.data;
    var next = slot.next;
    var data$1 = curry._2(f, key, data);
    if (data$1 !== undefined) {
      if (prec) {
        prec.next = slot;
      } else {
        caml_array.set(h.data, i, slot);
      }
      slot.data = caml_option.valFromOption(data$1);
      _slot = next;
      _prec = slot;
      continue ;
    }
    h.size = h.size - 1 | 0;
    _slot = next;
    continue ;
  }}

function filter_map_inplace(f, h) {
  var d = h.data;
  var old_trav = h.initial_size < 0;
  if (!old_trav) {
    flip_ongoing_traversal(h);
  }
  try {
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      filter_map_inplace_bucket(f, h, i, /* Empty */0, caml_array.get(h.data, i));
    }
    return ;
  }
  catch (exn){
    if (old_trav) {
      throw exn;
    }
    flip_ongoing_traversal(h);
    throw exn;
  }
}

function fold$1(f, h, init) {
  var do_bucket = function (_b, _accu) {
    while(true) {
      var accu = _accu;
      var b = _b;
      if (!b) {
        return accu;
      }
      var key = b.key;
      var data = b.data;
      var next = b.next;
      _accu = curry._3(f, key, data, accu);
      _b = next;
      continue ;
    }  };
  var old_trav = h.initial_size < 0;
  if (!old_trav) {
    flip_ongoing_traversal(h);
  }
  try {
    var d = h.data;
    var accu = init;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      accu = do_bucket(caml_array.get(d, i), accu);
    }
    if (!old_trav) {
      flip_ongoing_traversal(h);
    }
    return accu;
  }
  catch (exn){
    if (old_trav) {
      throw exn;
    }
    flip_ongoing_traversal(h);
    throw exn;
  }
}

function bucket_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    var next = param.next;
    _param = next;
    _accu = accu + 1 | 0;
    continue ;
  }}

function stats(h) {
  var mbl = array.fold_left((function (m, b) {
          return caml_primitive.caml_int_max(m, bucket_length(0, b));
        }), 0, h.data);
  var histo = caml_array.caml_make_vect(mbl + 1 | 0, 0);
  array.iter((function (b) {
          var l = bucket_length(0, b);
          return caml_array.set(histo, l, caml_array.get(histo, l) + 1 | 0);
        }), h.data);
  return {
          num_bindings: h.size,
          num_buckets: h.data.length,
          max_bucket_length: mbl,
          bucket_histogram: histo
        };
}

function MakeSeeded(H) {
  var key_index = function (h, key) {
    return curry._2(H.hash, h.seed, key) & (h.data.length - 1 | 0);
  };
  var add = function (h, key, data) {
    var i = key_index(h, key);
    var bucket = /* Cons */{
      key: key,
      data: data,
      next: caml_array.get(h.data, i)
    };
    caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize$1(key_index, h);
    }
    
  };
  var remove = function (h, key) {
    var i = key_index(h, key);
    var _prec = /* Empty */0;
    var _c = caml_array.get(h.data, i);
    while(true) {
      var c = _c;
      var prec = _prec;
      if (!c) {
        return ;
      }
      var k = c.key;
      var next = c.next;
      if (curry._2(H.equal, k, key)) {
        h.size = h.size - 1 | 0;
        if (prec) {
          prec.next = next;
          return ;
        } else {
          return caml_array.set(h.data, i, next);
        }
      }
      _c = next;
      _prec = c;
      continue ;
    }  };
  var find = function (h, key) {
    var match = caml_array.get(h.data, key_index(h, key));
    if (match) {
      var k1 = match.key;
      var d1 = match.data;
      var next1 = match.next;
      if (curry._2(H.equal, key, k1)) {
        return d1;
      }
      if (next1) {
        var k2 = next1.key;
        var d2 = next1.data;
        var next2 = next1.next;
        if (curry._2(H.equal, key, k2)) {
          return d2;
        }
        if (next2) {
          var k3 = next2.key;
          var d3 = next2.data;
          var next3 = next2.next;
          if (curry._2(H.equal, key, k3)) {
            return d3;
          } else {
            var _param = next3;
            while(true) {
              var param = _param;
              if (param) {
                var k = param.key;
                var data = param.data;
                var next = param.next;
                if (curry._2(H.equal, key, k)) {
                  return data;
                }
                _param = next;
                continue ;
              }
              throw {
                    RE_EXN_ID: "Not_found",
                    Error: new Error()
                  };
            }          }
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
  var find_opt = function (h, key) {
    var match = caml_array.get(h.data, key_index(h, key));
    if (!match) {
      return ;
    }
    var k1 = match.key;
    var d1 = match.data;
    var next1 = match.next;
    if (curry._2(H.equal, key, k1)) {
      return caml_option.some(d1);
    }
    if (!next1) {
      return ;
    }
    var k2 = next1.key;
    var d2 = next1.data;
    var next2 = next1.next;
    if (curry._2(H.equal, key, k2)) {
      return caml_option.some(d2);
    }
    if (!next2) {
      return ;
    }
    var k3 = next2.key;
    var d3 = next2.data;
    var next3 = next2.next;
    if (curry._2(H.equal, key, k3)) {
      return caml_option.some(d3);
    } else {
      var _param = next3;
      while(true) {
        var param = _param;
        if (!param) {
          return ;
        }
        var k = param.key;
        var data = param.data;
        var next = param.next;
        if (curry._2(H.equal, key, k)) {
          return caml_option.some(data);
        }
        _param = next;
        continue ;
      }    }
  };
  var find_all = function (h, key) {
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        var k = param.key;
        var d = param.data;
        var next = param.next;
        if (curry._2(H.equal, k, key)) {
          return {
                  hd: d,
                  tl: find_in_bucket(next)
                };
        }
        _param = next;
        continue ;
      }    };
    return find_in_bucket(caml_array.get(h.data, key_index(h, key)));
  };
  var replace_bucket = function (key, data, _slot) {
    while(true) {
      var slot = _slot;
      if (!slot) {
        return true;
      }
      var k = slot.key;
      var next = slot.next;
      if (curry._2(H.equal, k, key)) {
        slot.key = key;
        slot.data = data;
        return false;
      }
      _slot = next;
      continue ;
    }  };
  var replace = function (h, key, data) {
    var i = key_index(h, key);
    var l = caml_array.get(h.data, i);
    if (replace_bucket(key, data, l)) {
      caml_array.set(h.data, i, /* Cons */{
            key: key,
            data: data,
            next: l
          });
      h.size = h.size + 1 | 0;
      if (h.size > (h.data.length << 1)) {
        return resize$1(key_index, h);
      } else {
        return ;
      }
    }
    
  };
  var mem = function (h, key) {
    var _param = caml_array.get(h.data, key_index(h, key));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      var k = param.key;
      var next = param.next;
      if (curry._2(H.equal, k, key)) {
        return true;
      }
      _param = next;
      continue ;
    }  };
  return {
          create: create$3,
          clear: clear$2,
          reset: reset$1,
          copy: copy$5,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          iter: iter$5,
          filter_map_inplace: filter_map_inplace,
          fold: fold$1,
          length: length$3,
          stats: stats
        };
}

function Make$1(H) {
  var equal = H.equal;
  var key_index = function (h, key) {
    return curry._1(H.hash, key) & (h.data.length - 1 | 0);
  };
  var add = function (h, key, data) {
    var i = key_index(h, key);
    var bucket = /* Cons */{
      key: key,
      data: data,
      next: caml_array.get(h.data, i)
    };
    caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize$1(key_index, h);
    }
    
  };
  var remove = function (h, key) {
    var i = key_index(h, key);
    var _prec = /* Empty */0;
    var _c = caml_array.get(h.data, i);
    while(true) {
      var c = _c;
      var prec = _prec;
      if (!c) {
        return ;
      }
      var k = c.key;
      var next = c.next;
      if (curry._2(equal, k, key)) {
        h.size = h.size - 1 | 0;
        if (prec) {
          prec.next = next;
          return ;
        } else {
          return caml_array.set(h.data, i, next);
        }
      }
      _c = next;
      _prec = c;
      continue ;
    }  };
  var find = function (h, key) {
    var match = caml_array.get(h.data, key_index(h, key));
    if (match) {
      var k1 = match.key;
      var d1 = match.data;
      var next1 = match.next;
      if (curry._2(equal, key, k1)) {
        return d1;
      }
      if (next1) {
        var k2 = next1.key;
        var d2 = next1.data;
        var next2 = next1.next;
        if (curry._2(equal, key, k2)) {
          return d2;
        }
        if (next2) {
          var k3 = next2.key;
          var d3 = next2.data;
          var next3 = next2.next;
          if (curry._2(equal, key, k3)) {
            return d3;
          } else {
            var _param = next3;
            while(true) {
              var param = _param;
              if (param) {
                var k = param.key;
                var data = param.data;
                var next = param.next;
                if (curry._2(equal, key, k)) {
                  return data;
                }
                _param = next;
                continue ;
              }
              throw {
                    RE_EXN_ID: "Not_found",
                    Error: new Error()
                  };
            }          }
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
  var find_opt = function (h, key) {
    var match = caml_array.get(h.data, key_index(h, key));
    if (!match) {
      return ;
    }
    var k1 = match.key;
    var d1 = match.data;
    var next1 = match.next;
    if (curry._2(equal, key, k1)) {
      return caml_option.some(d1);
    }
    if (!next1) {
      return ;
    }
    var k2 = next1.key;
    var d2 = next1.data;
    var next2 = next1.next;
    if (curry._2(equal, key, k2)) {
      return caml_option.some(d2);
    }
    if (!next2) {
      return ;
    }
    var k3 = next2.key;
    var d3 = next2.data;
    var next3 = next2.next;
    if (curry._2(equal, key, k3)) {
      return caml_option.some(d3);
    } else {
      var _param = next3;
      while(true) {
        var param = _param;
        if (!param) {
          return ;
        }
        var k = param.key;
        var data = param.data;
        var next = param.next;
        if (curry._2(equal, key, k)) {
          return caml_option.some(data);
        }
        _param = next;
        continue ;
      }    }
  };
  var find_all = function (h, key) {
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        var k = param.key;
        var d = param.data;
        var next = param.next;
        if (curry._2(equal, k, key)) {
          return {
                  hd: d,
                  tl: find_in_bucket(next)
                };
        }
        _param = next;
        continue ;
      }    };
    return find_in_bucket(caml_array.get(h.data, key_index(h, key)));
  };
  var replace_bucket = function (key, data, _slot) {
    while(true) {
      var slot = _slot;
      if (!slot) {
        return true;
      }
      var k = slot.key;
      var next = slot.next;
      if (curry._2(equal, k, key)) {
        slot.key = key;
        slot.data = data;
        return false;
      }
      _slot = next;
      continue ;
    }  };
  var replace = function (h, key, data) {
    var i = key_index(h, key);
    var l = caml_array.get(h.data, i);
    if (replace_bucket(key, data, l)) {
      caml_array.set(h.data, i, /* Cons */{
            key: key,
            data: data,
            next: l
          });
      h.size = h.size + 1 | 0;
      if (h.size > (h.data.length << 1)) {
        return resize$1(key_index, h);
      } else {
        return ;
      }
    }
    
  };
  var mem = function (h, key) {
    var _param = caml_array.get(h.data, key_index(h, key));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      var k = param.key;
      var next = param.next;
      if (curry._2(equal, k, key)) {
        return true;
      }
      _param = next;
      continue ;
    }  };
  var create$1 = function (sz) {
    return create$3(false, sz);
  };
  return {
          create: create$1,
          clear: clear$2,
          reset: reset$1,
          copy: copy$5,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          iter: iter$5,
          filter_map_inplace: filter_map_inplace,
          fold: fold$1,
          length: length$3,
          stats: stats
        };
}

var seeded_hash_param = caml_hash_1.caml_hash;

var create_1$3 = create$3;
var clear_1$2 = clear$2;
var reset_1$1 = reset$1;
var copy_1$4 = copy$5;
var add_1$2 = add$2;
var find_1$1 = find$1;
var find_opt_1$1 = find_opt$1;
var find_all_1$1 = find_all$1;
var mem_1$2 = mem$2;
var remove_1 = remove;
var replace_1 = replace;
var iter_1$5 = iter$5;
var filter_map_inplace_1 = filter_map_inplace;
var fold_1$1 = fold$1;
var length_1$3 = length$3;
var randomize_1 = randomize;
var is_randomized_1 = is_randomized;
var stats_1 = stats;
var Make_1$1 = Make$1;
var MakeSeeded_1 = MakeSeeded;
var hash_1 = hash;
var seeded_hash_1 = seeded_hash;
var hash_param_1 = hash_param;
var seeded_hash_param_1 = seeded_hash_param;
/* No side effect */

var hashtbl = {
	create: create_1$3,
	clear: clear_1$2,
	reset: reset_1$1,
	copy: copy_1$4,
	add: add_1$2,
	find: find_1$1,
	find_opt: find_opt_1$1,
	find_all: find_all_1$1,
	mem: mem_1$2,
	remove: remove_1,
	replace: replace_1,
	iter: iter_1$5,
	filter_map_inplace: filter_map_inplace_1,
	fold: fold_1$1,
	length: length_1$3,
	randomize: randomize_1,
	is_randomized: is_randomized_1,
	stats: stats_1,
	Make: Make_1$1,
	MakeSeeded: MakeSeeded_1,
	hash: hash_1,
	seeded_hash: seeded_hash_1,
	hash_param: hash_param_1,
	seeded_hash_param: seeded_hash_param_1
};

function token_to_string(param) {
  if (typeof param === "number") {
    switch (param) {
      case /* T_IDENTIFIER */0 :
          return "T_IDENTIFIER";
      case /* T_LCURLY */1 :
          return "T_LCURLY";
      case /* T_RCURLY */2 :
          return "T_RCURLY";
      case /* T_LCURLYBAR */3 :
          return "T_LCURLYBAR";
      case /* T_RCURLYBAR */4 :
          return "T_RCURLYBAR";
      case /* T_LPAREN */5 :
          return "T_LPAREN";
      case /* T_RPAREN */6 :
          return "T_RPAREN";
      case /* T_LBRACKET */7 :
          return "T_LBRACKET";
      case /* T_RBRACKET */8 :
          return "T_RBRACKET";
      case /* T_SEMICOLON */9 :
          return "T_SEMICOLON";
      case /* T_COMMA */10 :
          return "T_COMMA";
      case /* T_PERIOD */11 :
          return "T_PERIOD";
      case /* T_ARROW */12 :
          return "T_ARROW";
      case /* T_ELLIPSIS */13 :
          return "T_ELLIPSIS";
      case /* T_AT */14 :
          return "T_AT";
      case /* T_FUNCTION */15 :
          return "T_FUNCTION";
      case /* T_IF */16 :
          return "T_IF";
      case /* T_IN */17 :
          return "T_IN";
      case /* T_INSTANCEOF */18 :
          return "T_INSTANCEOF";
      case /* T_RETURN */19 :
          return "T_RETURN";
      case /* T_SWITCH */20 :
          return "T_SWITCH";
      case /* T_THIS */21 :
          return "T_THIS";
      case /* T_THROW */22 :
          return "T_THROW";
      case /* T_TRY */23 :
          return "T_TRY";
      case /* T_VAR */24 :
          return "T_VAR";
      case /* T_WHILE */25 :
          return "T_WHILE";
      case /* T_WITH */26 :
          return "T_WITH";
      case /* T_CONST */27 :
          return "T_CONST";
      case /* T_LET */28 :
          return "T_LET";
      case /* T_NULL */29 :
          return "T_NULL";
      case /* T_FALSE */30 :
          return "T_FALSE";
      case /* T_TRUE */31 :
          return "T_TRUE";
      case /* T_BREAK */32 :
          return "T_BREAK";
      case /* T_CASE */33 :
          return "T_CASE";
      case /* T_CATCH */34 :
          return "T_CATCH";
      case /* T_CONTINUE */35 :
          return "T_CONTINUE";
      case /* T_DEFAULT */36 :
          return "T_DEFAULT";
      case /* T_DO */37 :
          return "T_DO";
      case /* T_FINALLY */38 :
          return "T_FINALLY";
      case /* T_FOR */39 :
          return "T_FOR";
      case /* T_CLASS */40 :
          return "T_CLASS";
      case /* T_EXTENDS */41 :
          return "T_EXTENDS";
      case /* T_STATIC */42 :
          return "T_STATIC";
      case /* T_ELSE */43 :
          return "T_ELSE";
      case /* T_NEW */44 :
          return "T_NEW";
      case /* T_DELETE */45 :
          return "T_DELETE";
      case /* T_TYPEOF */46 :
          return "T_TYPEOF";
      case /* T_VOID */47 :
          return "T_VOID";
      case /* T_ENUM */48 :
          return "T_ENUM";
      case /* T_EXPORT */49 :
          return "T_EXPORT";
      case /* T_IMPORT */50 :
          return "T_IMPORT";
      case /* T_SUPER */51 :
          return "T_SUPER";
      case /* T_IMPLEMENTS */52 :
          return "T_IMPLEMENTS";
      case /* T_INTERFACE */53 :
          return "T_INTERFACE";
      case /* T_PACKAGE */54 :
          return "T_PACKAGE";
      case /* T_PRIVATE */55 :
          return "T_PRIVATE";
      case /* T_PROTECTED */56 :
          return "T_PROTECTED";
      case /* T_PUBLIC */57 :
          return "T_PUBLIC";
      case /* T_YIELD */58 :
          return "T_YIELD";
      case /* T_DEBUGGER */59 :
          return "T_DEBUGGER";
      case /* T_DECLARE */60 :
          return "T_DECLARE";
      case /* T_TYPE */61 :
          return "T_TYPE";
      case /* T_OF */62 :
          return "T_OF";
      case /* T_ASYNC */63 :
          return "T_ASYNC";
      case /* T_AWAIT */64 :
          return "T_AWAIT";
      case /* T_CHECKS */65 :
          return "T_CHECKS";
      case /* T_RSHIFT3_ASSIGN */66 :
          return "T_RSHIFT3_ASSIGN";
      case /* T_RSHIFT_ASSIGN */67 :
          return "T_RSHIFT_ASSIGN";
      case /* T_LSHIFT_ASSIGN */68 :
          return "T_LSHIFT_ASSIGN";
      case /* T_BIT_XOR_ASSIGN */69 :
          return "T_BIT_XOR_ASSIGN";
      case /* T_BIT_OR_ASSIGN */70 :
          return "T_BIT_OR_ASSIGN";
      case /* T_BIT_AND_ASSIGN */71 :
          return "T_BIT_AND_ASSIGN";
      case /* T_MOD_ASSIGN */72 :
          return "T_MOD_ASSIGN";
      case /* T_DIV_ASSIGN */73 :
          return "T_DIV_ASSIGN";
      case /* T_MULT_ASSIGN */74 :
          return "T_MULT_ASSIGN";
      case /* T_EXP_ASSIGN */75 :
          return "T_EXP_ASSIGN";
      case /* T_MINUS_ASSIGN */76 :
          return "T_MINUS_ASSIGN";
      case /* T_PLUS_ASSIGN */77 :
          return "T_PLUS_ASSIGN";
      case /* T_ASSIGN */78 :
          return "T_ASSIGN";
      case /* T_PLING */79 :
          return "T_PLING";
      case /* T_COLON */80 :
          return "T_COLON";
      case /* T_OR */81 :
          return "T_OR";
      case /* T_AND */82 :
          return "T_AND";
      case /* T_BIT_OR */83 :
          return "T_BIT_OR";
      case /* T_BIT_XOR */84 :
          return "T_BIT_XOR";
      case /* T_BIT_AND */85 :
          return "T_BIT_AND";
      case /* T_EQUAL */86 :
          return "T_EQUAL";
      case /* T_NOT_EQUAL */87 :
          return "T_NOT_EQUAL";
      case /* T_STRICT_EQUAL */88 :
          return "T_STRICT_EQUAL";
      case /* T_STRICT_NOT_EQUAL */89 :
          return "T_STRICT_NOT_EQUAL";
      case /* T_LESS_THAN_EQUAL */90 :
          return "T_LESS_THAN_EQUAL";
      case /* T_GREATER_THAN_EQUAL */91 :
          return "T_GREATER_THAN_EQUAL";
      case /* T_LESS_THAN */92 :
          return "T_LESS_THAN";
      case /* T_GREATER_THAN */93 :
          return "T_GREATER_THAN";
      case /* T_LSHIFT */94 :
          return "T_LSHIFT";
      case /* T_RSHIFT */95 :
          return "T_RSHIFT";
      case /* T_RSHIFT3 */96 :
          return "T_RSHIFT3";
      case /* T_PLUS */97 :
          return "T_PLUS";
      case /* T_MINUS */98 :
          return "T_MINUS";
      case /* T_DIV */99 :
          return "T_DIV";
      case /* T_MULT */100 :
          return "T_MULT";
      case /* T_EXP */101 :
          return "T_EXP";
      case /* T_MOD */102 :
          return "T_MOD";
      case /* T_NOT */103 :
          return "T_NOT";
      case /* T_BIT_NOT */104 :
          return "T_BIT_NOT";
      case /* T_INCR */105 :
          return "T_INCR";
      case /* T_DECR */106 :
          return "T_DECR";
      case /* T_ERROR */107 :
          return "T_ERROR";
      case /* T_EOF */108 :
          return "T_EOF";
      case /* T_JSX_IDENTIFIER */109 :
          return "T_JSX_IDENTIFIER";
      case /* T_ANY_TYPE */110 :
          return "T_ANY_TYPE";
      case /* T_MIXED_TYPE */111 :
          return "T_MIXED_TYPE";
      case /* T_EMPTY_TYPE */112 :
          return "T_EMPTY_TYPE";
      case /* T_BOOLEAN_TYPE */113 :
          return "T_BOOLEAN_TYPE";
      case /* T_NUMBER_TYPE */114 :
          return "T_NUMBER_TYPE";
      case /* T_STRING_TYPE */115 :
          return "T_STRING_TYPE";
      case /* T_VOID_TYPE */116 :
          return "T_VOID_TYPE";
      
    }
  } else {
    switch (param.TAG | 0) {
      case /* T_NUMBER */0 :
          return "T_NUMBER";
      case /* T_STRING */1 :
          return "T_STRING";
      case /* T_TEMPLATE_PART */2 :
          return "T_TEMPLATE_PART";
      case /* T_REGEXP */3 :
          return "T_REGEXP";
      case /* T_JSX_TEXT */4 :
          return "T_JSX_TEXT";
      case /* T_NUMBER_SINGLETON_TYPE */5 :
          return "T_NUMBER_SINGLETON_TYPE";
      
    }
  }
}

var Token = {
  token_to_string: token_to_string
};

function yyback(n, lexbuf) {
  lexbuf.lex_curr_pos = lexbuf.lex_curr_pos - n | 0;
  var currp = lexbuf.lex_curr_p;
  lexbuf.lex_curr_p = {
    pos_fname: currp.pos_fname,
    pos_lnum: currp.pos_lnum,
    pos_bol: currp.pos_bol,
    pos_cnum: currp.pos_cnum - n | 0
  };
  
}

function back(lb) {
  var n = lexing.lexeme_end(lb) - lexing.lexeme_start(lb) | 0;
  return yyback(n, lb);
}

function debug_string_of_lexing_position(position) {
  return curry._4(printf_1.sprintf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "{pos_fname=",
                    _1: {
                      TAG: /* Caml_string */3,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "; pos_lnum=",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: "; pos_bol=",
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* String_literal */11,
                                _0: "; pos_cnum=",
                                _1: {
                                  TAG: /* Int */4,
                                  _0: /* Int_d */0,
                                  _1: /* No_padding */0,
                                  _2: /* No_precision */0,
                                  _3: {
                                    TAG: /* Char_literal */12,
                                    _0: /* "}" */125,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "{pos_fname=%S; pos_lnum=%d; pos_bol=%d; pos_cnum=%d}"
                }), position.pos_fname, position.pos_lnum, position.pos_bol, position.pos_cnum);
}

function debug_string_of_lexbuf(lb) {
  return curry.app(printf_1.sprintf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "{ lex_buffer = ",
                    _1: {
                      TAG: /* Caml_string */3,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "; lex_buffer_len = ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: "; lex_abs_pos = ",
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* String_literal */11,
                                _0: "; lex_start_pos = ",
                                _1: {
                                  TAG: /* Int */4,
                                  _0: /* Int_d */0,
                                  _1: /* No_padding */0,
                                  _2: /* No_precision */0,
                                  _3: {
                                    TAG: /* String_literal */11,
                                    _0: "; lex_curr_pos = ",
                                    _1: {
                                      TAG: /* Int */4,
                                      _0: /* Int_d */0,
                                      _1: /* No_padding */0,
                                      _2: /* No_precision */0,
                                      _3: {
                                        TAG: /* String_literal */11,
                                        _0: "; lex_last_pos = ",
                                        _1: {
                                          TAG: /* Int */4,
                                          _0: /* Int_d */0,
                                          _1: /* No_padding */0,
                                          _2: /* No_precision */0,
                                          _3: {
                                            TAG: /* String_literal */11,
                                            _0: "; lex_last_action = ",
                                            _1: {
                                              TAG: /* Int */4,
                                              _0: /* Int_d */0,
                                              _1: /* No_padding */0,
                                              _2: /* No_precision */0,
                                              _3: {
                                                TAG: /* String_literal */11,
                                                _0: "; lex_eof_reached = ",
                                                _1: {
                                                  TAG: /* Bool */9,
                                                  _0: /* No_padding */0,
                                                  _1: {
                                                    TAG: /* String_literal */11,
                                                    _0: "; lex_mem = TODO; lex_start_p = ",
                                                    _1: {
                                                      TAG: /* String */2,
                                                      _0: /* No_padding */0,
                                                      _1: {
                                                        TAG: /* String_literal */11,
                                                        _0: "; lex_curr_p = ",
                                                        _1: {
                                                          TAG: /* String */2,
                                                          _0: /* No_padding */0,
                                                          _1: {
                                                            TAG: /* String_literal */11,
                                                            _0: "; }",
                                                            _1: /* End_of_format */0
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "{ lex_buffer = %S; lex_buffer_len = %d; lex_abs_pos = %d; lex_start_pos = %d; lex_curr_pos = %d; lex_last_pos = %d; lex_last_action = %d; lex_eof_reached = %b; lex_mem = TODO; lex_start_p = %s; lex_curr_p = %s; }"
                }), [
              bytes.to_string(lb.lex_buffer),
              lb.lex_buffer_len,
              lb.lex_abs_pos,
              lb.lex_start_pos,
              lb.lex_curr_pos,
              lb.lex_last_pos,
              lb.lex_last_action,
              lb.lex_eof_reached,
              debug_string_of_lexing_position(lb.lex_start_p),
              debug_string_of_lexing_position(lb.lex_curr_p)
            ]);
}

var empty_lex_state = {
  lex_errors_acc: /* [] */0,
  lex_comments_acc: /* [] */0
};

function new_lex_env(lex_source, lex_lb, enable_types_in_comments) {
  return {
          lex_source: lex_source,
          lex_lb: lex_lb,
          lex_in_comment_syntax: false,
          lex_enable_comment_syntax: enable_types_in_comments,
          lex_state: empty_lex_state
        };
}

function get_and_clear_state(env) {
  var state = env.lex_state;
  var env$1 = state !== empty_lex_state ? ({
        lex_source: env.lex_source,
        lex_lb: env.lex_lb,
        lex_in_comment_syntax: env.lex_in_comment_syntax,
        lex_enable_comment_syntax: env.lex_enable_comment_syntax,
        lex_state: empty_lex_state
      }) : env;
  return [
          env$1,
          state
        ];
}

function lexbuf(env) {
  return env.lex_lb;
}

function with_lexbuf(lexbuf, env) {
  return {
          lex_source: env.lex_source,
          lex_lb: lexbuf,
          lex_in_comment_syntax: env.lex_in_comment_syntax,
          lex_enable_comment_syntax: env.lex_enable_comment_syntax,
          lex_state: env.lex_state
        };
}

function source$1(env) {
  return env.lex_source;
}

function state$1(env) {
  return env.lex_state;
}

function is_in_comment_syntax(env) {
  return env.lex_in_comment_syntax;
}

function is_comment_syntax_enabled(env) {
  return env.lex_enable_comment_syntax;
}

function in_comment_syntax(is_in, env) {
  if (is_in !== env.lex_in_comment_syntax) {
    return {
            lex_source: env.lex_source,
            lex_lb: env.lex_lb,
            lex_in_comment_syntax: is_in,
            lex_enable_comment_syntax: env.lex_enable_comment_syntax,
            lex_state: env.lex_state
          };
  } else {
    return env;
  }
}

function debug_string_of_lex_env(env) {
  var x = env.lex_source;
  var source = x !== undefined ? curry._1(printf_1.sprintf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "Some ",
                _1: {
                  TAG: /* Caml_string */3,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                }
              },
              _1: "Some %S"
            }), loc_bs.string_of_filename(x)) : "None";
  return curry._6(printf_1.sprintf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "{\n  lex_source = ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "\n  lex_lb = ",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "\n  lex_in_comment_syntax = ",
                            _1: {
                              TAG: /* Bool */9,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "\n  lex_enable_comment_syntax = ",
                                _1: {
                                  TAG: /* Bool */9,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "\n  lex_state = {errors = (count = ",
                                    _1: {
                                      TAG: /* Int */4,
                                      _0: /* Int_d */0,
                                      _1: /* No_padding */0,
                                      _2: /* No_precision */0,
                                      _3: {
                                        TAG: /* String_literal */11,
                                        _0: "); comments = (count = ",
                                        _1: {
                                          TAG: /* Int */4,
                                          _0: /* Int_d */0,
                                          _1: /* No_padding */0,
                                          _2: /* No_precision */0,
                                          _3: {
                                            TAG: /* String_literal */11,
                                            _0: ")}\n}",
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "{\n  lex_source = %s\n  lex_lb = %s\n  lex_in_comment_syntax = %b\n  lex_enable_comment_syntax = %b\n  lex_state = {errors = (count = %d); comments = (count = %d)}\n}"
                }), source, debug_string_of_lexbuf(env.lex_lb), env.lex_in_comment_syntax, env.lex_enable_comment_syntax, list.length(env.lex_state.lex_errors_acc), list.length(env.lex_state.lex_comments_acc));
}

var Lex_env = {
  empty_lex_state: empty_lex_state,
  new_lex_env: new_lex_env,
  get_and_clear_state: get_and_clear_state,
  lexbuf: lexbuf,
  with_lexbuf: with_lexbuf,
  source: source$1,
  state: state$1,
  is_in_comment_syntax: is_in_comment_syntax,
  is_comment_syntax_enabled: is_comment_syntax_enabled,
  in_comment_syntax: in_comment_syntax,
  debug_string_of_lex_env: debug_string_of_lex_env
};

function token(result) {
  return result.lex_token;
}

function loc(result) {
  return result.lex_loc;
}

function value(result) {
  return result.lex_value;
}

function comments(result) {
  return result.lex_comments;
}

function errors(result) {
  return result.lex_errors;
}

function debug_string_of_lex_result(lex_result) {
  return curry._4(printf_1.sprintf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "{\n  lex_token = ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "\n  lex_value = ",
                        _1: {
                          TAG: /* Caml_string */3,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "\n  lex_errors = (length = ",
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* String_literal */11,
                                _0: ")\n  lex_comments = (length = ",
                                _1: {
                                  TAG: /* Int */4,
                                  _0: /* Int_d */0,
                                  _1: /* No_padding */0,
                                  _2: /* No_precision */0,
                                  _3: {
                                    TAG: /* String_literal */11,
                                    _0: ")\n}",
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "{\n  lex_token = %s\n  lex_value = %S\n  lex_errors = (length = %d)\n  lex_comments = (length = %d)\n}"
                }), token_to_string(lex_result.lex_token), lex_result.lex_value, list.length(lex_result.lex_errors), list.length(lex_result.lex_comments));
}

var Lex_result = {
  token: token,
  loc: loc,
  value: value,
  comments: comments,
  errors: errors,
  debug_string_of_lex_result: debug_string_of_lex_result
};

function loc_of_lexbuf(env, lexbuf) {
  return loc_bs.from_lb(env.lex_source, lexbuf);
}

function get_result_and_clear_state(param) {
  var lex_token = param[1];
  var match = get_and_clear_state(param[0]);
  var state = match[1];
  var env = match[0];
  var match$1;
  var exit = 0;
  if (typeof lex_token === "number") {
    exit = 2;
  } else {
    switch (lex_token.TAG | 0) {
      case /* T_TEMPLATE_PART */2 :
          var match$2 = lex_token._0;
          match$1 = [
            match$2[0],
            match$2[1].literal
          ];
          break;
      case /* T_REGEXP */3 :
          var match$3 = lex_token._0;
          match$1 = [
            match$3[0],
            "/" + (match$3[1] + ("/" + match$3[2]))
          ];
          break;
      case /* T_STRING */1 :
      case /* T_JSX_TEXT */4 :
          exit = 1;
          break;
      default:
        exit = 2;
    }
  }
  switch (exit) {
    case 1 :
        var match$4 = lex_token._0;
        match$1 = [
          match$4[0],
          match$4[2]
        ];
        break;
    case 2 :
        match$1 = [
          loc_bs.from_lb(env.lex_source, env.lex_lb),
          lexing.lexeme(env.lex_lb)
        ];
        break;
    
  }
  return [
          env,
          {
            lex_token: lex_token,
            lex_loc: match$1[0],
            lex_value: match$1[1],
            lex_errors: list.rev(state.lex_errors_acc),
            lex_comments: list.rev(state.lex_comments_acc)
          }
        ];
}

function lex_error(env, loc, err) {
  var lex_errors_acc_0 = [
    loc,
    err
  ];
  var lex_errors_acc_1 = env.lex_state.lex_errors_acc;
  var lex_errors_acc = {
    hd: lex_errors_acc_0,
    tl: lex_errors_acc_1
  };
  var init = env.lex_state;
  return {
          lex_source: env.lex_source,
          lex_lb: env.lex_lb,
          lex_in_comment_syntax: env.lex_in_comment_syntax,
          lex_enable_comment_syntax: env.lex_enable_comment_syntax,
          lex_state: {
            lex_errors_acc: lex_errors_acc,
            lex_comments_acc: init.lex_comments_acc
          }
        };
}

function unexpected_error(env, loc, value) {
  return lex_error(env, loc, {
              TAG: /* UnexpectedToken */1,
              _0: value
            });
}

function unexpected_error_w_suggest(env, loc, value, suggest) {
  return lex_error(env, loc, {
              TAG: /* UnexpectedTokenWithSuggestion */2,
              _0: value,
              _1: suggest
            });
}

function illegal(env, loc) {
  return lex_error(env, loc, {
              TAG: /* UnexpectedToken */1,
              _0: "ILLEGAL"
            });
}

function illegal_number(env, lexbuf, word, token) {
  var loc = loc_bs.from_lb(env.lex_source, lexbuf);
  yyback(word.length, lexbuf);
  var env$1 = lex_error(env, loc, {
        TAG: /* UnexpectedToken */1,
        _0: "ILLEGAL"
      });
  return [
          env$1,
          token
        ];
}

var No_good = caml_exceptions.create("Lexer_flow.FloatOfString.No_good");

function eat(f) {
  var match = f.todo;
  if (match) {
    return {
            negative: f.negative,
            mantissa: f.mantissa,
            exponent: f.exponent,
            decimal_exponent: f.decimal_exponent,
            todo: match.tl
          };
  }
  throw {
        RE_EXN_ID: No_good,
        Error: new Error()
      };
}

function start(str) {
  var todo = {
    contents: /* [] */0
  };
  string.iter((function (c) {
          todo.contents = {
            hd: c,
            tl: todo.contents
          };
          
        }), str);
  return {
          negative: false,
          mantissa: 0,
          exponent: 0,
          decimal_exponent: undefined,
          todo: list.rev(todo.contents)
        };
}

function parse_sign(f) {
  var match = f.todo;
  if (!match) {
    return f;
  }
  switch (match.hd) {
    case 43 :
        return eat(f);
    case 44 :
        return f;
    case 45 :
        var init = eat(f);
        return {
                negative: true,
                mantissa: init.mantissa,
                exponent: init.exponent,
                decimal_exponent: init.decimal_exponent,
                todo: init.todo
              };
    default:
      return f;
  }
}

function parse_hex_symbol(f) {
  var match = f.todo;
  if (match) {
    if (match.hd !== 48) {
      throw {
            RE_EXN_ID: No_good,
            Error: new Error()
          };
    }
    var match$1 = match.tl;
    if (match$1) {
      var match$2 = match$1.hd;
      if (match$2 === 88) {
        return eat(eat(f));
      }
      if (match$2 !== 120) {
        throw {
              RE_EXN_ID: No_good,
              Error: new Error()
            };
      }
      return eat(eat(f));
    }
    throw {
          RE_EXN_ID: No_good,
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: No_good,
        Error: new Error()
      };
}

function parse_exponent(f) {
  var todo_str = string.concat("", list.map(char.escaped, f.todo));
  var exponent;
  try {
    exponent = caml_format.caml_int_of_string(todo_str);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      throw {
            RE_EXN_ID: No_good,
            Error: new Error()
          };
    }
    throw exn;
  }
  return {
          negative: f.negative,
          mantissa: f.mantissa,
          exponent: exponent,
          decimal_exponent: f.decimal_exponent,
          todo: /* [] */0
        };
}

function parse_body(_f) {
  while(true) {
    var f = _f;
    var match = f.todo;
    if (!match) {
      return f;
    }
    var c = match.hd;
    if (c >= 81) {
      if (c !== 95) {
        if (c === 112) {
          return parse_exponent(eat(f));
        }
        
      } else {
        _f = eat(f);
        continue ;
      }
    } else if (c !== 46) {
      if (c >= 80) {
        return parse_exponent(eat(f));
      }
      
    } else {
      if (f.decimal_exponent === undefined) {
        var init = eat(f);
        _f = {
          negative: init.negative,
          mantissa: init.mantissa,
          exponent: init.exponent,
          decimal_exponent: 0,
          todo: init.todo
        };
        continue ;
      }
      throw {
            RE_EXN_ID: No_good,
            Error: new Error()
          };
    }
    var ref_char_code;
    if (c >= /* "0" */48 && c <= /* "9" */57) {
      ref_char_code = /* "0" */48;
    } else if (c >= /* "A" */65 && c <= /* "F" */70) {
      ref_char_code = 55;
    } else if (c >= /* "a" */97 && c <= /* "f" */102) {
      ref_char_code = 87;
    } else {
      throw {
            RE_EXN_ID: No_good,
            Error: new Error()
          };
    }
    var value = c - ref_char_code | 0;
    var e = f.decimal_exponent;
    var decimal_exponent = e !== undefined ? e - 4 | 0 : undefined;
    var mantissa = (f.mantissa << 4) + value | 0;
    var init$1 = eat(f);
    _f = {
      negative: init$1.negative,
      mantissa: mantissa,
      exponent: init$1.exponent,
      decimal_exponent: decimal_exponent,
      todo: init$1.todo
    };
    continue ;
  }}

function float_of_string$1(str) {
  try {
    return caml_format.caml_float_of_string(str);
  }
  catch (e){
    if (sys.win32) {
      try {
        var f = parse_body(parse_hex_symbol(parse_sign(start(str))));
        if (f.todo !== /* [] */0) {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "lexer_flow.mll",
                  556,
                  4
                ],
                Error: new Error()
              };
        }
        var ret = f.mantissa;
        var decimal_exponent = f.decimal_exponent;
        var exponent = decimal_exponent !== undefined ? f.exponent + decimal_exponent | 0 : f.exponent;
        var ret$1 = exponent === 0 ? ret : Math.pow(ret, exponent);
        if (f.negative) {
          return -ret$1;
        } else {
          return ret$1;
        }
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === No_good) {
          throw e;
        }
        throw exn;
      }
    } else {
      throw e;
    }
  }
}

var FloatOfString = {
  float_of_string: float_of_string$1
};

function save_comment(env, start, _end, buf, multiline) {
  var loc = loc_bs.btwn(start, _end);
  var s = buffer.contents(buf);
  var c = multiline ? ({
        TAG: /* Block */0,
        _0: s
      }) : ({
        TAG: /* Line */1,
        _0: s
      });
  var lex_comments_acc_0 = [
    loc,
    c
  ];
  var lex_comments_acc_1 = env.lex_state.lex_comments_acc;
  var lex_comments_acc = {
    hd: lex_comments_acc_0,
    tl: lex_comments_acc_1
  };
  var init = env.lex_state;
  return {
          lex_source: env.lex_source,
          lex_lb: env.lex_lb,
          lex_in_comment_syntax: env.lex_in_comment_syntax,
          lex_enable_comment_syntax: env.lex_enable_comment_syntax,
          lex_state: {
            lex_errors_acc: init.lex_errors_acc,
            lex_comments_acc: lex_comments_acc
          }
        };
}

function unicode_fix_cols(lb) {
  var count = function (_start, stop, _acc) {
    while(true) {
      var acc = _acc;
      var start = _start;
      if (start === stop) {
        return acc;
      }
      var c = caml_bytes.get(lb.lex_buffer, start);
      var acc$1 = (c & 192) === 128 ? acc + 1 | 0 : acc;
      _acc = acc$1;
      _start = start + 1 | 0;
      continue ;
    }  };
  var bytes = count(lb.lex_start_pos, lb.lex_curr_pos, 0);
  var new_bol = lb.lex_curr_p.pos_bol + bytes | 0;
  var init = lb.lex_curr_p;
  lb.lex_curr_p = {
    pos_fname: init.pos_fname,
    pos_lnum: init.pos_lnum,
    pos_bol: new_bol,
    pos_cnum: init.pos_cnum
  };
  
}

function oct_to_int(x) {
  if (x > 55 || x < 48) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "lexer_flow.mll",
            614,
            11
          ],
          Error: new Error()
        };
  }
  return x - /* "0" */48 | 0;
}

function hexa_to_int(x) {
  if (x >= 65) {
    if (x >= 97) {
      if (x < 103) {
        return (x - /* "a" */97 | 0) + 10 | 0;
      }
      
    } else if (x < 71) {
      return (x - /* "A" */65 | 0) + 10 | 0;
    }
    
  } else if (!(x > 57 || x < 48)) {
    return x - /* "0" */48 | 0;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "lexer_flow.mll",
          620,
          11
        ],
        Error: new Error()
      };
}

function utf16to8(code) {
  if (code >= 65536) {
    return {
            hd: char.chr(240 | (code >>> 18)),
            tl: {
              hd: char.chr(128 | (code >>> 12) & 63),
              tl: {
                hd: char.chr(128 | (code >>> 6) & 63),
                tl: {
                  hd: char.chr(128 | code & 63),
                  tl: /* [] */0
                }
              }
            }
          };
  } else if (code >= 2048) {
    return {
            hd: char.chr(224 | (code >>> 12)),
            tl: {
              hd: char.chr(128 | (code >>> 6) & 63),
              tl: {
                hd: char.chr(128 | code & 63),
                tl: /* [] */0
              }
            }
          };
  } else if (code >= 128) {
    return {
            hd: char.chr(192 | (code >>> 6)),
            tl: {
              hd: char.chr(128 | code & 63),
              tl: /* [] */0
            }
          };
  } else {
    return {
            hd: char.chr(code),
            tl: /* [] */0
          };
  }
}

function mk_num_singleton(number_type, num, neg) {
  var value;
  if (number_type !== 0) {
    switch (number_type - 1 | 0) {
      case /* BINARY */0 :
          value = caml_int64.to_float(caml_format.caml_int64_of_string("0o" + num));
          break;
      case /* LEGACY_OCTAL */1 :
          value = caml_int64.to_float(caml_format.caml_int64_of_string(num));
          break;
      case /* OCTAL */2 :
          value = float_of_string$1(num);
          break;
      
    }
  } else {
    value = caml_int64.to_float(caml_format.caml_int64_of_string(num));
  }
  var value$1 = neg === "" ? value : -value;
  return {
          TAG: /* T_NUMBER_SINGLETON_TYPE */5,
          _0: number_type,
          _1: value$1
        };
}

var keywords = hashtbl.create(undefined, 53);

var type_keywords = hashtbl.create(undefined, 53);

list.iter((function (param) {
        return hashtbl.add(keywords, param[0], param[1]);
      }), {
      hd: [
        "function",
        /* T_FUNCTION */15
      ],
      tl: {
        hd: [
          "if",
          /* T_IF */16
        ],
        tl: {
          hd: [
            "in",
            /* T_IN */17
          ],
          tl: {
            hd: [
              "instanceof",
              /* T_INSTANCEOF */18
            ],
            tl: {
              hd: [
                "return",
                /* T_RETURN */19
              ],
              tl: {
                hd: [
                  "switch",
                  /* T_SWITCH */20
                ],
                tl: {
                  hd: [
                    "this",
                    /* T_THIS */21
                  ],
                  tl: {
                    hd: [
                      "throw",
                      /* T_THROW */22
                    ],
                    tl: {
                      hd: [
                        "try",
                        /* T_TRY */23
                      ],
                      tl: {
                        hd: [
                          "var",
                          /* T_VAR */24
                        ],
                        tl: {
                          hd: [
                            "while",
                            /* T_WHILE */25
                          ],
                          tl: {
                            hd: [
                              "with",
                              /* T_WITH */26
                            ],
                            tl: {
                              hd: [
                                "const",
                                /* T_CONST */27
                              ],
                              tl: {
                                hd: [
                                  "let",
                                  /* T_LET */28
                                ],
                                tl: {
                                  hd: [
                                    "null",
                                    /* T_NULL */29
                                  ],
                                  tl: {
                                    hd: [
                                      "false",
                                      /* T_FALSE */30
                                    ],
                                    tl: {
                                      hd: [
                                        "true",
                                        /* T_TRUE */31
                                      ],
                                      tl: {
                                        hd: [
                                          "break",
                                          /* T_BREAK */32
                                        ],
                                        tl: {
                                          hd: [
                                            "case",
                                            /* T_CASE */33
                                          ],
                                          tl: {
                                            hd: [
                                              "catch",
                                              /* T_CATCH */34
                                            ],
                                            tl: {
                                              hd: [
                                                "continue",
                                                /* T_CONTINUE */35
                                              ],
                                              tl: {
                                                hd: [
                                                  "default",
                                                  /* T_DEFAULT */36
                                                ],
                                                tl: {
                                                  hd: [
                                                    "do",
                                                    /* T_DO */37
                                                  ],
                                                  tl: {
                                                    hd: [
                                                      "finally",
                                                      /* T_FINALLY */38
                                                    ],
                                                    tl: {
                                                      hd: [
                                                        "for",
                                                        /* T_FOR */39
                                                      ],
                                                      tl: {
                                                        hd: [
                                                          "class",
                                                          /* T_CLASS */40
                                                        ],
                                                        tl: {
                                                          hd: [
                                                            "extends",
                                                            /* T_EXTENDS */41
                                                          ],
                                                          tl: {
                                                            hd: [
                                                              "static",
                                                              /* T_STATIC */42
                                                            ],
                                                            tl: {
                                                              hd: [
                                                                "else",
                                                                /* T_ELSE */43
                                                              ],
                                                              tl: {
                                                                hd: [
                                                                  "new",
                                                                  /* T_NEW */44
                                                                ],
                                                                tl: {
                                                                  hd: [
                                                                    "delete",
                                                                    /* T_DELETE */45
                                                                  ],
                                                                  tl: {
                                                                    hd: [
                                                                      "typeof",
                                                                      /* T_TYPEOF */46
                                                                    ],
                                                                    tl: {
                                                                      hd: [
                                                                        "void",
                                                                        /* T_VOID */47
                                                                      ],
                                                                      tl: {
                                                                        hd: [
                                                                          "enum",
                                                                          /* T_ENUM */48
                                                                        ],
                                                                        tl: {
                                                                          hd: [
                                                                            "export",
                                                                            /* T_EXPORT */49
                                                                          ],
                                                                          tl: {
                                                                            hd: [
                                                                              "import",
                                                                              /* T_IMPORT */50
                                                                            ],
                                                                            tl: {
                                                                              hd: [
                                                                                "super",
                                                                                /* T_SUPER */51
                                                                              ],
                                                                              tl: {
                                                                                hd: [
                                                                                  "implements",
                                                                                  /* T_IMPLEMENTS */52
                                                                                ],
                                                                                tl: {
                                                                                  hd: [
                                                                                    "interface",
                                                                                    /* T_INTERFACE */53
                                                                                  ],
                                                                                  tl: {
                                                                                    hd: [
                                                                                      "package",
                                                                                      /* T_PACKAGE */54
                                                                                    ],
                                                                                    tl: {
                                                                                      hd: [
                                                                                        "private",
                                                                                        /* T_PRIVATE */55
                                                                                      ],
                                                                                      tl: {
                                                                                        hd: [
                                                                                          "protected",
                                                                                          /* T_PROTECTED */56
                                                                                        ],
                                                                                        tl: {
                                                                                          hd: [
                                                                                            "public",
                                                                                            /* T_PUBLIC */57
                                                                                          ],
                                                                                          tl: {
                                                                                            hd: [
                                                                                              "yield",
                                                                                              /* T_YIELD */58
                                                                                            ],
                                                                                            tl: {
                                                                                              hd: [
                                                                                                "debugger",
                                                                                                /* T_DEBUGGER */59
                                                                                              ],
                                                                                              tl: {
                                                                                                hd: [
                                                                                                  "declare",
                                                                                                  /* T_DECLARE */60
                                                                                                ],
                                                                                                tl: {
                                                                                                  hd: [
                                                                                                    "type",
                                                                                                    /* T_TYPE */61
                                                                                                  ],
                                                                                                  tl: {
                                                                                                    hd: [
                                                                                                      "of",
                                                                                                      /* T_OF */62
                                                                                                    ],
                                                                                                    tl: {
                                                                                                      hd: [
                                                                                                        "async",
                                                                                                        /* T_ASYNC */63
                                                                                                      ],
                                                                                                      tl: {
                                                                                                        hd: [
                                                                                                          "await",
                                                                                                          /* T_AWAIT */64
                                                                                                        ],
                                                                                                        tl: /* [] */0
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

list.iter((function (param) {
        return hashtbl.add(type_keywords, param[0], param[1]);
      }), {
      hd: [
        "static",
        /* T_STATIC */42
      ],
      tl: {
        hd: [
          "typeof",
          /* T_TYPEOF */46
        ],
        tl: {
          hd: [
            "any",
            /* T_ANY_TYPE */110
          ],
          tl: {
            hd: [
              "mixed",
              /* T_MIXED_TYPE */111
            ],
            tl: {
              hd: [
                "empty",
                /* T_EMPTY_TYPE */112
              ],
              tl: {
                hd: [
                  "bool",
                  /* T_BOOLEAN_TYPE */113
                ],
                tl: {
                  hd: [
                    "boolean",
                    /* T_BOOLEAN_TYPE */113
                  ],
                  tl: {
                    hd: [
                      "true",
                      /* T_TRUE */31
                    ],
                    tl: {
                      hd: [
                        "false",
                        /* T_FALSE */30
                      ],
                      tl: {
                        hd: [
                          "number",
                          /* T_NUMBER_TYPE */114
                        ],
                        tl: {
                          hd: [
                            "string",
                            /* T_STRING_TYPE */115
                          ],
                          tl: {
                            hd: [
                              "void",
                              /* T_VOID_TYPE */116
                            ],
                            tl: {
                              hd: [
                                "null",
                                /* T_NULL */29
                              ],
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

var __ocaml_lex_tables = {
  lex_base: "\0\0\xb2\xff\xb3\xff\xb9\xffB\0C\0T\0W\0F\0I\0J\0K\0M\0e\0\xdd\xff\xde\xff\xdf\xff\xe0\xff\xe3\xff\xe4\xff\xe5\xff\xe6\xff\xe7\xff\xe8\xff\xc0\0L\0e\0\x17\x01n\x01\xf6\xff\xf7\xffl\0u\0v\0\0\0\x0e\0\x0f\0\x07\x003\x01\xfe\xff\xff\xff\x01\0\x12\0(\0\f\0\x15\0*\0\f\0=\0-\0\t\0\xb6\xff\xf9\xff\xe0\x01B\0u\0\x0f\x000\x004\0\x17\0\xe5\x01(\x008\0\x1a\0K\0:\0\x17\0\xfb\xffh\0a\0\xac\0q\0m\0y\0q\0i\0{\0{\0\xa8\0\xca\xff\xfa\xff\xc9\xff\xf8\xff\x0b\x02\xa5\x02\xfc\x02S\x03\xaa\x03\x01\x04X\x04\xaf\x04\x06\x05]\x05\xb4\x05\x0b\x06b\x06\xb9\x06\xc3\x01\x10\x07g\x07\xbe\x07\x15\bl\b\xc3\b\x1a\tq\t\xc8\t\xb8\0\xe2\xffE\x02\xc7\xff\xdc\xff\xc6\xff\xdb\xff\xb7\xff\xaa\0\xda\xff\xab\0\xd9\xff\xac\0\xd8\xff\xd2\xff\xad\0\xd7\xff\xb0\0\xd0\xff\xcf\xff\xcc\xff\xd4\xff\xcb\xff\xd3\xff\xc8\xff\xc5\xff:\n\xcc\xff\xcd\xff\xcf\xff\xd3\xff\xb0\0\xd9\xff\xda\xff\xdd\xff\xde\xff\xdf\xff\xe0\xff\xe3\xff\xe4\xff~\0\xe7\xff\x80\0\xe9\xff\xea\xff\x9a\0\x94\n\xfa\n\xd6\x01Q\x0b\xa8\x0b\x1a\f\xf9\xff\xcf\0\xf1\0D\0\x9c\0\x9d\0\xa3\0\xc4\x0b\xff\xff\x83\0\xc1\0\xd1\0\xf9\0\xb4\0\xc4\0\xa7\0\xcb\t\xd4\0\x96\0\xfa\xff\x1f\f\xea\0\x1d\x01\xb7\0\xf3\0\xf4\0\xfa\0$\f\xe9\0\x15\x01\xf7\0\xdf\x0b\x17\x01\xd9\0\xfc\xff,\x01&\x01{\x01@\x01<\x01H\x01@\x018\x01J\x01d\x01\xfb\xff\xf3\x01\x0f\x01K\x01j\x01c\x01K\f>\x01N\x01P\x01\xec\x0bp\x01?\x01x\f\xff\fV\r\xad\r\0\x02\x04\x0e[\x0e\xb2\x0e\t\x0f`\x0f\xb7\x0f\x0e\x10e\x10\xbc\x10\x13\x11j\x11\xc1\x11\x18\x12o\x12\xc6\x12\x1d\x13t\x13\xcb\x13\"\x14\xd1\x01\xe2\xffy\x14\xd0\x14'\x15~\x15\x99\x01\x9d\x01\xad\x01\xa6\x01\x9f\x01\xeb\xff\xe6\xff\xe5\xff\xd1\xff\x1b\f\xfc\xff\xfd\xff\xfe\xff\xff\xff\xcf\x15\xee\xff\x01\0\xef\xff\x18\x16\xf4\xff\xf5\xff\xf6\xff\xf7\xff\xf8\xff\xf9\xff\xf1\x02H\x03>\x16\xfe\xff\xff\xffU\x16\xfd\xff\x9f\x03\xfc\xff{\x16\x92\x16\xb8\x16\xcf\x16\xf2\xff\xf5\x16\xf1\xff\xd7\x02\xfb\xff\xea\x01\xfe\xff\xff\xff\xe4\x01\xfd\xff\xfc\xff;\x02\xfd\xff\xfe\xff\xff\xff\0\x17\xf9\xff\xee\x01`\x01\x9c\x01\xa0\x01*\x02)\fC\x15\xfe\xff\xff\xffc\x01\xad\x01\xc7\x01+\x02\xa0\x01\xba\x01\xaa\x01\x87\x15\xca\x01\xa7\x01\xfb\xff\xfc\xff\x0b\x16\xf8\xff\x04\0\xf9\xff\xfa\xff8\x17,\x03\xff\xff\xfd\xff\x05\0\xfe\xff\xc0\x17\x96\t\xfb\xff\xfc\xff\x0b\x02\xff\xff\xfd\xff\xfe\xff2\x18\xf1\xff\xf2\xff\x8a\x18\xf4\xff\xf5\xff\xf6\xff\xf7\xff\xf8\xff\xfa\xffv\x02\xb0\x01!\x02\"\x023\x02\x88\x167\x18\xfe\xff\xff\xff\x05\x02L\x02_\x02\xf3\x02@\x02Q\x02C\x02\xbd\x16c\x02%\x02\xfb\xff\xfc\xff|\f\xfb\xff\xfc\xff\xfd\xff\xfe\xff\x06\0\xff\xff\xfc\x18\xf9\xff\xf8\x18\x07\0\xfd\xff\xfe\xff\xff\xffO\x19\xdf\n_\f\x84\x17\x9c\x19\xfc\xff\xfb\xff\xd3\x19\xfa\xff*\x1a\x81\x1a\xd8\x1a/\x1b\x86\x1b\xaa\x02\xf8\x1b\xfa\xff\xfb\xff\xd6\x02G\x02\x83\x02\xa9\x02J\x03\x04\x19K\x1b\xff\xffp\x02\xb7\x02\xd7\x02\x8d\x03\xaa\x02\xba\x02\x9d\x02\xc9\x16\xd9\x02\x9b\x02\xfc\xff\xfd\xff\xc3\x16\xf9\xff\xfa\xff\b\0\xfc\xff\xe1\x02\xfe\xff\xff\xff\xfd\xff\xfb\xff",
  lex_backtrk: "\xff\xff\xff\xff\xff\xff\xff\xffD\0A\0>\0=\0<\0;\0E\0G\0B\0C\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\0K\0\x1e\0\x15\0\x15\0\xff\xff\xff\xffM\0?\0J\0M\0M\0M\0M\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff\xff\xff\xff\xff\xff\xff\x14\0\x14\0\x15\0\x14\0\x0f\0\x14\0\x14\0\x0b\0\n\0\r\0\f\0\x0e\0\x0e\0\x0e\0\xff\xff\x0e\0\x0e\0\x13\0\x12\0\x11\0\x10\0\x15\0\x13\0\x12\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\0\xff\xff*\0\xff\xff.\0\xff\xff\xff\xff2\0\xff\xff1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff+\0\xff\xff\x17\0\xff\xff\xff\xff3\0\x13\0\x13\0\x1e\0\x12\0\x12\x001\0\xff\xff)\x003\x003\x003\x003\x003\0\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x02\0\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x12\0\x11\0\x11\0\x10\0\xff\xff\x10\0\x0f\0\x0f\0\x12\0\x11\0\f\0\x11\0\x11\0\b\0\x07\0\n\0\t\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0e\0\r\0\xff\xff\xff\xff\x13\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x10\0\xff\xff\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\0\x05\0\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\x06\0\x06\0\x06\0\x06\0\x02\0\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\xff\xff\xff\xff\x04\0\x07\0\xff\xff\xff\xff\x01\0\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x0e\0\x0e\0\x0e\0\x0e\0\x02\0\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\x06\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x01\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x06\0\xff\xff\xff\xff\xff\xff\xff\xff",
  lex_default: "\x01\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\x01\x01\0\0\0\0\0\0\0\0\x06\x01\0\0\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0!\x01\0\0\xff\xff\0\0\0\0\xff\xff\0\0\0\0)\x01\0\0\0\0\0\0-\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0D\x01\0\0\xff\xff\0\0\0\0\xff\xffK\x01\0\0\0\0\xff\xff\0\0\xff\xffP\x01\0\0\0\0\xff\xff\0\0\0\0\0\0W\x01\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0v\x01\0\0\0\0\0\0\0\0\xff\xff\0\0}\x01\0\0\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x93\x01\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xaa\x01\0\0\0\0\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0",
  lex_trans: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0(\0\b\x01&\0&\0F\x01M\x01{\x01\x80\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0\n\0\x1e\0\x1f\0\x18\0\x05\0\r\0\x1e\0\x15\0\x14\0 \0\x07\0\x10\0\x06\0\x1a\0!\0\x1c\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x0f\0\x11\0\t\0\x0b\0\b\0\x0e\0\x19\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x13\0'\0\x12\0\x04\0\x18\0\x1d\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x17\0\f\0\x16\0\x03\0\x84\0\x83\0\x82\0\x80\0{\0z\0w\0x\0u\0s\0r\0p\0o\0m\0R\x001\x000\0/\0\x81\x001\0k\0\x7f\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0N\x005\0.\0n\0&\0P\x004\0.\0-\x000\0/\0&\0&\0-\0&\0D\0C\0A\0>\0O\x003\0@\0?\0<\0=\0<\0<\0<\x002\x002\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0q\0B\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0E\0F\0G\0H\0I\0J\0K\0L\0M\0C\0%\0$\0#\0\x18\0Q\0l\0t\0v\0y\0}\0|\0&\0~\0\xff\0\"\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0<\0\xfe\0\xfd\0\xf7\0\xcc\0\xb1\0\x02\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xb3\0\xb0\0\xaf\0\xae\0\x18\0\xb2\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0S\0&\0\xad\0\xb1\0&\0&\0\xb0\0\xa6\0\xac\0\xa6\0U\0\xa6\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\xaf\0\xae\0&\0\xa6\0\xa6\0\xc2\0\xc1\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xc0\0\xbf\0\xbe\0\xbd\0S\0\xba\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xad\0\xbc\0\xba\0\xba\0\xba\0\xba\0\xac\0\xbb\0\xc3\0U\0\xc4\0W\0W\0W\0W\0W\0W\0W\0W\0\x1b\0\x1b\0\xc5\0\xc6\0\xc7\0\xc8\0\xc9\0\xca\0\xcb\0S\0Y\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0X\0S\0S\0S\0S\0S\0S\0S\0S\0V\0S\0S\0\xc1\0\xd8\0\xd7\0\xd2\0S\0\xd2\0S\0Y\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0X\0S\0S\0S\0S\0S\0S\0S\0S\0V\0S\0S\0<\0\xd6\0\xd5\0<\0<\0<\0\xd2\0\xd2\0<\0<\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xd4\0\xd2\0\xf2\0<\0\xf8\0\xf9\0\xd3\0\xf1\0<\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xfa\0\xfb\0\xfc\0'\x01,\0+\0*\0%\x01A\x01&\x017\0@\x01?\x01B\x01@\x017\0>\x01=\x01)\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0?\x013\x01S\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\x003\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0*\x016\0>\x01=\x013\x013\x016\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\x003\x01U\x01T\x01\x18\0S\0r\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0s\x01q\x01p\x01o\x01\x18\0t\x01\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0r\x01;\0:\x009\0<\x01<\x01;\0:\x009\0S\0;\x01;\x01q\x01n\x01e\x018\0a\0e\x01a\0m\x018\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0p\x01o\x01#\x01e\x01e\x01e\x01\x8b\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xa7\x01\"\x01\xa6\x01\xa5\x01S\0\xa8\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\xa4\x01\xa3\x01\xa6\x01h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0M\x01\xa5\x01\x9a\x01L\x01\x9a\x01+\x01\x9a\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xa4\x01\xa3\x01\x9a\x01\x9a\x01S\0\xb1\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\0\0\0\0\0\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0n\x01\0\0\0\0\0\0\0\0\0\0m\x01f\0f\0f\0f\0f\0f\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0f\0f\0f\0f\0f\0f\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0_\0\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01$\x01U\0\0\0W\0W\0W\0W\0W\0W\0W\0W\0^\0^\0\xa2\x01\0\0\0\0\0\0\0\0\0\0\xa1\x01_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0S\0\0\0\xa2\x01\0\0\0\0\0\0\0\0\xff\xff\xa1\x01\0\0\0\0\0\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0S\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Z\0Z\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Z\0Z\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0[\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0[\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0]\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0]\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0U\0\0\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0a\0\0\0a\0\0\0\0\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0c\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0c\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0e\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0e\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0g\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0f\0f\0f\0f\0f\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0g\0\0\0f\0f\0f\0f\0f\0f\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0g\0\0\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0j\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0j\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0\0\0R\x01Q\x01\0\0\0\0\0\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0j\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\xa6\0\xa7\0\0\0\xa6\0\xa6\0\0\0\0\0\0\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\0\0\0\0\0\0\0\0\xa6\0\0\0\x9f\0\0\0\x99\0\x98\0\x89\0\x9f\0\x92\0\x91\0\xa0\0\x88\0\x8f\0\x9e\0\x9b\0\xa1\0\x9d\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x8e\0\x90\0\x8c\0\x8a\0\x8b\0\x8d\0\xa6\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x97\0S\x01\x96\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x9a\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x95\0\x93\0\x94\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\0\0\0\0\xa5\0\xa4\0\xa3\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa2\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\x86\x01\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xf3\0\x99\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xa6\0\0\0\0\0\xa6\0\xa6\0\0\0\0\0\0\0\0\0\xe1\0\0\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\x9c\0\x9c\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\xda\0\xe5\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe4\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe2\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xe5\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe4\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe2\0\xda\0\xda\0\xd2\0\0\0\x02\x01\xd2\0\xd2\0\xba\0\0\0\0\0\xba\0\xba\0\xba\0\0\0\0\0\xba\0\xba\x003\x01\0\0\0\x003\x013\x01\0\0\0\0\0\0\xd2\0\0\0\0\0\x04\x01\0\0\xba\0\0\0\0\0\x04\x01\0\0\xba\0\0\0\0\0\0\0\xcd\x003\x01\x9d\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xd2\0\0\0\0\0\xd2\0\xd2\0\xb5\0\0\0\0\0\0\0\0\0\xb5\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\0\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\x03\x01\0\0\xcd\0\0\0\x9d\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xb4\0{\x01\0\0\0\0z\x01\xb4\0\0\0\0\0\0\0\xba\0\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\0\0\x89\x01\xd2\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xab\0\xaa\0\xa9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\0\0\xa8\0\0\0\0\0\0\0\0\0x\x01\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0w\x01\0\0\0\0\0\0\xd1\0\xd0\0\xcf\0\0\0\0\0\xb9\0\xb8\0\xb7\0\0\0\0\0\xb9\0\xb8\0\xb7\0\0\0\xce\0:\x019\x018\x01\0\0\xb6\0\0\0\0\0\0\0\0\0\xb6\0\0\0\0\0\0\0\0\x007\x01\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd1\0\xd0\0\xcf\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\xce\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0y\x01\0\0\0\0\0\0\0\0\xdd\0\0\0\xdd\0\0\0\0\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\xe6\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\xe6\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\xe9\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\xe9\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xdd\0\0\0\xdd\0\0\0\0\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\xf0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\xf0\0\0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xf4\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\xf5\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\x003\x015\x01\0\x003\x013\x01\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\x003\x01\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xf6\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\b\x01\0\0\0\0\x07\x01\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x013\x013\x013\x013\x013\x013\x013\x013\x013\x013\x013\x01\0\0\0\0\0\0F\x01\0\0\0\0E\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0:\x019\x018\x01\0\0\0\0\0\0\0\0\x13\x01\0\0\0\0\0\0\0\0\0\0\x0f\x017\x01\0\0\0\0\x0e\x013\x01\0\0\0\0\0\0H\x01\0\0\0\0\r\x01\0\0\0\0\0\0\f\x01\0\0\x0b\x01\t\x01\n\x01\0\0\x12\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0G\x01I\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0e\x01\0\0\x19\x01e\x01e\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0e\x01\0\0\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\0\0\xab\x01\0\0\x14\x01\xac\x01\0\0\0\0\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\0\0\0\0\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\0\0\0\0\0\0\0\0\0\0\xae\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\0\0\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x013\x015\x01J\x013\x014\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\0\0\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\xad\x013\x01\0\0\0\0\xaf\x01\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01.\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\0\0e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01\0\0\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\0\0\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01N\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0l\x01k\x01j\x01e\x01\0\0\0\0\0\0\0\0\0\0\x1f\x01\0\0\0\0\0\0\0\0i\x01\x9a\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\0\0\0\0\0\0\0\0N\x01\0\0N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\xb0\x01\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\x011\x010\x01N\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0/\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x006\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\0\0\0\0\0\0\0\0N\x01\0\0N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01e\x01g\x01\0\0e\x01f\x01e\x01g\x01\0\0e\x01e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\x01\0\0X\x01\0\0Y\x01e\x01\0\0X\x01\0\0\0\0\0\0\0\0\0\0\0\0[\x01`\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\x01\0\0_\x01Z\x01^\x01\0\0\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\0\0\0\0\0\0Y\x01\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01]\x01Y\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Y\x01\0\0\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\0\0\0\0\0\0Y\x01\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\x80\x01\0\0\0\0\x7f\x01\0\0\0\0\0\0\x9a\x01\0\0\0\0\x9a\x01\x9a\x01\0\0d\x01c\x01b\x01\0\0\0\0l\x01k\x01j\x01\x84\x01\x83\x01\0\0\x82\x01\0\0\0\0a\x01~\x01\x82\x01\x9a\x01\0\0i\x01\0\0\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01h\x01\0\0\0\0\0\0\0\0\0\0\x82\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\0\0\0\0\0\0\0\0\x83\x01\0\0\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x8a\x01\0\0\0\0\0\0\x82\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\0\0\0\0\0\0\0\0\x8a\x01\0\0\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\x88\x01\0\0\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\xa0\x01\x9f\x01\x9e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9d\x01\0\0\0\0\0\0\x8c\x01\0\0\0\0\0\0\0\0\x81\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\0\0\0\0\0\0\0\0\x8c\x01\0\0\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\0\0\0\0\0\0\0\0\x8d\x01\0\0\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\0\0\0\0\0\0\0\0\x8e\x01\0\0\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\0\0\0\0\0\0\0\0\x8f\x01\0\0\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x90\x01\x9a\x01\x9c\x01\0\0\x9a\x01\x9a\x01\0\0\0\0\0\0\0\0\0\0\0\0\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\0\0\x8b\x01\x9a\x01\0\0\0\0\0\0\0\0\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\0\0\0\0\0\0\0\0\x90\x01\0\0\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x91\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\0\0\0\0\0\0\0\0\x91\x01\0\0\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x9a\x01\x9c\x01\0\0\x9a\x01\x9b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x95\x01\0\0\0\0\0\0\0\0\xa0\x01\x9f\x01\x9e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x94\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\x01\x98\x01\x97\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x96\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff",
  lex_check: "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\x07\x01\0\0\0\0E\x01L\x01z\x01\x7f\x01\xac\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x05\0\x06\0\x07\0\b\0\b\0\t\0\t\0\n\0\x0b\0\x0b\0\f\0\r\0\x19\0\x1f\0#\0$\0$\0\x06\0*\0\x1a\0\x07\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0 \0!\0%\0\r\0-\0 \0!\0,\0%\0+\0+\0.\0/\0,\x001\x006\x007\x009\0;\0 \0!\0:\0:\0=\0;\0>\0?\0A\0\"\0)\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x002\0\f\x008\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0B\0D\0E\0F\0G\0H\0I\0J\0K\0L\0M\0\0\0\0\0\0\0\x18\0N\0k\0s\0u\0w\0z\0z\x000\0|\0\x8a\0\0\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0@\0\x93\0\x95\0\x98\0\xa0\0\xa2\0\0\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xa1\0\xa3\0\xa4\0\xa4\0\x18\0\xa1\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x1b\0&\0\xa5\0\xa8\0&\0&\0\xa9\0\xac\0\xa5\0\xad\0\x1b\0\xae\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\xaa\0\xaa\0&\0\xb0\0\xb1\0\xb4\0\xb5\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\xb6\0\xb7\0\xb8\0\xb8\0\x1b\0\xbb\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1c\0\xab\0\xb9\0\xbc\0\xbd\0\xbf\0\xc0\0\xab\0\xb9\0\xc2\0\x1c\0\xc3\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\xc4\0\xc5\0\xc6\0\xc7\0\xc8\0\xc9\0\xca\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\xcb\0\xce\0\xcf\0\xd3\0\x1c\0\xd4\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\x005\0\xd0\0\xd0\x005\x005\0<\0\xd5\0\xd7\0<\0<\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xd1\0\xd8\0\xf1\x005\0\xf7\0\xf8\0\xd1\0\x9b\0<\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\xf9\0\xfa\0\xfb\0%\x01&\0&\0&\0\"\x01.\x01\"\x015\0/\x010\x01.\x017\x01<\x001\x011\x01&\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\x008\x01;\x01S\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0<\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0(\x015\x009\x019\x01=\x01?\x01<\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0@\x01R\x01R\x01m\0S\0a\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0`\x01b\x01c\x01c\x01m\0`\x01m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0i\x015\x005\x005\x002\x01:\x01<\0<\0<\0T\x002\x01:\x01j\x01d\x01m\x015\0T\0n\x01T\0d\x01<\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0k\x01k\x01 \x01o\x01q\x01r\x01\x91\x01T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0\x95\x01 \x01\x96\x01\x97\x01T\0\x95\x01T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0U\0\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x98\x01\x98\x01\x9d\x01U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0I\x01\x9e\x01\xa1\x01I\x01\xa2\x01(\x01\xa3\x01U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\x9f\x01\x9f\x01\xa5\x01\xa6\x01U\0\xae\x01U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0V\0\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\xff\xff\xff\xff\xff\xffV\0V\0V\0V\0V\0V\0V\0V\0V\0V\0l\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\x01V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\xff\xff\xff\xff\xff\xff\xff\xffV\0\xff\xffV\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0W\0\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01 \x01W\0\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0\x99\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\x01W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0\xff\xff\xff\xff\xff\xff\xff\xffW\0\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0X\0\xff\xff\xa0\x01\xff\xff\xff\xff\xff\xff\xff\xffI\x01\xa0\x01\xff\xff\xff\xff\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0\xff\xff\xff\xff\xff\xff\xff\xffX\0\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0Y\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0\xff\xff\xff\xff\xff\xff\xff\xffY\0\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Z\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0\xff\xff\xff\xff\xff\xff\xff\xffZ\0\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0[\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\xff\xff\xff\xff\xff\xff\xff\xff[\0\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\\\0\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff]\0\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0^\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\0\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\xff\xff\xff\xff\xff\xff\xff\xff^\0\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff_\0\xff\xff_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\xff\xff\xff\xff\xff\xff\xff\xffb\0\xff\xffb\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\xff\xff\xff\xff\xff\xff\xff\xffc\0\xff\xffc\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xff\xff\xff\xff\xff\xff\xff\xffd\0\xff\xffd\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\xff\xff\xff\xff\xff\xff\xff\xffe\0\xff\xffe\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\xff\xff\xff\xff\xff\xff\xff\xfff\0\xff\xfff\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0g\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\xff\xff\xff\xff\xff\xff\xff\xffg\0\xff\xffg\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0h\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffh\0h\0h\0h\0h\0h\0h\0h\0h\0h\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffh\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0\xff\xff\xff\xff\xff\xff\xff\xffh\0\xff\xffh\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0i\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\xff\xff\xff\xff\xff\xff\xff\xffi\0\xff\xffi\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffO\x01O\x01\xff\xff\xff\xff\xff\xff\xff\xffj\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xffj\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\x85\0\x85\0\xff\xff\x85\0\x85\0\xff\xff\xff\xff\xff\xff\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\xff\xff\x85\0\xff\xff\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\xaf\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0O\x01\x85\0\xff\xff\x85\0\xff\xff\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\xff\xff\xff\xff\x85\0\x85\0\x85\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\x84\x01\xff\xff\x9a\0\xff\xff\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9c\0\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xff\xff\xff\xff\xff\xff\xff\xff\x9c\0\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9d\0\xa6\0\xff\xff\xff\xff\xa6\0\xa6\0\xff\xff\xff\xff\xff\xff\xff\xff\x9d\0\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\xff\xff\xa6\0\xff\xff\xff\xff\xff\xff\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\xff\xff\xff\xff\xff\xff\x9d\0\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9e\0\xff\xff\0\x01\x9e\0\x9e\0\xb3\0\xff\xff\xff\xff\xb3\0\xb3\0\xba\0\xff\xff\xff\xff\xba\0\xba\x003\x01\xff\xff\xff\xff3\x013\x01\xff\xff\xff\xff\xff\xff\x9e\0\xff\xff\xff\xff\0\x01\xff\xff\xb3\0\xff\xff\xff\xff\0\x01\xff\xff\xba\0\xff\xff\xff\xff\xff\xff\x9e\x003\x01\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\xd2\0\xff\xff\xff\xff\xd2\0\xd2\0\xb3\0\xff\xff\xff\xff\xff\xff\xff\xff\xba\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xff\xff\xd2\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\0\x01\xff\xff\xd2\0\xff\xff\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xb3\0u\x01\xff\xff\xff\xffu\x01\xba\0\xff\xff\xff\xff\xff\xff\xbe\0\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\xff\xff\x85\x01\xd6\0\xd9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa6\0\xa6\0\xa6\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xff\xff\xa6\0\xff\xff\xff\xff\xff\xff\xff\xffu\x01\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xff\xff\xff\xff\xff\xff\xff\xff\xd9\0\xff\xff\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xff\xff\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\x9e\0\x9e\0\x9e\0\xff\xff\xff\xff\xb3\0\xb3\0\xb3\0\xff\xff\xff\xff\xba\0\xba\0\xba\0\xff\xff\x9e\x003\x013\x013\x01\xff\xff\xb3\0\xff\xff\xff\xff\xff\xff\xff\xff\xba\0\xff\xff\xff\xff\xff\xff\xff\xff3\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xd2\0\xd2\0\xd2\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xff\xff\xd2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xda\0\xff\xff\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xdb\0\xff\xff\xdb\0\xff\xff\xff\xff\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xff\xff\xff\xff\xff\xff\xff\xff\xdb\0\xff\xff\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdc\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xff\xff\xff\xff\xff\xff\xff\xff\xdc\0\xff\xff\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xde\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xff\xff\xff\xff\xff\xff\xff\xff\xde\0\xff\xff\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xdf\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xff\xff\xff\xff\xff\xff\xff\xff\xdf\0\xff\xff\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xe0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xff\xff\xff\xff\xff\xff\xff\xff\xe0\0\xff\xff\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xff\xff\xff\xff\xff\xff\xff\xff\xe1\0\xff\xff\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe3\0\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xff\xff\xff\xff\xff\xff\xff\xff\xe3\0\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xe4\0\xff\xff\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe5\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xff\xff\xff\xff\xff\xff\xff\xff\xe5\0\xff\xff\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xff\xff\xff\xff\xff\xff\xff\xff\xe6\0\xff\xff\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xff\xff\xff\xff\xff\xff\xff\xff\xe7\0\xff\xff\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe8\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xff\xff\xff\xff\xff\xff\xff\xff\xe8\0\xff\xff\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xff\xff\xff\xff\xff\xff\xff\xff\xe9\0\xff\xff\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xea\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xea\0\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xff\xff\xff\xff\xff\xff\xff\xff\xea\0\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xeb\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xff\xff\xff\xff\xff\xff\xff\xff\xeb\0\xff\xff\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xec\0\xff\xff\xec\0\xff\xff\xff\xff\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xff\xff\xff\xff\xff\xff\xff\xff\xec\0\xff\xff\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xed\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xff\xff\xff\xff\xff\xff\xff\xff\xed\0\xff\xff\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xee\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xff\xff\xff\xff\xff\xff\xff\xff\xee\0\xff\xff\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xf0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xff\xff\xff\xff\xff\xff\xff\xff\xf0\0\xff\xff\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xff\xff\xff\xff\xff\xff\xff\xff\xf3\0\xff\xff\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xff\xff\xff\xff\xff\xff\xff\xff\xf4\0\xff\xff\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf5\x004\x014\x01\xff\xff4\x014\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xff\xff\xff\xff\xff\xff\xff\xff\xf5\0\xff\xff\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\x05\x01\xff\xff\xff\xff\x05\x01\xf6\0\xff\xff\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x014\x014\x01\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\x014\x01\xff\xff\xff\xff\x05\x01>\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xff\x05\x01\xff\xff\xff\xff\xff\xff\x05\x01\xff\xff\x05\x01\x05\x01\x05\x01\xff\xff\x05\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffC\x01C\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\xff\xff\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xff\xff\xff\xffe\x01\xff\xff\t\x01e\x01e\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xff\xff\xff\xff\xff\xff\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\xff\xff\xff\xff\xff\xffe\x01\xff\xff\xff\xff\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\xff\xff\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\xff\xff\xa9\x01\xff\xff\x05\x01\xa9\x01\xff\xff\xff\xff\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\xff\xff\xff\xff\xff\xff\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\xff\xff\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01,\x01,\x01C\x01,\x01,\x01\xff\xff\xff\xff\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\xff\xff\xff\xff\xff\xff\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\xa9\x01,\x01\xff\xff\xff\xff\xa9\x01\xff\xff\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01,\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\xff\xffp\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01\xff\xff\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xff\xff\xff\xff\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01H\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\x01e\x01e\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\xff\xff\xff\xff\xff\xff\xff\xffe\x01\xa4\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xffH\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01\xff\xff\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\x01\xff\xff\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\x01,\x01,\x01N\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\xff\xff\xff\xff\xff\xff\xff\xff,\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffN\x01\xff\xffN\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01V\x01V\x01\xff\xffV\x01V\x01f\x01f\x01\xff\xfff\x01f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xffV\x01\xff\xffV\x01f\x01\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01V\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xffV\x01V\x01V\x01\xff\xff\xff\xffV\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xffV\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xffY\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xffY\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\xff\xff|\x01\xff\xff\xff\xff|\x01\xff\xff\xff\xff\xff\xff\x9a\x01\xff\xff\xff\xff\x9a\x01\x9a\x01\xff\xffV\x01V\x01V\x01\xff\xff\xff\xfff\x01f\x01f\x01~\x01~\x01\xff\xff|\x01\xff\xff\xff\xffV\x01|\x01|\x01\x9a\x01\xff\xfff\x01\xff\xff~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01V\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff|\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01\xff\xff\xff\xff\xff\xff\xff\xff~\x01\xff\xff~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01\x83\x01\xff\xff\xff\xff\xff\xff|\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\xff\xff\xff\xff\xff\xff\xff\xff\x83\x01\xff\xff\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\xff\xff\xff\xff\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\xff\xff\x87\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\xff\xff\xff\xff\x9a\x01\x9a\x01\x9a\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9a\x01\xff\xff\xff\xff\xff\xff\x8a\x01\xff\xff\xff\xff\xff\xff\xff\xff|\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\xff\xff\x8a\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8a\x01\xff\xff\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\xff\xff\x8c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8c\x01\xff\xff\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\xff\xff\x8d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x01\xff\xff\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\xff\xff\x8e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8e\x01\xff\xff\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8f\x01\x9b\x01\x9b\x01\xff\xff\x9b\x01\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\xff\xff\x8f\x01\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8f\x01\xff\xff\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x90\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\xff\xff\x90\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\xff\xff\xff\xff\xff\xff\xff\xff\x90\x01\xff\xff\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x92\x01\x92\x01\xff\xff\x92\x01\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x01\x9b\x01\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\x92\x01\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01",
  lex_base_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\x16\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\x01\0\f\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x006\0_\0B\0v\0L\0N\0\0\0\x81\0\0\0\x98\0\0\0\xa2\0\xac\0\xb6\0\0\0\xc0\0\0\0\xca\0\0\0\xe1\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x1a\x01&\x01W\x01\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\x0b\0\r\0\x0f\0\xe5\0\x1a\0\b\0h\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0H\x01\0\0\0\0\0\0\0\0y\x01\r\0\x1c\0\x10\0\x1a\x01\x1d\0E\0\x83\x01\0\0\x8d\x01\x9a\x01\xa4\x01\xae\x01\0\0\0\0\xb8\x01\xc2\x01\xdb\x01\xe5\x01\x89\0\x8b\0\0\0\xf9\x01\0\0\x03\x02\0\0\r\x02\x17\x02\0\0!\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_backtrk_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x0f\0\0\0\x0f\0\0\0\x0f\0\x0f\0\0\0#\0\0\0&\0)\0)\0)\0\0\0)\0)\0\0\0,\0\0\0/\0\0\0\0\0,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\0W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0h\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\0k\0k\0s\0\0\0s\0v\0v\0W\0k\0~\0k\0k\0&\0\x8f\0/\0\x94\0\x99\0\x99\0\x99\0\x99\0\x99\0\x9e\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_default_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_trans_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\0\0\t\0\t\0\t\0\t\0\t\0e\0\0\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\0\0\t\0\0\0\0\0\0\0\0\0e\0\0\0e\0\t\0e\0\0\0\0\0\0\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x01\0\x01\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x01\0\x01\0 \0 \0 \0 \0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0e\0\t\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0e\0e\x002\x002\x002\0\0\0\t\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0e\x002\0\t\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x8c\0\x8c\0\x8c\0\x8c\0\0\0\0\0\t\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x01\0e\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\x002\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\x002\0\0\0\0\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\0\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0M\0\0\0`\0`\0`\0`\0`\0`\0`\0`\0R\0R\x002\0\0\0\0\x002\x002\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\x002\0\0\0\0\x002\x002\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\0\0\0\0\0\0e\0\0\0\0\0\0\0\0\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\0\0\0\0\0\0\0\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0\0\0\0\x002\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0{\0{\0{\0{\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0R\0\0\0\x81\0\x81\0\x81\0\x81\0\x81\0\x81\0\x81\0\x81\0\x86\0\x86\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0R\0\0\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0{\0{\0{\0{\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_check_code: "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0\xff\xff<\x005\x005\0<\0<\0\xb3\0\xff\xff\xba\0\xb3\0\xb3\0\xba\0\xba\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0\xff\xff<\0\xff\xff\xff\xff\xff\xff\xff\xff\xb3\0\xff\xff\xba\0!\0\xa1\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1b\0\xff\xff\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1c\0\xff\xff\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0W\0\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0Y\0Y\0Z\0Z\0>\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0A\0\xbc\0=\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\xbb\0\xbf\0\xd3\0\xd4\0\xd7\0\xff\xff?\0V\0V\0V\0V\0V\0V\0X\0X\0X\0X\0X\0X\0X\0X\0\xbd\0\xd5\0@\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xe5\0\xe5\0\xe6\0\xe6\0\xff\xff\xff\xffB\0V\0V\0V\0V\0V\0V\0^\0\xc0\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\xd8\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0\x85\0\xff\xff\xff\xff\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9c\0\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9d\0\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9e\0\xff\xff\xff\xff\x9e\0\x9e\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9e\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xd2\0\xff\xff\xff\xff\xd2\0\xd2\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\xff\xff\xff\xff\xff\xff\xbe\0\xff\xff\xff\xff\xff\xff\xff\xff\xd2\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xff\xff\xff\xff\xff\xff\xff\xff\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xff\xff\xff\xff\xd6\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe3\0\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xea\0\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  lex_code: "\xff\x01\xff\xff\x03\xff\x01\xff\xff\x02\xff\xff\0\x02\xff\0\x01\xff\x06\xff\xff\x07\xff\xff\x01\xff\x03\xff\xff\x05\xff\xff\x04\xff\xff\0\x04\xff\0\x05\xff\0\x03\xff\0\x06\xff\0\x07\xff\x11\xff\x10\xff\x0e\xff\r\xff\f\xff\x0b\xff\n\xff\t\xff\b\xff\x07\xff\x06\xff\x05\xff\x04\xff\xff\x13\xff\x12\xff\xff\x12\xff\x13\xff\xff\x03\x11\x02\x12\x01\x0f\0\x10\xff\x16\xff\x13\xff\xff\x14\xff\xff\0\x14\xff\x01\x13\0\x0e\xff\x15\xff\xff\0\r\xff\x01\x15\0\f\xff\x19\xff\xff\0\t\xff\x13\xff\x16\xff\xff\x13\xff\xff\x18\xff\xff\x17\xff\xff\x01\x17\0\x04\xff\x01\x18\0\x06\xff\x01\x16\0\b\xff\0\x0b\xff\x01\x19\0\n\xff"
};

function token$1(env, lexbuf) {
  lexbuf.lex_mem = caml_array.caml_make_vect(8, -1);
  return __ocaml_lex_token_rec(env, lexbuf, 0);
}

function line_comment(env, buf, lexbuf) {
  return __ocaml_lex_line_comment_rec(env, buf, lexbuf, 296);
}

function __ocaml_lex_line_comment_rec(env, buf, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          return [
                  env,
                  loc_bs.from_lb(env.lex_source, lexbuf)
                ];
      case 1 :
          var match = loc_bs.from_lb(env.lex_source, lexbuf);
          var match$1 = match._end;
          lexing.new_line(lexbuf);
          var _end_line = match$1.line;
          var _end_column = match$1.column - 1 | 0;
          var _end_offset = match$1.offset - 1 | 0;
          var _end = {
            line: _end_line,
            column: _end_column,
            offset: _end_offset
          };
          return [
                  env,
                  {
                    source: match.source,
                    start: match.start,
                    _end: _end
                  }
                ];
      case 2 :
          var c = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(buf, c);
          return line_comment(env, buf, lexbuf);
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function __ocaml_lex_regexp_body_rec(env, buf, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          var loc = loc_bs.from_lb(env.lex_source, lexbuf);
          var env$1 = lex_error(env, loc, /* UnterminatedRegExp */14);
          return [
                  env$1,
                  ""
                ];
      case 1 :
          var loc$1 = loc_bs.from_lb(env.lex_source, lexbuf);
          var env$2 = lex_error(env, loc$1, /* UnterminatedRegExp */14);
          return [
                  env$2,
                  ""
                ];
      case 2 :
          var s = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_start_pos + 2 | 0);
          buffer.add_string(buf, s);
          return regexp_body(env, buf, lexbuf);
      case 3 :
          var flags = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos + 1 | 0, lexbuf.lex_curr_pos);
          return [
                  env,
                  flags
                ];
      case 4 :
          return [
                  env,
                  ""
                ];
      case 5 :
          var c = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(buf, c);
          var env$3 = regexp_class(env, buf, lexbuf);
          return regexp_body(env$3, buf, lexbuf);
      case 6 :
          var loc$2 = loc_bs.from_lb(env.lex_source, lexbuf);
          var env$4 = lex_error(env, loc$2, /* UnterminatedRegExp */14);
          return [
                  env$4,
                  ""
                ];
      case 7 :
          var c$1 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(buf, c$1);
          return regexp_body(env, buf, lexbuf);
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function regexp_body(env, buf, lexbuf) {
  return __ocaml_lex_regexp_body_rec(env, buf, lexbuf, 323);
}

function regexp_class(env, buf, lexbuf) {
  return __ocaml_lex_regexp_class_rec(env, buf, lexbuf, 335);
}

function template_part(env, start, cooked, raw, literal, lexbuf) {
  return __ocaml_lex_template_part_rec(env, start, cooked, raw, literal, lexbuf, 425);
}

function __ocaml_lex_template_tail_rec(_env, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var env = _env;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          lexing.new_line(lexbuf);
          ___ocaml_lex_state = 402;
          continue ;
      case 1 :
          unicode_fix_cols(lexbuf);
          ___ocaml_lex_state = 402;
          continue ;
      case 2 :
          var start = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf = buffer.create(127);
          var match = line_comment(env, buf, lexbuf);
          var env$1 = save_comment(match[0], start, match[1], buf, false);
          ___ocaml_lex_state = 402;
          _env = env$1;
          continue ;
      case 3 :
          var start$1 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$1 = buffer.create(127);
          var match$1 = comment(env, buf$1, lexbuf);
          var env$2 = save_comment(match$1[0], start$1, match$1[1], buf$1, true);
          ___ocaml_lex_state = 402;
          _env = env$2;
          continue ;
      case 4 :
          var start$2 = loc_bs.from_lb(env.lex_source, lexbuf);
          var cooked = buffer.create(127);
          var raw = buffer.create(127);
          var literal = buffer.create(127);
          buffer.add_string(literal, "}");
          var match$2 = template_part(env, start$2, cooked, raw, literal, lexbuf);
          return [
                  match$2[0],
                  {
                    TAG: /* T_TEMPLATE_PART */2,
                    _0: [
                      match$2[1],
                      {
                        cooked: buffer.contents(cooked),
                        raw: buffer.contents(raw),
                        literal: buffer.contents(literal)
                      },
                      match$2[2]
                    ]
                  }
                ];
      case 5 :
          var env$3 = lex_error(env, loc_bs.from_lb(env.lex_source, lexbuf), {
                TAG: /* UnexpectedToken */1,
                _0: "ILLEGAL"
              });
          return [
                  env$3,
                  {
                    TAG: /* T_TEMPLATE_PART */2,
                    _0: [
                      loc_bs.from_lb(env$3.lex_source, lexbuf),
                      {
                        cooked: "",
                        raw: "",
                        literal: ""
                      },
                      true
                    ]
                  }
                ];
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function comment(env, buf, lexbuf) {
  return __ocaml_lex_comment_rec(env, buf, lexbuf, 288);
}

function __ocaml_lex_jsx_text_rec(env, mode, buf, raw, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          var c = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          switch (mode) {
            case /* JSX_SINGLE_QUOTED_TEXT */0 :
                if (c === 39) {
                  return [
                          env,
                          loc_bs.from_lb(env.lex_source, lexbuf)
                        ];
                }
                break;
            case /* JSX_DOUBLE_QUOTED_TEXT */1 :
                if (c === 34) {
                  return [
                          env,
                          loc_bs.from_lb(env.lex_source, lexbuf)
                        ];
                }
                break;
            case /* JSX_CHILD_TEXT */2 :
                var exit = 0;
                if (!(c !== 60 && c !== 123)) {
                  exit = 2;
                }
                if (exit === 2) {
                  back(lexbuf);
                  return [
                          env,
                          loc_bs.from_lb(env.lex_source, lexbuf)
                        ];
                }
                break;
            
          }
          buffer.add_char(raw, c);
          buffer.add_char(buf, c);
          return jsx_text(env, mode, buf, raw, lexbuf);
      case 1 :
          var env$1 = lex_error(env, loc_bs.from_lb(env.lex_source, lexbuf), {
                TAG: /* UnexpectedToken */1,
                _0: "ILLEGAL"
              });
          return [
                  env$1,
                  loc_bs.from_lb(env$1.lex_source, lexbuf)
                ];
      case 2 :
          var lt = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          buffer.add_string(raw, lt);
          buffer.add_string(buf, lt);
          lexing.new_line(lexbuf);
          return jsx_text(env, mode, buf, raw, lexbuf);
      case 3 :
          var n = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos + 3 | 0, lexbuf.lex_curr_pos - 1 | 0);
          var s = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          buffer.add_string(raw, s);
          var code = caml_format.caml_int_of_string("0x" + n);
          list.iter((function (param) {
                  return buffer.add_char(buf, param);
                }), utf16to8(code));
          return jsx_text(env, mode, buf, raw, lexbuf);
      case 4 :
          var n$1 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos + 2 | 0, lexbuf.lex_curr_pos - 1 | 0);
          var s$1 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          buffer.add_string(raw, s$1);
          var code$1 = caml_format.caml_int_of_string(n$1);
          list.iter((function (param) {
                  return buffer.add_char(buf, param);
                }), utf16to8(code$1));
          return jsx_text(env, mode, buf, raw, lexbuf);
      case 5 :
          var entity = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos + 1 | 0, lexbuf.lex_curr_pos - 1 | 0);
          var s$2 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          buffer.add_string(raw, s$2);
          var code$2;
          switch (entity) {
            case "'int'" :
                code$2 = 8747;
                break;
            case "AElig" :
                code$2 = 198;
                break;
            case "Aacute" :
                code$2 = 193;
                break;
            case "Acirc" :
                code$2 = 194;
                break;
            case "Agrave" :
                code$2 = 192;
                break;
            case "Alpha" :
                code$2 = 913;
                break;
            case "Aring" :
                code$2 = 197;
                break;
            case "Atilde" :
                code$2 = 195;
                break;
            case "Auml" :
                code$2 = 196;
                break;
            case "Beta" :
                code$2 = 914;
                break;
            case "Ccedil" :
                code$2 = 199;
                break;
            case "Chi" :
                code$2 = 935;
                break;
            case "Dagger" :
                code$2 = 8225;
                break;
            case "Delta" :
                code$2 = 916;
                break;
            case "ETH" :
                code$2 = 208;
                break;
            case "Eacute" :
                code$2 = 201;
                break;
            case "Ecirc" :
                code$2 = 202;
                break;
            case "Egrave" :
                code$2 = 200;
                break;
            case "Epsilon" :
                code$2 = 917;
                break;
            case "Eta" :
                code$2 = 919;
                break;
            case "Euml" :
                code$2 = 203;
                break;
            case "Gamma" :
                code$2 = 915;
                break;
            case "Iacute" :
                code$2 = 205;
                break;
            case "Icirc" :
                code$2 = 206;
                break;
            case "Igrave" :
                code$2 = 204;
                break;
            case "Iota" :
                code$2 = 921;
                break;
            case "Iuml" :
                code$2 = 207;
                break;
            case "Kappa" :
                code$2 = 922;
                break;
            case "Lambda" :
                code$2 = 923;
                break;
            case "Mu" :
                code$2 = 924;
                break;
            case "Ntilde" :
                code$2 = 209;
                break;
            case "Nu" :
                code$2 = 925;
                break;
            case "OElig" :
                code$2 = 338;
                break;
            case "Oacute" :
                code$2 = 211;
                break;
            case "Ocirc" :
                code$2 = 212;
                break;
            case "Ograve" :
                code$2 = 210;
                break;
            case "Omega" :
                code$2 = 937;
                break;
            case "Omicron" :
                code$2 = 927;
                break;
            case "Oslash" :
                code$2 = 216;
                break;
            case "Otilde" :
                code$2 = 213;
                break;
            case "Ouml" :
                code$2 = 214;
                break;
            case "Phi" :
                code$2 = 934;
                break;
            case "Pi" :
                code$2 = 928;
                break;
            case "Prime" :
                code$2 = 8243;
                break;
            case "Psi" :
                code$2 = 936;
                break;
            case "Rho" :
                code$2 = 929;
                break;
            case "Scaron" :
                code$2 = 352;
                break;
            case "Sigma" :
                code$2 = 931;
                break;
            case "THORN" :
                code$2 = 222;
                break;
            case "Tau" :
                code$2 = 932;
                break;
            case "Theta" :
                code$2 = 920;
                break;
            case "Uacute" :
                code$2 = 218;
                break;
            case "Ucirc" :
                code$2 = 219;
                break;
            case "Ugrave" :
                code$2 = 217;
                break;
            case "Upsilon" :
                code$2 = 933;
                break;
            case "Uuml" :
                code$2 = 220;
                break;
            case "Xi" :
                code$2 = 926;
                break;
            case "Yacute" :
                code$2 = 221;
                break;
            case "Yuml" :
                code$2 = 376;
                break;
            case "Zeta" :
                code$2 = 918;
                break;
            case "aacute" :
                code$2 = 225;
                break;
            case "acirc" :
                code$2 = 226;
                break;
            case "acute" :
                code$2 = 180;
                break;
            case "aelig" :
                code$2 = 230;
                break;
            case "agrave" :
                code$2 = 224;
                break;
            case "alefsym" :
                code$2 = 8501;
                break;
            case "alpha" :
                code$2 = 945;
                break;
            case "amp" :
                code$2 = 38;
                break;
            case "and" :
                code$2 = 8743;
                break;
            case "ang" :
                code$2 = 8736;
                break;
            case "apos" :
                code$2 = 39;
                break;
            case "aring" :
                code$2 = 229;
                break;
            case "asymp" :
                code$2 = 8776;
                break;
            case "atilde" :
                code$2 = 227;
                break;
            case "auml" :
                code$2 = 228;
                break;
            case "bdquo" :
                code$2 = 8222;
                break;
            case "beta" :
                code$2 = 946;
                break;
            case "brvbar" :
                code$2 = 166;
                break;
            case "bull" :
                code$2 = 8226;
                break;
            case "cap" :
                code$2 = 8745;
                break;
            case "ccedil" :
                code$2 = 231;
                break;
            case "cedil" :
                code$2 = 184;
                break;
            case "cent" :
                code$2 = 162;
                break;
            case "chi" :
                code$2 = 967;
                break;
            case "circ" :
                code$2 = 710;
                break;
            case "clubs" :
                code$2 = 9827;
                break;
            case "cong" :
                code$2 = 8773;
                break;
            case "copy" :
                code$2 = 169;
                break;
            case "crarr" :
                code$2 = 8629;
                break;
            case "cup" :
                code$2 = 8746;
                break;
            case "curren" :
                code$2 = 164;
                break;
            case "dArr" :
                code$2 = 8659;
                break;
            case "dagger" :
                code$2 = 8224;
                break;
            case "darr" :
                code$2 = 8595;
                break;
            case "deg" :
                code$2 = 176;
                break;
            case "delta" :
                code$2 = 948;
                break;
            case "diams" :
                code$2 = 9830;
                break;
            case "divide" :
                code$2 = 247;
                break;
            case "eacute" :
                code$2 = 233;
                break;
            case "ecirc" :
                code$2 = 234;
                break;
            case "egrave" :
                code$2 = 232;
                break;
            case "empty" :
                code$2 = 8709;
                break;
            case "emsp" :
                code$2 = 8195;
                break;
            case "ensp" :
                code$2 = 8194;
                break;
            case "epsilon" :
                code$2 = 949;
                break;
            case "equiv" :
                code$2 = 8801;
                break;
            case "eta" :
                code$2 = 951;
                break;
            case "eth" :
                code$2 = 240;
                break;
            case "euml" :
                code$2 = 235;
                break;
            case "euro" :
                code$2 = 8364;
                break;
            case "exist" :
                code$2 = 8707;
                break;
            case "fnof" :
                code$2 = 402;
                break;
            case "forall" :
                code$2 = 8704;
                break;
            case "frac12" :
                code$2 = 189;
                break;
            case "frac14" :
                code$2 = 188;
                break;
            case "frac34" :
                code$2 = 190;
                break;
            case "frasl" :
                code$2 = 8260;
                break;
            case "gamma" :
                code$2 = 947;
                break;
            case "ge" :
                code$2 = 8805;
                break;
            case "gt" :
                code$2 = 62;
                break;
            case "hArr" :
                code$2 = 8660;
                break;
            case "harr" :
                code$2 = 8596;
                break;
            case "hearts" :
                code$2 = 9829;
                break;
            case "hellip" :
                code$2 = 8230;
                break;
            case "iacute" :
                code$2 = 237;
                break;
            case "icirc" :
                code$2 = 238;
                break;
            case "iexcl" :
                code$2 = 161;
                break;
            case "igrave" :
                code$2 = 236;
                break;
            case "image" :
                code$2 = 8465;
                break;
            case "infin" :
                code$2 = 8734;
                break;
            case "iota" :
                code$2 = 953;
                break;
            case "iquest" :
                code$2 = 191;
                break;
            case "isin" :
                code$2 = 8712;
                break;
            case "iuml" :
                code$2 = 239;
                break;
            case "kappa" :
                code$2 = 954;
                break;
            case "lArr" :
                code$2 = 8656;
                break;
            case "lambda" :
                code$2 = 955;
                break;
            case "lang" :
                code$2 = 10216;
                break;
            case "laquo" :
                code$2 = 171;
                break;
            case "larr" :
                code$2 = 8592;
                break;
            case "lceil" :
                code$2 = 8968;
                break;
            case "ldquo" :
                code$2 = 8220;
                break;
            case "le" :
                code$2 = 8804;
                break;
            case "lfloor" :
                code$2 = 8970;
                break;
            case "lowast" :
                code$2 = 8727;
                break;
            case "loz" :
                code$2 = 9674;
                break;
            case "lrm" :
                code$2 = 8206;
                break;
            case "lsaquo" :
                code$2 = 8249;
                break;
            case "lsquo" :
                code$2 = 8216;
                break;
            case "lt" :
                code$2 = 60;
                break;
            case "macr" :
                code$2 = 175;
                break;
            case "mdash" :
                code$2 = 8212;
                break;
            case "micro" :
                code$2 = 181;
                break;
            case "middot" :
                code$2 = 183;
                break;
            case "minus" :
                code$2 = 8722;
                break;
            case "mu" :
                code$2 = 956;
                break;
            case "nabla" :
                code$2 = 8711;
                break;
            case "nbsp" :
                code$2 = 160;
                break;
            case "ndash" :
                code$2 = 8211;
                break;
            case "ne" :
                code$2 = 8800;
                break;
            case "ni" :
                code$2 = 8715;
                break;
            case "not" :
                code$2 = 172;
                break;
            case "notin" :
                code$2 = 8713;
                break;
            case "nsub" :
                code$2 = 8836;
                break;
            case "ntilde" :
                code$2 = 241;
                break;
            case "nu" :
                code$2 = 957;
                break;
            case "oacute" :
                code$2 = 243;
                break;
            case "ocirc" :
                code$2 = 244;
                break;
            case "oelig" :
                code$2 = 339;
                break;
            case "ograve" :
                code$2 = 242;
                break;
            case "oline" :
                code$2 = 8254;
                break;
            case "omega" :
                code$2 = 969;
                break;
            case "omicron" :
                code$2 = 959;
                break;
            case "oplus" :
                code$2 = 8853;
                break;
            case "or" :
                code$2 = 8744;
                break;
            case "ordf" :
                code$2 = 170;
                break;
            case "ordm" :
                code$2 = 186;
                break;
            case "oslash" :
                code$2 = 248;
                break;
            case "otilde" :
                code$2 = 245;
                break;
            case "otimes" :
                code$2 = 8855;
                break;
            case "ouml" :
                code$2 = 246;
                break;
            case "para" :
                code$2 = 182;
                break;
            case "part" :
                code$2 = 8706;
                break;
            case "permil" :
                code$2 = 8240;
                break;
            case "perp" :
                code$2 = 8869;
                break;
            case "phi" :
                code$2 = 966;
                break;
            case "pi" :
                code$2 = 960;
                break;
            case "piv" :
                code$2 = 982;
                break;
            case "plusmn" :
                code$2 = 177;
                break;
            case "pound" :
                code$2 = 163;
                break;
            case "prime" :
                code$2 = 8242;
                break;
            case "prod" :
                code$2 = 8719;
                break;
            case "prop" :
                code$2 = 8733;
                break;
            case "psi" :
                code$2 = 968;
                break;
            case "quot" :
                code$2 = 34;
                break;
            case "rArr" :
                code$2 = 8658;
                break;
            case "radic" :
                code$2 = 8730;
                break;
            case "rang" :
                code$2 = 10217;
                break;
            case "raquo" :
                code$2 = 187;
                break;
            case "rarr" :
                code$2 = 8594;
                break;
            case "rceil" :
                code$2 = 8969;
                break;
            case "rdquo" :
                code$2 = 8221;
                break;
            case "real" :
                code$2 = 8476;
                break;
            case "reg" :
                code$2 = 174;
                break;
            case "rfloor" :
                code$2 = 8971;
                break;
            case "rho" :
                code$2 = 961;
                break;
            case "rlm" :
                code$2 = 8207;
                break;
            case "rsaquo" :
                code$2 = 8250;
                break;
            case "rsquo" :
                code$2 = 8217;
                break;
            case "sbquo" :
                code$2 = 8218;
                break;
            case "scaron" :
                code$2 = 353;
                break;
            case "sdot" :
                code$2 = 8901;
                break;
            case "sect" :
                code$2 = 167;
                break;
            case "shy" :
                code$2 = 173;
                break;
            case "sigma" :
                code$2 = 963;
                break;
            case "sigmaf" :
                code$2 = 962;
                break;
            case "sim" :
                code$2 = 8764;
                break;
            case "spades" :
                code$2 = 9824;
                break;
            case "sub" :
                code$2 = 8834;
                break;
            case "sube" :
                code$2 = 8838;
                break;
            case "sum" :
                code$2 = 8721;
                break;
            case "sup" :
                code$2 = 8835;
                break;
            case "sup1" :
                code$2 = 185;
                break;
            case "sup2" :
                code$2 = 178;
                break;
            case "sup3" :
                code$2 = 179;
                break;
            case "supe" :
                code$2 = 8839;
                break;
            case "szlig" :
                code$2 = 223;
                break;
            case "tau" :
                code$2 = 964;
                break;
            case "there4" :
                code$2 = 8756;
                break;
            case "theta" :
                code$2 = 952;
                break;
            case "thetasym" :
                code$2 = 977;
                break;
            case "thinsp" :
                code$2 = 8201;
                break;
            case "thorn" :
                code$2 = 254;
                break;
            case "tilde" :
                code$2 = 732;
                break;
            case "times" :
                code$2 = 215;
                break;
            case "trade" :
                code$2 = 8482;
                break;
            case "uArr" :
                code$2 = 8657;
                break;
            case "uacute" :
                code$2 = 250;
                break;
            case "uarr" :
                code$2 = 8593;
                break;
            case "ucirc" :
                code$2 = 251;
                break;
            case "ugrave" :
                code$2 = 249;
                break;
            case "uml" :
                code$2 = 168;
                break;
            case "upsih" :
                code$2 = 978;
                break;
            case "upsilon" :
                code$2 = 965;
                break;
            case "uuml" :
                code$2 = 252;
                break;
            case "weierp" :
                code$2 = 8472;
                break;
            case "xi" :
                code$2 = 958;
                break;
            case "yacute" :
                code$2 = 253;
                break;
            case "yen" :
                code$2 = 165;
                break;
            case "yuml" :
                code$2 = 255;
                break;
            case "zeta" :
                code$2 = 950;
                break;
            case "zwj" :
                code$2 = 8205;
                break;
            case "zwnj" :
                code$2 = 8204;
                break;
            default:
              code$2 = undefined;
          }
          if (code$2 !== undefined) {
            list.iter((function (param) {
                    return buffer.add_char(buf, param);
                  }), utf16to8(code$2));
          } else {
            buffer.add_string(buf, "&" + (entity + ";"));
          }
          return jsx_text(env, mode, buf, raw, lexbuf);
      case 6 :
          var c$1 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(raw, c$1);
          buffer.add_char(buf, c$1);
          return jsx_text(env, mode, buf, raw, lexbuf);
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function __ocaml_lex_string_quote_rec(env, q, buf, raw, octal, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          var q$prime = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(raw, q$prime);
          if (q === q$prime) {
            return [
                    env,
                    loc_bs.from_lb(env.lex_source, lexbuf),
                    octal
                  ];
          } else {
            buffer.add_char(buf, q$prime);
            return string_quote(env, q, buf, raw, octal, lexbuf);
          }
      case 1 :
          var e = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(raw, e);
          var match = string_escape(env, buf, lexbuf);
          var octal$1 = match[1] || octal;
          buffer.add_string(raw, lexing.lexeme(lexbuf));
          return string_quote(match[0], q, buf, raw, octal$1, lexbuf);
      case 2 :
          var x = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          buffer.add_string(raw, x);
          var env$1 = lex_error(env, loc_bs.from_lb(env.lex_source, lexbuf), {
                TAG: /* UnexpectedToken */1,
                _0: "ILLEGAL"
              });
          buffer.add_string(buf, x);
          return [
                  env$1,
                  loc_bs.from_lb(env$1.lex_source, lexbuf),
                  octal
                ];
      case 3 :
          var x$1 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(raw, x$1);
          buffer.add_char(buf, x$1);
          return string_quote(env, q, buf, raw, octal, lexbuf);
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function __ocaml_lex_type_token_rec(env, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          lexing.new_line(lexbuf);
          return type_token(env, lexbuf);
      case 1 :
          unicode_fix_cols(lexbuf);
          return type_token(env, lexbuf);
      case 2 :
          var start = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf = buffer.create(127);
          var match = comment(env, buf, lexbuf);
          var env$1 = save_comment(match[0], start, match[1], buf, true);
          return type_token(env$1, lexbuf);
      case 3 :
          var sp = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos + 2 | 0, caml_array.get(lexbuf.lex_mem, 0));
          var escape_type = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          var pattern = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          if (env.lex_enable_comment_syntax) {
            var env$2;
            if (env.lex_in_comment_syntax) {
              var loc = loc_bs.from_lb(env.lex_source, lexbuf);
              env$2 = unexpected_error(env, loc, pattern);
            } else {
              env$2 = env;
            }
            var env$3 = in_comment_syntax(true, env$2);
            if (escape_type === ":") {
              return [
                      env$3,
                      /* T_COLON */80
                    ];
            } else {
              return type_token(env$3, lexbuf);
            }
          }
          var start$1 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$1 = buffer.create(127);
          buffer.add_string(buf$1, sp);
          buffer.add_string(buf$1, escape_type);
          var match$1 = comment(env, buf$1, lexbuf);
          var env$4 = save_comment(match$1[0], start$1, match$1[1], buf$1, true);
          return type_token(env$4, lexbuf);
      case 4 :
          if (env.lex_in_comment_syntax) {
            var env$5 = in_comment_syntax(false, env);
            return type_token(env$5, lexbuf);
          }
          yyback(1, lexbuf);
          return [
                  env,
                  /* T_MULT */100
                ];
      case 5 :
          var start$2 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$2 = buffer.create(127);
          var match$2 = line_comment(env, buf$2, lexbuf);
          var env$6 = save_comment(match$2[0], start$2, match$2[1], buf$2, false);
          return type_token(env$6, lexbuf);
      case 6 :
          var quote = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          var start$3 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$3 = buffer.create(127);
          var raw = buffer.create(127);
          buffer.add_char(raw, quote);
          var match$3 = string_quote(env, quote, buf$3, raw, false, lexbuf);
          return [
                  match$3[0],
                  {
                    TAG: /* T_STRING */1,
                    _0: [
                      loc_bs.btwn(start$3, match$3[1]),
                      buffer.contents(buf$3),
                      buffer.contents(raw),
                      match$3[2]
                    ]
                  }
                ];
      case 7 :
          var neg = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), caml_array.get(lexbuf.lex_mem, 1));
          var w = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 1), lexbuf.lex_curr_pos);
          return illegal_number(env, lexbuf, w, mk_num_singleton(/* BINARY */0, num, neg));
      case 8 :
          var neg$1 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num$1 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          return [
                  env,
                  mk_num_singleton(/* BINARY */0, num$1, neg$1)
                ];
      case 9 :
          var neg$2 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num$2 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), caml_array.get(lexbuf.lex_mem, 1));
          var w$1 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 1), lexbuf.lex_curr_pos);
          return illegal_number(env, lexbuf, w$1, mk_num_singleton(/* OCTAL */2, num$2, neg$2));
      case 10 :
          var neg$3 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num$3 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          return [
                  env,
                  mk_num_singleton(/* OCTAL */2, num$3, neg$3)
                ];
      case 11 :
          var neg$4 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num$4 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), caml_array.get(lexbuf.lex_mem, 1));
          var w$2 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 1), lexbuf.lex_curr_pos);
          return illegal_number(env, lexbuf, w$2, mk_num_singleton(/* LEGACY_OCTAL */1, num$4, neg$4));
      case 12 :
          var neg$5 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num$5 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          return [
                  env,
                  mk_num_singleton(/* LEGACY_OCTAL */1, num$5, neg$5)
                ];
      case 13 :
          var neg$6 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num$6 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), caml_array.get(lexbuf.lex_mem, 1));
          var w$3 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 1), lexbuf.lex_curr_pos);
          var match$4;
          try {
            match$4 = [
              env,
              mk_num_singleton(/* NORMAL */3, num$6, neg$6)
            ];
          }
          catch (exn){
            if (sys.win32) {
              var loc$1 = loc_bs.from_lb(env.lex_source, lexbuf);
              var env$7 = lex_error(env, loc$1, /* WindowsFloatOfString */59);
              match$4 = [
                env$7,
                {
                  TAG: /* T_NUMBER_SINGLETON_TYPE */5,
                  _0: /* NORMAL */3,
                  _1: 789.0
                }
              ];
            } else {
              throw exn;
            }
          }
          return illegal_number(match$4[0], lexbuf, w$3, match$4[1]);
      case 14 :
          var neg$7 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num$7 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          try {
            return [
                    env,
                    mk_num_singleton(/* NORMAL */3, num$7, neg$7)
                  ];
          }
          catch (exn$1){
            if (sys.win32) {
              var loc$2 = loc_bs.from_lb(env.lex_source, lexbuf);
              var env$8 = lex_error(env, loc$2, /* WindowsFloatOfString */59);
              return [
                      env$8,
                      {
                        TAG: /* T_NUMBER_SINGLETON_TYPE */5,
                        _0: /* NORMAL */3,
                        _1: 789.0
                      }
                    ];
            }
            throw exn$1;
          }
      case 15 :
          var neg$8 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num$8 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), caml_array.get(lexbuf.lex_mem, 1));
          var w$4 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 1), lexbuf.lex_curr_pos);
          return illegal_number(env, lexbuf, w$4, mk_num_singleton(/* NORMAL */3, num$8, neg$8));
      case 16 :
          var neg$9 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num$9 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          return [
                  env,
                  mk_num_singleton(/* NORMAL */3, num$9, neg$9)
                ];
      case 17 :
          var neg$10 = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, caml_array.get(lexbuf.lex_mem, 0));
          var num$10 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), caml_array.get(lexbuf.lex_mem, 1));
          var w$5 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 1), lexbuf.lex_curr_pos);
          return illegal_number(env, lexbuf, w$5, mk_num_singleton(/* NORMAL */3, num$10, neg$10));
      case 18 :
          var neg$11 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 1), caml_array.get(lexbuf.lex_mem, 0));
          var num$11 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 3), caml_array.get(lexbuf.lex_mem, 2));
          return [
                  env,
                  mk_num_singleton(/* NORMAL */3, num$11, neg$11)
                ];
      case 19 :
          var word = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          unicode_fix_cols(lexbuf);
          try {
            return [
                    env,
                    hashtbl.find(type_keywords, word)
                  ];
          }
          catch (raw_exn){
            var exn$2 = caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$2.RE_EXN_ID === "Not_found") {
              return [
                      env,
                      /* T_IDENTIFIER */0
                    ];
            }
            throw exn$2;
          }
      case 20 :
          return [
                  env,
                  /* T_CHECKS */65
                ];
      case 23 :
          return [
                  env,
                  /* T_LCURLY */1
                ];
      case 24 :
          return [
                  env,
                  /* T_RCURLY */2
                ];
      case 25 :
          return [
                  env,
                  /* T_LCURLYBAR */3
                ];
      case 26 :
          return [
                  env,
                  /* T_RCURLYBAR */4
                ];
      case 27 :
          return [
                  env,
                  /* T_LPAREN */5
                ];
      case 28 :
          return [
                  env,
                  /* T_RPAREN */6
                ];
      case 29 :
          return [
                  env,
                  /* T_ELLIPSIS */13
                ];
      case 30 :
          return [
                  env,
                  /* T_PERIOD */11
                ];
      case 31 :
          return [
                  env,
                  /* T_SEMICOLON */9
                ];
      case 32 :
          return [
                  env,
                  /* T_COMMA */10
                ];
      case 21 :
      case 35 :
          return [
                  env,
                  /* T_LBRACKET */7
                ];
      case 22 :
      case 36 :
          return [
                  env,
                  /* T_RBRACKET */8
                ];
      case 37 :
          return [
                  env,
                  /* T_LESS_THAN */92
                ];
      case 38 :
          return [
                  env,
                  /* T_GREATER_THAN */93
                ];
      case 34 :
      case 40 :
          return [
                  env,
                  /* T_PLING */79
                ];
      case 41 :
          return [
                  env,
                  /* T_MULT */100
                ];
      case 33 :
      case 42 :
          return [
                  env,
                  /* T_COLON */80
                ];
      case 43 :
          return [
                  env,
                  /* T_BIT_OR */83
                ];
      case 44 :
          return [
                  env,
                  /* T_BIT_AND */85
                ];
      case 45 :
          return [
                  env,
                  /* T_TYPEOF */46
                ];
      case 46 :
          return [
                  env,
                  /* T_ARROW */12
                ];
      case 39 :
      case 47 :
          return [
                  env,
                  /* T_ASSIGN */78
                ];
      case 48 :
          return [
                  env,
                  /* T_PLUS */97
                ];
      case 49 :
          return [
                  env,
                  /* T_MINUS */98
                ];
      case 50 :
          var env$9;
          if (env.lex_in_comment_syntax) {
            var loc$3 = loc_bs.from_lb(env.lex_source, lexbuf);
            env$9 = lex_error(env, loc$3, /* UnexpectedEOS */4);
          } else {
            env$9 = env;
          }
          return [
                  env$9,
                  /* T_EOF */108
                ];
      case 51 :
          return [
                  env,
                  /* T_ERROR */107
                ];
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function __ocaml_lex_regexp_rec(_env, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var env = _env;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          return [
                  env,
                  /* T_EOF */108
                ];
      case 1 :
          lexing.new_line(lexbuf);
          ___ocaml_lex_state = 300;
          continue ;
      case 2 :
          unicode_fix_cols(lexbuf);
          ___ocaml_lex_state = 300;
          continue ;
      case 3 :
          var start = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf = buffer.create(127);
          var match = line_comment(env, buf, lexbuf);
          var env$1 = save_comment(match[0], start, match[1], buf, false);
          ___ocaml_lex_state = 300;
          _env = env$1;
          continue ;
      case 4 :
          var start$1 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$1 = buffer.create(127);
          var match$1 = comment(env, buf$1, lexbuf);
          var env$2 = save_comment(match$1[0], start$1, match$1[1], buf$1, true);
          ___ocaml_lex_state = 300;
          _env = env$2;
          continue ;
      case 5 :
          var start$2 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$2 = buffer.create(127);
          var match$2 = regexp_body(env, buf$2, lexbuf);
          var env$3 = match$2[0];
          var end_ = loc_bs.from_lb(env$3.lex_source, lexbuf);
          var loc = loc_bs.btwn(start$2, end_);
          return [
                  env$3,
                  {
                    TAG: /* T_REGEXP */3,
                    _0: [
                      loc,
                      buffer.contents(buf$2),
                      match$2[1]
                    ]
                  }
                ];
      case 6 :
          var env$4 = lex_error(env, loc_bs.from_lb(env.lex_source, lexbuf), {
                TAG: /* UnexpectedToken */1,
                _0: "ILLEGAL"
              });
          return [
                  env$4,
                  /* T_ERROR */107
                ];
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function jsx_text(env, mode, buf, raw, lexbuf) {
  return __ocaml_lex_jsx_text_rec(env, mode, buf, raw, lexbuf, 380);
}

function __ocaml_lex_jsx_tag_rec(_env, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var env = _env;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          return [
                  env,
                  /* T_EOF */108
                ];
      case 1 :
          lexing.new_line(lexbuf);
          ___ocaml_lex_state = 342;
          continue ;
      case 2 :
          unicode_fix_cols(lexbuf);
          ___ocaml_lex_state = 342;
          continue ;
      case 3 :
          var start = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf = buffer.create(127);
          var match = line_comment(env, buf, lexbuf);
          var env$1 = save_comment(match[0], start, match[1], buf, false);
          ___ocaml_lex_state = 342;
          _env = env$1;
          continue ;
      case 4 :
          var start$1 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$1 = buffer.create(127);
          var match$1 = comment(env, buf$1, lexbuf);
          var env$2 = save_comment(match$1[0], start$1, match$1[1], buf$1, true);
          ___ocaml_lex_state = 342;
          _env = env$2;
          continue ;
      case 5 :
          return [
                  env,
                  /* T_LESS_THAN */92
                ];
      case 6 :
          return [
                  env,
                  /* T_DIV */99
                ];
      case 7 :
          return [
                  env,
                  /* T_GREATER_THAN */93
                ];
      case 8 :
          return [
                  env,
                  /* T_LCURLY */1
                ];
      case 9 :
          return [
                  env,
                  /* T_COLON */80
                ];
      case 10 :
          return [
                  env,
                  /* T_PERIOD */11
                ];
      case 11 :
          return [
                  env,
                  /* T_ASSIGN */78
                ];
      case 12 :
          unicode_fix_cols(lexbuf);
          return [
                  env,
                  /* T_JSX_IDENTIFIER */109
                ];
      case 13 :
          var quote = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          var start$2 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$2 = buffer.create(127);
          var raw = buffer.create(127);
          buffer.add_char(raw, quote);
          var mode = quote === /* "'" */39 ? /* JSX_SINGLE_QUOTED_TEXT */0 : /* JSX_DOUBLE_QUOTED_TEXT */1;
          var match$2 = jsx_text(env, mode, buf$2, raw, lexbuf);
          buffer.add_char(raw, quote);
          var value = buffer.contents(buf$2);
          var raw$1 = buffer.contents(raw);
          return [
                  match$2[0],
                  {
                    TAG: /* T_JSX_TEXT */4,
                    _0: [
                      loc_bs.btwn(start$2, match$2[1]),
                      value,
                      raw$1
                    ]
                  }
                ];
      case 14 :
          return [
                  env,
                  /* T_ERROR */107
                ];
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function __ocaml_lex_comment_rec(env, buf, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          var env$1 = lex_error(env, loc_bs.from_lb(env.lex_source, lexbuf), {
                TAG: /* UnexpectedToken */1,
                _0: "ILLEGAL"
              });
          return [
                  env$1,
                  loc_bs.from_lb(env$1.lex_source, lexbuf)
                ];
      case 1 :
          lexing.new_line(lexbuf);
          buffer.add_char(buf, /* "\n" */10);
          return comment(env, buf, lexbuf);
      case 2 :
          var loc = loc_bs.from_lb(env.lex_source, lexbuf);
          var env$2 = env.lex_in_comment_syntax ? unexpected_error_w_suggest(env, loc, "*/", "*-/") : env;
          return [
                  env$2,
                  loc
                ];
      case 3 :
          if (env.lex_in_comment_syntax) {
            return [
                    env,
                    loc_bs.from_lb(env.lex_source, lexbuf)
                  ];
          } else {
            buffer.add_string(buf, "*-/");
            return comment(env, buf, lexbuf);
          }
      case 4 :
          var c = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(buf, c);
          return comment(env, buf, lexbuf);
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function __ocaml_lex_token_rec(env, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          lexing.new_line(lexbuf);
          return token$1(env, lexbuf);
      case 1 :
          var env$1 = lex_error(env, loc_bs.from_lb(env.lex_source, lexbuf), {
                TAG: /* UnexpectedToken */1,
                _0: "ILLEGAL"
              });
          return token$1(env$1, lexbuf);
      case 2 :
          unicode_fix_cols(lexbuf);
          return token$1(env, lexbuf);
      case 3 :
          var start = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf = buffer.create(127);
          var match = comment(env, buf, lexbuf);
          var env$2 = save_comment(match[0], start, match[1], buf, true);
          return token$1(env$2, lexbuf);
      case 4 :
          var sp = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos + 2 | 0, caml_array.get(lexbuf.lex_mem, 0));
          var escape_type = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          var pattern = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          if (env.lex_enable_comment_syntax) {
            var env$3;
            if (env.lex_in_comment_syntax) {
              var loc = loc_bs.from_lb(env.lex_source, lexbuf);
              env$3 = unexpected_error(env, loc, pattern);
            } else {
              env$3 = env;
            }
            var env$4 = in_comment_syntax(true, env$3);
            if (escape_type === ":") {
              return [
                      env$4,
                      /* T_COLON */80
                    ];
            } else {
              return token$1(env$4, lexbuf);
            }
          }
          var start$1 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$1 = buffer.create(127);
          buffer.add_string(buf$1, sp);
          buffer.add_string(buf$1, escape_type);
          var match$1 = comment(env, buf$1, lexbuf);
          var env$5 = save_comment(match$1[0], start$1, match$1[1], buf$1, true);
          return token$1(env$5, lexbuf);
      case 5 :
          if (env.lex_in_comment_syntax) {
            var env$6 = in_comment_syntax(false, env);
            return token$1(env$6, lexbuf);
          }
          yyback(1, lexbuf);
          return [
                  env,
                  /* T_MULT */100
                ];
      case 6 :
          var start$2 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$2 = buffer.create(127);
          var match$2 = line_comment(env, buf$2, lexbuf);
          var env$7 = save_comment(match$2[0], start$2, match$2[1], buf$2, false);
          return token$1(env$7, lexbuf);
      case 7 :
          if (lexbuf.lex_start_pos !== 0) {
            return [
                    env,
                    /* T_ERROR */107
                  ];
          }
          var match$3 = line_comment(env, buffer.create(127), lexbuf);
          return token$1(match$3[0], lexbuf);
      case 8 :
          var quote = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          var start$3 = loc_bs.from_lb(env.lex_source, lexbuf);
          var buf$3 = buffer.create(127);
          var raw = buffer.create(127);
          buffer.add_char(raw, quote);
          var match$4 = string_quote(env, quote, buf$3, raw, false, lexbuf);
          return [
                  match$4[0],
                  {
                    TAG: /* T_STRING */1,
                    _0: [
                      loc_bs.btwn(start$3, match$4[1]),
                      buffer.contents(buf$3),
                      buffer.contents(raw),
                      match$4[2]
                    ]
                  }
                ];
      case 9 :
          var cooked = buffer.create(127);
          var raw$1 = buffer.create(127);
          var literal = buffer.create(127);
          buffer.add_string(literal, lexing.lexeme(lexbuf));
          var start$4 = loc_bs.from_lb(env.lex_source, lexbuf);
          var match$5 = template_part(env, start$4, cooked, raw$1, literal, lexbuf);
          return [
                  match$5[0],
                  {
                    TAG: /* T_TEMPLATE_PART */2,
                    _0: [
                      match$5[1],
                      {
                        cooked: buffer.contents(cooked),
                        raw: buffer.contents(raw$1),
                        literal: buffer.contents(literal)
                      },
                      match$5[2]
                    ]
                  }
                ];
      case 10 :
          var w = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          return illegal_number(env, lexbuf, w, {
                      TAG: /* T_NUMBER */0,
                      _0: /* BINARY */0
                    });
      case 11 :
          return [
                  env,
                  {
                    TAG: /* T_NUMBER */0,
                    _0: /* BINARY */0
                  }
                ];
      case 12 :
          var w$1 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          return illegal_number(env, lexbuf, w$1, {
                      TAG: /* T_NUMBER */0,
                      _0: /* OCTAL */2
                    });
      case 13 :
          return [
                  env,
                  {
                    TAG: /* T_NUMBER */0,
                    _0: /* OCTAL */2
                  }
                ];
      case 14 :
          var w$2 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          return illegal_number(env, lexbuf, w$2, {
                      TAG: /* T_NUMBER */0,
                      _0: /* LEGACY_OCTAL */1
                    });
      case 15 :
          return [
                  env,
                  {
                    TAG: /* T_NUMBER */0,
                    _0: /* LEGACY_OCTAL */1
                  }
                ];
      case 16 :
      case 18 :
      case 20 :
          break;
      case 17 :
      case 19 :
      case 21 :
          return [
                  env,
                  {
                    TAG: /* T_NUMBER */0,
                    _0: /* NORMAL */3
                  }
                ];
      case 22 :
          var word = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          unicode_fix_cols(lexbuf);
          try {
            return [
                    env,
                    hashtbl.find(keywords, word)
                  ];
          }
          catch (raw_exn){
            var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === "Not_found") {
              return [
                      env,
                      /* T_IDENTIFIER */0
                    ];
            }
            throw exn;
          }
      case 23 :
          return [
                  env,
                  /* T_LCURLY */1
                ];
      case 24 :
          return [
                  env,
                  /* T_RCURLY */2
                ];
      case 25 :
          return [
                  env,
                  /* T_LPAREN */5
                ];
      case 26 :
          return [
                  env,
                  /* T_RPAREN */6
                ];
      case 27 :
          return [
                  env,
                  /* T_LBRACKET */7
                ];
      case 28 :
          return [
                  env,
                  /* T_RBRACKET */8
                ];
      case 29 :
          return [
                  env,
                  /* T_ELLIPSIS */13
                ];
      case 30 :
          return [
                  env,
                  /* T_PERIOD */11
                ];
      case 31 :
          return [
                  env,
                  /* T_SEMICOLON */9
                ];
      case 32 :
          return [
                  env,
                  /* T_COMMA */10
                ];
      case 33 :
          return [
                  env,
                  /* T_COLON */80
                ];
      case 34 :
          return [
                  env,
                  /* T_PLING */79
                ];
      case 35 :
          return [
                  env,
                  /* T_AND */82
                ];
      case 36 :
          return [
                  env,
                  /* T_OR */81
                ];
      case 37 :
          return [
                  env,
                  /* T_STRICT_EQUAL */88
                ];
      case 38 :
          return [
                  env,
                  /* T_STRICT_NOT_EQUAL */89
                ];
      case 39 :
          return [
                  env,
                  /* T_LESS_THAN_EQUAL */90
                ];
      case 40 :
          return [
                  env,
                  /* T_GREATER_THAN_EQUAL */91
                ];
      case 41 :
          return [
                  env,
                  /* T_EQUAL */86
                ];
      case 42 :
          return [
                  env,
                  /* T_NOT_EQUAL */87
                ];
      case 43 :
          return [
                  env,
                  /* T_INCR */105
                ];
      case 44 :
          return [
                  env,
                  /* T_DECR */106
                ];
      case 45 :
          return [
                  env,
                  /* T_LSHIFT_ASSIGN */68
                ];
      case 46 :
          return [
                  env,
                  /* T_LSHIFT */94
                ];
      case 47 :
          return [
                  env,
                  /* T_RSHIFT_ASSIGN */67
                ];
      case 48 :
          return [
                  env,
                  /* T_RSHIFT3_ASSIGN */66
                ];
      case 49 :
          return [
                  env,
                  /* T_RSHIFT3 */96
                ];
      case 50 :
          return [
                  env,
                  /* T_RSHIFT */95
                ];
      case 51 :
          return [
                  env,
                  /* T_PLUS_ASSIGN */77
                ];
      case 52 :
          return [
                  env,
                  /* T_MINUS_ASSIGN */76
                ];
      case 53 :
          return [
                  env,
                  /* T_MULT_ASSIGN */74
                ];
      case 54 :
          return [
                  env,
                  /* T_EXP_ASSIGN */75
                ];
      case 55 :
          return [
                  env,
                  /* T_MOD_ASSIGN */72
                ];
      case 56 :
          return [
                  env,
                  /* T_BIT_AND_ASSIGN */71
                ];
      case 57 :
          return [
                  env,
                  /* T_BIT_OR_ASSIGN */70
                ];
      case 58 :
          return [
                  env,
                  /* T_BIT_XOR_ASSIGN */69
                ];
      case 59 :
          return [
                  env,
                  /* T_LESS_THAN */92
                ];
      case 60 :
          return [
                  env,
                  /* T_GREATER_THAN */93
                ];
      case 61 :
          return [
                  env,
                  /* T_PLUS */97
                ];
      case 62 :
          return [
                  env,
                  /* T_MINUS */98
                ];
      case 63 :
          return [
                  env,
                  /* T_MULT */100
                ];
      case 64 :
          return [
                  env,
                  /* T_EXP */101
                ];
      case 65 :
          return [
                  env,
                  /* T_MOD */102
                ];
      case 66 :
          return [
                  env,
                  /* T_BIT_OR */83
                ];
      case 67 :
          return [
                  env,
                  /* T_BIT_AND */85
                ];
      case 68 :
          return [
                  env,
                  /* T_BIT_XOR */84
                ];
      case 69 :
          return [
                  env,
                  /* T_NOT */103
                ];
      case 70 :
          return [
                  env,
                  /* T_BIT_NOT */104
                ];
      case 71 :
          return [
                  env,
                  /* T_ASSIGN */78
                ];
      case 72 :
          return [
                  env,
                  /* T_ARROW */12
                ];
      case 73 :
          return [
                  env,
                  /* T_DIV_ASSIGN */73
                ];
      case 74 :
          return [
                  env,
                  /* T_DIV */99
                ];
      case 75 :
          return [
                  env,
                  /* T_AT */14
                ];
      case 76 :
          var env$8;
          if (env.lex_in_comment_syntax) {
            var loc$1 = loc_bs.from_lb(env.lex_source, lexbuf);
            env$8 = lex_error(env, loc$1, /* UnexpectedEOS */4);
          } else {
            env$8 = env;
          }
          return [
                  env$8,
                  /* T_EOF */108
                ];
      case 77 :
          var env$9 = lex_error(env, loc_bs.from_lb(env.lex_source, lexbuf), {
                TAG: /* UnexpectedToken */1,
                _0: "ILLEGAL"
              });
          return [
                  env$9,
                  /* T_ERROR */107
                ];
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
    var w$3 = lexing.sub_lexeme(lexbuf, caml_array.get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
    return illegal_number(env, lexbuf, w$3, {
                TAG: /* T_NUMBER */0,
                _0: /* NORMAL */3
              });
  }}

function type_token(env, lexbuf) {
  lexbuf.lex_mem = caml_array.caml_make_vect(26, -1);
  caml_array.set(lexbuf.lex_mem, 17, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 16, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 15, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 14, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 13, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 12, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 11, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 10, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 9, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 8, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 7, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 6, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 5, lexbuf.lex_curr_pos);
  caml_array.set(lexbuf.lex_mem, 4, lexbuf.lex_curr_pos);
  return __ocaml_lex_type_token_rec(env, lexbuf, 133);
}

function string_quote(env, q, buf, raw, octal, lexbuf) {
  return __ocaml_lex_string_quote_rec(env, q, buf, raw, octal, lexbuf, 256);
}

function __ocaml_lex_string_escape_rec(env, buf, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          return [
                  env,
                  false
                ];
      case 1 :
          buffer.add_string(buf, "\\");
          return [
                  env,
                  false
                ];
      case 2 :
          var a = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos + 1 | 0);
          var b = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos + 2 | 0);
          var code = (hexa_to_int(a) << 4) + hexa_to_int(b) | 0;
          list.iter((function (param) {
                  return buffer.add_char(buf, param);
                }), utf16to8(code));
          return [
                  env,
                  false
                ];
      case 3 :
          var a$1 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          var b$1 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos + 1 | 0);
          var c = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos + 2 | 0);
          var code$1 = ((oct_to_int(a$1) << 6) + (oct_to_int(b$1) << 3) | 0) + oct_to_int(c) | 0;
          if (code$1 < 256) {
            list.iter((function (param) {
                    return buffer.add_char(buf, param);
                  }), utf16to8(code$1));
          } else {
            var code$2 = (oct_to_int(a$1) << 3) + oct_to_int(b$1) | 0;
            list.iter((function (param) {
                    return buffer.add_char(buf, param);
                  }), utf16to8(code$2));
            buffer.add_char(buf, c);
          }
          return [
                  env,
                  true
                ];
      case 4 :
          var a$2 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          var b$2 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos + 1 | 0);
          var code$3 = (oct_to_int(a$2) << 3) + oct_to_int(b$2) | 0;
          list.iter((function (param) {
                  return buffer.add_char(buf, param);
                }), utf16to8(code$3));
          return [
                  env,
                  true
                ];
      case 5 :
          buffer.add_char(buf, char.chr(0));
          return [
                  env,
                  false
                ];
      case 6 :
          buffer.add_char(buf, char.chr(8));
          return [
                  env,
                  false
                ];
      case 7 :
          buffer.add_char(buf, char.chr(12));
          return [
                  env,
                  false
                ];
      case 8 :
          buffer.add_char(buf, char.chr(10));
          return [
                  env,
                  false
                ];
      case 9 :
          buffer.add_char(buf, char.chr(13));
          return [
                  env,
                  false
                ];
      case 10 :
          buffer.add_char(buf, char.chr(9));
          return [
                  env,
                  false
                ];
      case 11 :
          buffer.add_char(buf, char.chr(11));
          return [
                  env,
                  false
                ];
      case 12 :
          var a$3 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          var code$4 = oct_to_int(a$3);
          list.iter((function (param) {
                  return buffer.add_char(buf, param);
                }), utf16to8(code$4));
          return [
                  env,
                  true
                ];
      case 13 :
          var a$4 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos + 1 | 0);
          var b$3 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos + 2 | 0);
          var c$1 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos + 3 | 0);
          var d = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos + 4 | 0);
          var code$5 = (((hexa_to_int(a$4) << 12) + (hexa_to_int(b$3) << 8) | 0) + (hexa_to_int(c$1) << 4) | 0) + hexa_to_int(d) | 0;
          list.iter((function (param) {
                  return buffer.add_char(buf, param);
                }), utf16to8(code$5));
          return [
                  env,
                  false
                ];
      case 14 :
          var hex_code = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos + 2 | 0, lexbuf.lex_curr_pos - 1 | 0);
          var code$6 = caml_format.caml_int_of_string("0x" + hex_code);
          var env$1 = code$6 > 1114111 ? lex_error(env, loc_bs.from_lb(env.lex_source, lexbuf), {
                  TAG: /* UnexpectedToken */1,
                  _0: "ILLEGAL"
                }) : env;
          list.iter((function (param) {
                  return buffer.add_char(buf, param);
                }), utf16to8(code$6));
          return [
                  env$1,
                  false
                ];
      case 15 :
          var c$2 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          var env$2 = lex_error(env, loc_bs.from_lb(env.lex_source, lexbuf), {
                TAG: /* UnexpectedToken */1,
                _0: "ILLEGAL"
              });
          buffer.add_char(buf, c$2);
          return [
                  env$2,
                  false
                ];
      case 16 :
          lexing.new_line(lexbuf);
          return [
                  env,
                  false
                ];
      case 17 :
          var c$3 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(buf, c$3);
          return [
                  env,
                  false
                ];
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function __ocaml_lex_jsx_child_rec(env, start, buf, raw, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          var lt = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          buffer.add_string(raw, lt);
          buffer.add_string(buf, lt);
          lexing.new_line(lexbuf);
          var match = jsx_text(env, /* JSX_CHILD_TEXT */2, buf, raw, lexbuf);
          var value = buffer.contents(buf);
          var raw$1 = buffer.contents(raw);
          return [
                  match[0],
                  {
                    TAG: /* T_JSX_TEXT */4,
                    _0: [
                      loc_bs.btwn(start, match[1]),
                      value,
                      raw$1
                    ]
                  }
                ];
      case 1 :
          return [
                  env,
                  /* T_EOF */108
                ];
      case 2 :
          return [
                  env,
                  /* T_LESS_THAN */92
                ];
      case 3 :
          return [
                  env,
                  /* T_LCURLY */1
                ];
      case 4 :
          var c = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(raw, c);
          buffer.add_char(buf, c);
          var match$1 = jsx_text(env, /* JSX_CHILD_TEXT */2, buf, raw, lexbuf);
          var value$1 = buffer.contents(buf);
          var raw$2 = buffer.contents(raw);
          return [
                  match$1[0],
                  {
                    TAG: /* T_JSX_TEXT */4,
                    _0: [
                      loc_bs.btwn(start, match$1[1]),
                      value$1,
                      raw$2
                    ]
                  }
                ];
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function __ocaml_lex_regexp_class_rec(env, buf, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          return env;
      case 1 :
      case 2 :
          break;
      case 3 :
          var c = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(buf, c);
          return env;
      case 4 :
          var c$1 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(buf, c$1);
          return regexp_class(env, buf, lexbuf);
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
    var s = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_start_pos + 2 | 0);
    buffer.add_string(buf, s);
    return regexp_class(env, buf, lexbuf);
  }}

function string_escape(env, buf, lexbuf) {
  return __ocaml_lex_string_escape_rec(env, buf, lexbuf, 261);
}

function __ocaml_lex_template_part_rec(env, start, cooked, raw, literal, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          var env$1 = lex_error(env, loc_bs.from_lb(env.lex_source, lexbuf), {
                TAG: /* UnexpectedToken */1,
                _0: "ILLEGAL"
              });
          return [
                  env$1,
                  loc_bs.btwn(start, loc_bs.from_lb(env$1.lex_source, lexbuf)),
                  true
                ];
      case 1 :
          buffer.add_char(literal, /* "`" */96);
          return [
                  env,
                  loc_bs.btwn(start, loc_bs.from_lb(env.lex_source, lexbuf)),
                  true
                ];
      case 2 :
          buffer.add_string(literal, "${");
          return [
                  env,
                  loc_bs.btwn(start, loc_bs.from_lb(env.lex_source, lexbuf)),
                  false
                ];
      case 3 :
          buffer.add_char(raw, /* "\\" */92);
          buffer.add_char(literal, /* "\\" */92);
          var match = string_escape(env, cooked, lexbuf);
          var str = lexing.lexeme(lexbuf);
          buffer.add_string(raw, str);
          buffer.add_string(literal, str);
          return template_part(match[0], start, cooked, raw, literal, lexbuf);
      case 4 :
          var lf = lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_start_pos + 2 | 0);
          buffer.add_string(raw, lf);
          buffer.add_string(literal, lf);
          buffer.add_string(cooked, "\n");
          lexing.new_line(lexbuf);
          return template_part(env, start, cooked, raw, literal, lexbuf);
      case 5 :
          var lf$1 = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(raw, lf$1);
          buffer.add_char(literal, lf$1);
          buffer.add_char(cooked, /* "\n" */10);
          lexing.new_line(lexbuf);
          return template_part(env, start, cooked, raw, literal, lexbuf);
      case 6 :
          var c = lexing.sub_lexeme_char(lexbuf, lexbuf.lex_start_pos);
          buffer.add_char(raw, c);
          buffer.add_char(literal, c);
          buffer.add_char(cooked, c);
          return template_part(env, start, cooked, raw, literal, lexbuf);
      default:
        curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  }}

function jsx_child(env, start, buf, raw, lexbuf) {
  return __ocaml_lex_jsx_child_rec(env, start, buf, raw, lexbuf, 373);
}

function regexp(env) {
  return get_result_and_clear_state(__ocaml_lex_regexp_rec(env, env.lex_lb, 300));
}

function jsx_child$1(env) {
  var start = loc_bs.from_curr_lb(env.lex_source, env.lex_lb);
  var buf = buffer.create(127);
  var raw = buffer.create(127);
  var match = jsx_child(env, start, buf, raw, env.lex_lb);
  return get_result_and_clear_state([
              match[0],
              match[1]
            ]);
}

function jsx_tag(env) {
  return get_result_and_clear_state(__ocaml_lex_jsx_tag_rec(env, env.lex_lb, 342));
}

function template_tail(env) {
  return get_result_and_clear_state(__ocaml_lex_template_tail_rec(env, env.lex_lb, 402));
}

function type_token$1(env) {
  return get_result_and_clear_state(type_token(env, env.lex_lb));
}

function token$2(env) {
  return get_result_and_clear_state(token$1(env, env.lex_lb));
}

var Ast;

var Ast_1 = Ast;
var Token_1 = Token;
var yyback_1 = yyback;
var back_1 = back;
var debug_string_of_lexing_position_1 = debug_string_of_lexing_position;
var debug_string_of_lexbuf_1 = debug_string_of_lexbuf;
var Lex_env_1 = Lex_env;
var Lex_result_1 = Lex_result;
var loc_of_lexbuf_1 = loc_of_lexbuf;
var get_result_and_clear_state_1 = get_result_and_clear_state;
var lex_error_1 = lex_error;
var unexpected_error_1 = unexpected_error;
var unexpected_error_w_suggest_1 = unexpected_error_w_suggest;
var illegal_1 = illegal;
var illegal_number_1 = illegal_number;
var FloatOfString_1 = FloatOfString;
var save_comment_1 = save_comment;
var unicode_fix_cols_1 = unicode_fix_cols;
var oct_to_int_1 = oct_to_int;
var hexa_to_int_1 = hexa_to_int;
var utf16to8_1 = utf16to8;
var mk_num_singleton_1 = mk_num_singleton;
var keywords_1 = keywords;
var type_keywords_1 = type_keywords;
var __ocaml_lex_tables_1 = __ocaml_lex_tables;
var __ocaml_lex_token_rec_1 = __ocaml_lex_token_rec;
var __ocaml_lex_type_token_rec_1 = __ocaml_lex_type_token_rec;
var string_quote_1 = string_quote;
var __ocaml_lex_string_quote_rec_1 = __ocaml_lex_string_quote_rec;
var string_escape_1 = string_escape;
var __ocaml_lex_string_escape_rec_1 = __ocaml_lex_string_escape_rec;
var comment_1 = comment;
var __ocaml_lex_comment_rec_1 = __ocaml_lex_comment_rec;
var line_comment_1 = line_comment;
var __ocaml_lex_line_comment_rec_1 = __ocaml_lex_line_comment_rec;
var __ocaml_lex_regexp_rec_1 = __ocaml_lex_regexp_rec;
var regexp_body_1 = regexp_body;
var __ocaml_lex_regexp_body_rec_1 = __ocaml_lex_regexp_body_rec;
var regexp_class_1 = regexp_class;
var __ocaml_lex_regexp_class_rec_1 = __ocaml_lex_regexp_class_rec;
var __ocaml_lex_jsx_tag_rec_1 = __ocaml_lex_jsx_tag_rec;
var __ocaml_lex_jsx_child_rec_1 = __ocaml_lex_jsx_child_rec;
var jsx_text_1 = jsx_text;
var __ocaml_lex_jsx_text_rec_1 = __ocaml_lex_jsx_text_rec;
var __ocaml_lex_template_tail_rec_1 = __ocaml_lex_template_tail_rec;
var template_part_1 = template_part;
var __ocaml_lex_template_part_rec_1 = __ocaml_lex_template_part_rec;
var regexp_1 = regexp;
var jsx_child_1 = jsx_child$1;
var jsx_tag_1 = jsx_tag;
var template_tail_1 = template_tail;
var type_token_1 = type_token$1;
var token_1 = token$2;
/* keywords Not a pure module */

var lexer_flow_bs = {
	Ast: Ast_1,
	Token: Token_1,
	yyback: yyback_1,
	back: back_1,
	debug_string_of_lexing_position: debug_string_of_lexing_position_1,
	debug_string_of_lexbuf: debug_string_of_lexbuf_1,
	Lex_env: Lex_env_1,
	Lex_result: Lex_result_1,
	loc_of_lexbuf: loc_of_lexbuf_1,
	get_result_and_clear_state: get_result_and_clear_state_1,
	lex_error: lex_error_1,
	unexpected_error: unexpected_error_1,
	unexpected_error_w_suggest: unexpected_error_w_suggest_1,
	illegal: illegal_1,
	illegal_number: illegal_number_1,
	FloatOfString: FloatOfString_1,
	save_comment: save_comment_1,
	unicode_fix_cols: unicode_fix_cols_1,
	oct_to_int: oct_to_int_1,
	hexa_to_int: hexa_to_int_1,
	utf16to8: utf16to8_1,
	mk_num_singleton: mk_num_singleton_1,
	keywords: keywords_1,
	type_keywords: type_keywords_1,
	__ocaml_lex_tables: __ocaml_lex_tables_1,
	__ocaml_lex_token_rec: __ocaml_lex_token_rec_1,
	__ocaml_lex_type_token_rec: __ocaml_lex_type_token_rec_1,
	string_quote: string_quote_1,
	__ocaml_lex_string_quote_rec: __ocaml_lex_string_quote_rec_1,
	string_escape: string_escape_1,
	__ocaml_lex_string_escape_rec: __ocaml_lex_string_escape_rec_1,
	comment: comment_1,
	__ocaml_lex_comment_rec: __ocaml_lex_comment_rec_1,
	line_comment: line_comment_1,
	__ocaml_lex_line_comment_rec: __ocaml_lex_line_comment_rec_1,
	__ocaml_lex_regexp_rec: __ocaml_lex_regexp_rec_1,
	regexp_body: regexp_body_1,
	__ocaml_lex_regexp_body_rec: __ocaml_lex_regexp_body_rec_1,
	regexp_class: regexp_class_1,
	__ocaml_lex_regexp_class_rec: __ocaml_lex_regexp_class_rec_1,
	__ocaml_lex_jsx_tag_rec: __ocaml_lex_jsx_tag_rec_1,
	__ocaml_lex_jsx_child_rec: __ocaml_lex_jsx_child_rec_1,
	jsx_text: jsx_text_1,
	__ocaml_lex_jsx_text_rec: __ocaml_lex_jsx_text_rec_1,
	__ocaml_lex_template_tail_rec: __ocaml_lex_template_tail_rec_1,
	template_part: template_part_1,
	__ocaml_lex_template_part_rec: __ocaml_lex_template_part_rec_1,
	regexp: regexp_1,
	jsx_child: jsx_child_1,
	jsx_tag: jsx_tag_1,
	template_tail: template_tail_1,
	type_token: type_token_1,
	token: token_1
};

var SSet = set$2.Make({
      compare: string.compare
    });

function debug_string_of_lex_mode(mode) {
  switch (mode) {
    case /* NORMAL */0 :
        return "NORMAL";
    case /* TYPE */1 :
        return "TYPE";
    case /* JSX_TAG */2 :
        return "JSX_TAG";
    case /* JSX_CHILD */3 :
        return "JSX_CHILD";
    case /* TEMPLATE */4 :
        return "TEMPLATE";
    case /* REGEXP */5 :
        return "REGEXP";
    
  }
}

var Lex_mode = {
  debug_string_of_lex_mode: debug_string_of_lex_mode
};

function create$4(lex_env, mode) {
  var lexbuf = lexer_flow_bs.Lex_env.lexbuf(lex_env);
  var lexbuf$1 = {
    refill_buff: lexbuf.refill_buff,
    lex_buffer: lexbuf.lex_buffer,
    lex_buffer_len: lexbuf.lex_buffer_len,
    lex_abs_pos: lexbuf.lex_abs_pos,
    lex_start_pos: lexbuf.lex_start_pos,
    lex_curr_pos: lexbuf.lex_curr_pos,
    lex_last_pos: lexbuf.lex_last_pos,
    lex_last_action: lexbuf.lex_last_action,
    lex_eof_reached: lexbuf.lex_eof_reached,
    lex_mem: lexbuf.lex_mem,
    lex_start_p: lexbuf.lex_start_p,
    lex_curr_p: lexbuf.lex_curr_p
  };
  var lex_env$1 = lexer_flow_bs.Lex_env.with_lexbuf(lexbuf$1, lex_env);
  return {
          la_results: [],
          la_num_lexed: 0,
          la_lex_mode: mode,
          la_lex_env: lex_env$1
        };
}

function next_power_of_two(n) {
  var _i = 1;
  while(true) {
    var i = _i;
    if (i >= n) {
      return i;
    }
    _i = (i << 1);
    continue ;
  }}

function grow(t, n) {
  if (t.la_results.length >= n) {
    return ;
  }
  var new_size = next_power_of_two(n);
  var filler = function (i) {
    if (i < t.la_results.length) {
      return caml_array.get(t.la_results, i);
    }
    
  };
  var new_arr = array.init(new_size, filler);
  t.la_results = new_arr;
  
}

function lex(t) {
  var lex_env = t.la_lex_env;
  var match = t.la_lex_mode;
  var match$1;
  switch (match) {
    case /* NORMAL */0 :
        match$1 = lexer_flow_bs.token(lex_env);
        break;
    case /* TYPE */1 :
        match$1 = lexer_flow_bs.type_token(lex_env);
        break;
    case /* JSX_TAG */2 :
        match$1 = lexer_flow_bs.jsx_tag(lex_env);
        break;
    case /* JSX_CHILD */3 :
        match$1 = lexer_flow_bs.jsx_child(lex_env);
        break;
    case /* TEMPLATE */4 :
        match$1 = lexer_flow_bs.template_tail(lex_env);
        break;
    case /* REGEXP */5 :
        match$1 = lexer_flow_bs.regexp(lex_env);
        break;
    
  }
  var lex_env$1 = match$1[0];
  var lexbuf = lexer_flow_bs.Lex_env.lexbuf(lex_env$1);
  var lexbuf$1 = {
    refill_buff: lexbuf.refill_buff,
    lex_buffer: lexbuf.lex_buffer,
    lex_buffer_len: lexbuf.lex_buffer_len,
    lex_abs_pos: lexbuf.lex_abs_pos,
    lex_start_pos: lexbuf.lex_start_pos,
    lex_curr_pos: lexbuf.lex_curr_pos,
    lex_last_pos: lexbuf.lex_last_pos,
    lex_last_action: lexbuf.lex_last_action,
    lex_eof_reached: lexbuf.lex_eof_reached,
    lex_mem: lexbuf.lex_mem,
    lex_start_p: lexbuf.lex_start_p,
    lex_curr_p: lexbuf.lex_curr_p
  };
  var cloned_env = lexer_flow_bs.Lex_env.with_lexbuf(lexbuf$1, lex_env$1);
  t.la_lex_env = lex_env$1;
  caml_array.set(t.la_results, t.la_num_lexed, [
        cloned_env,
        match$1[1]
      ]);
  t.la_num_lexed = t.la_num_lexed + 1 | 0;
  
}

function lex_until(t, i) {
  grow(t, i + 1 | 0);
  while(t.la_num_lexed <= i) {
    lex(t);
  }  
}

var default_parse_options = {
  esproposal_class_instance_fields: false,
  esproposal_class_static_fields: false,
  esproposal_decorators: false,
  esproposal_export_star_as: false,
  types: true,
  use_strict: false
};

function init_env(token_sinkOpt, parse_optionsOpt, source, content) {
  var token_sink = token_sinkOpt !== undefined ? caml_option.valFromOption(token_sinkOpt) : undefined;
  var parse_options = parse_optionsOpt !== undefined ? caml_option.valFromOption(parse_optionsOpt) : undefined;
  var lb = lexing.from_string(content);
  if (source !== undefined && typeof source !== "number") {
    var init = lb.lex_curr_p;
    lb.lex_curr_p = {
      pos_fname: source._0,
      pos_lnum: init.pos_lnum,
      pos_bol: init.pos_bol,
      pos_cnum: init.pos_cnum
    };
  }
  var parse_options$1 = parse_options !== undefined ? parse_options : default_parse_options;
  var enable_types_in_comments = parse_options$1.types;
  var lex_env = lexer_flow_bs.Lex_env.new_lex_env(source, lb, enable_types_in_comments);
  return {
          errors: {
            contents: /* [] */0
          },
          comments: {
            contents: /* [] */0
          },
          labels: SSet.empty,
          exports: {
            contents: SSet.empty
          },
          last_loc: {
            contents: undefined
          },
          in_strict_mode: parse_options$1.use_strict,
          in_export: false,
          in_loop: false,
          in_switch: false,
          in_function: false,
          no_in: false,
          no_call: false,
          no_let: false,
          no_anon_function_type: false,
          no_new: false,
          allow_yield: true,
          allow_await: false,
          allow_directive: false,
          error_callback: undefined,
          lex_mode_stack: {
            contents: {
              hd: /* NORMAL */0,
              tl: /* [] */0
            }
          },
          lex_env: {
            contents: lex_env
          },
          lookahead: {
            contents: create$4(lex_env, /* NORMAL */0)
          },
          token_sink: {
            contents: token_sink
          },
          parse_options: parse_options$1,
          source: source
        };
}

function in_strict_mode(env) {
  return env.in_strict_mode;
}

function in_export(env) {
  return env.in_export;
}

function comments$1(env) {
  return env.comments.contents;
}

function labels(env) {
  return env.labels;
}

function in_loop(env) {
  return env.in_loop;
}

function in_switch(env) {
  return env.in_switch;
}

function in_function(env) {
  return env.in_function;
}

function allow_yield(env) {
  return env.allow_yield;
}

function allow_await(env) {
  return env.allow_await;
}

function allow_directive(env) {
  return env.allow_directive;
}

function no_in(env) {
  return env.no_in;
}

function no_call(env) {
  return env.no_call;
}

function no_let(env) {
  return env.no_let;
}

function no_anon_function_type(env) {
  return env.no_anon_function_type;
}

function no_new(env) {
  return env.no_new;
}

function errors$1(env) {
  return env.errors.contents;
}

function parse_options(env) {
  return env.parse_options;
}

function source$2(env) {
  return env.source;
}

function should_parse_types(env) {
  return env.parse_options.types;
}

function error_at(env, param) {
  var e = param[1];
  env.errors.contents = {
    hd: [
      param[0],
      e
    ],
    tl: env.errors.contents
  };
  var callback = env.error_callback;
  if (callback !== undefined) {
    return curry._2(callback, env, e);
  }
  
}

function comment_list(env) {
  return function (param) {
    return list.iter((function (c) {
                  env.comments.contents = {
                    hd: c,
                    tl: env.comments.contents
                  };
                  
                }), param);
  };
}

function record_export(env, param) {
  var export_name = param[1];
  var $$exports = env.exports.contents;
  if (curry._2(SSet.mem, export_name, $$exports)) {
    return error_at(env, [
                param[0],
                {
                  TAG: /* DuplicateExport */7,
                  _0: export_name
                }
              ]);
  } else {
    env.exports.contents = curry._2(SSet.add, export_name, env.exports.contents);
    return ;
  }
}

function lookahead(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  if (i >= 2) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "parser_env.ml",
            294,
            2
          ],
          Error: new Error()
        };
  }
  var t = env.lookahead.contents;
  lex_until(t, i);
  var match = caml_array.get(t.la_results, i);
  if (match !== undefined) {
    return match[1];
  } else {
    return pervasives.failwith("Lookahead.peek failed");
  }
}

function with_strict(in_strict_mode, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.in_strict_mode = in_strict_mode;
  return newrecord;
}

function with_in_function(in_function, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.in_function = in_function;
  return newrecord;
}

function with_allow_yield(allow_yield, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.allow_yield = allow_yield;
  return newrecord;
}

function with_allow_await(allow_await, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.allow_await = allow_await;
  return newrecord;
}

function with_allow_directive(allow_directive, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.allow_directive = allow_directive;
  return newrecord;
}

function with_no_let(no_let, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.no_let = no_let;
  return newrecord;
}

function with_in_loop(in_loop, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.in_loop = in_loop;
  return newrecord;
}

function with_no_in(no_in, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.no_in = no_in;
  return newrecord;
}

function with_no_anon_function_type(no_anon_function_type, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.no_anon_function_type = no_anon_function_type;
  return newrecord;
}

function with_no_new(no_new, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.no_new = no_new;
  return newrecord;
}

function with_in_switch(in_switch, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.in_switch = in_switch;
  return newrecord;
}

function with_in_export(in_export, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.in_export = in_export;
  return newrecord;
}

function with_no_call(no_call, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.no_call = no_call;
  return newrecord;
}

function with_error_callback(error_callback, env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.error_callback = error_callback;
  return newrecord;
}

function error_list(env) {
  return function (param) {
    return list.iter((function (param) {
                  return error_at(env, param);
                }), param);
  };
}

function last_loc(env) {
  return env.last_loc.contents;
}

function without_error_callback(env) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.error_callback = undefined;
  return newrecord;
}

function add_label(env, label) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.labels = curry._2(SSet.add, label, env.labels);
  return newrecord;
}

function enter_function(env, async, generator) {
  var newrecord = caml_obj.caml_obj_dup(env);
  newrecord.allow_await = async;
  newrecord.allow_yield = generator;
  newrecord.in_function = true;
  newrecord.in_switch = false;
  newrecord.in_loop = false;
  newrecord.labels = SSet.empty;
  return newrecord;
}

function is_future_reserved(param) {
  if (param === "enum") {
    return true;
  } else {
    return false;
  }
}

function is_strict_reserved(param) {
  switch (param) {
    case "implements" :
    case "interface" :
    case "package" :
    case "private" :
    case "protected" :
    case "public" :
    case "static" :
    case "yield" :
        return true;
    default:
      return false;
  }
}

function is_restricted(param) {
  switch (param) {
    case "arguments" :
    case "eval" :
        return true;
    default:
      return false;
  }
}

function token$3(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  return lexer_flow_bs.Lex_result.token(lookahead(i, env));
}

function value$1(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  return lexer_flow_bs.Lex_result.value(lookahead(i, env));
}

function loc$1(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  return lexer_flow_bs.Lex_result.loc(lookahead(i, env));
}

function errors$1$1(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  return lexer_flow_bs.Lex_result.errors(lookahead(i, env));
}

function comments$1$1(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  return lexer_flow_bs.Lex_result.comments(lookahead(i, env));
}

function lex_env(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  var t = env.lookahead.contents;
  lex_until(t, i);
  var match = caml_array.get(t.la_results, i);
  if (match !== undefined) {
    return match[0];
  } else {
    return pervasives.failwith("Lookahead.peek failed");
  }
}

function is_line_terminator(env) {
  var loc$prime = env.last_loc.contents;
  if (loc$prime !== undefined) {
    return loc$1(undefined, env).start.line > loc$prime.start.line;
  } else {
    return false;
  }
}

function is_implicit_semicolon(env) {
  var match = token$3(undefined, env);
  if (typeof match !== "number") {
    return is_line_terminator(env);
  }
  var switcher = match - 3 | 0;
  if (switcher > 104 || switcher < 0) {
    if ((switcher + 1 >>> 0) > 106) {
      return is_line_terminator(env);
    } else {
      return true;
    }
  } else if (switcher !== 6) {
    return is_line_terminator(env);
  } else {
    return false;
  }
}

function semicolon_loc(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  if (token$3(i, env) === /* T_SEMICOLON */9) {
    return loc$1(i, env);
  }
  
}

function is_identifier(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  var name = value$1(i, env);
  var match = token$3(i, env);
  if (is_strict_reserved(name) || is_restricted(name) || is_future_reserved(name)) {
    return true;
  }
  if (typeof match !== "number") {
    return false;
  }
  var switcher = match - 1 | 0;
  if (switcher > 58 || switcher < 0) {
    return switcher < 64;
  } else {
    return switcher === 27;
  }
}

function is_literal_property_name(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  if (is_identifier(i, env)) {
    return true;
  }
  var match = token$3(i, env);
  if (typeof match === "number") {
    return false;
  }
  switch (match.TAG | 0) {
    case /* T_NUMBER */0 :
    case /* T_STRING */1 :
        return true;
    default:
      return false;
  }
}

function is_function(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  if (token$3(i, env) === /* T_FUNCTION */15) {
    return true;
  } else if (token$3(i, env) === /* T_ASYNC */63) {
    return token$3(i + 1 | 0, env) === /* T_FUNCTION */15;
  } else {
    return false;
  }
}

function is_class(iOpt, env) {
  var i = iOpt !== undefined ? iOpt : 0;
  var match = token$3(i, env);
  if (typeof match === "number") {
    if (match !== 14) {
      return match === 40;
    } else {
      return true;
    }
  } else {
    return false;
  }
}

function error$2(env, e) {
  var loc$1$1 = loc$1(undefined, env);
  return error_at(env, [
              loc$1$1,
              e
            ]);
}

function get_unexpected_error(param) {
  var tmp = param[0];
  if (typeof tmp === "number") {
    switch (tmp) {
      case /* T_IDENTIFIER */0 :
          return /* UnexpectedIdentifier */2;
      case /* T_EOF */108 :
          return /* UnexpectedEOS */4;
        
    }
  } else {
    switch (tmp.TAG | 0) {
      case /* T_NUMBER */0 :
          return /* UnexpectedNumber */0;
      case /* T_STRING */1 :
      case /* T_JSX_TEXT */4 :
          return /* UnexpectedString */1;
        
    }
  }
  var word = param[1];
  if (is_future_reserved(word)) {
    return /* UnexpectedReserved */3;
  } else if (is_strict_reserved(word)) {
    return /* StrictReservedWord */40;
  } else {
    return {
            TAG: /* UnexpectedToken */1,
            _0: word
          };
  }
}

function error_unexpected(env) {
  error_list(env)(errors$1$1(undefined, env));
  return error$2(env, get_unexpected_error([
                  token$3(undefined, env),
                  value$1(undefined, env)
                ]));
}

function error_on_decorators(env) {
  return function (param) {
    return list.iter((function (decorator) {
                  return error_at(env, [
                              decorator[0],
                              /* UnsupportedDecorator */57
                            ]);
                }), param);
  };
}

function strict_error(env, e) {
  if (env.in_strict_mode) {
    return error$2(env, e);
  }
  
}

function strict_error_at(env, param) {
  if (env.in_strict_mode) {
    return error_at(env, [
                param[0],
                param[1]
              ]);
  }
  
}

function token$1$1(env) {
  var token_sink = env.token_sink.contents;
  if (token_sink !== undefined) {
    var token_loc = loc$1(undefined, env);
    var token$2 = token$3(undefined, env);
    var token_value = value$1(undefined, env);
    curry._1(token_sink, {
          token_loc: token_loc,
          token: token$2,
          token_context: list.hd(env.lex_mode_stack.contents),
          token_value: token_value
        });
  }
  env.lex_env.contents = lex_env(undefined, env);
  error_list(env)(errors$1$1(undefined, env));
  comment_list(env)(comments$1$1(undefined, env));
  env.last_loc.contents = loc$1(undefined, env);
  var t = env.lookahead.contents;
  lex_until(t, 0);
  if (t.la_num_lexed > 1) {
    array.blit(t.la_results, 1, t.la_results, 0, t.la_num_lexed - 1 | 0);
  }
  caml_array.set(t.la_results, t.la_num_lexed - 1 | 0, undefined);
  t.la_num_lexed = t.la_num_lexed - 1 | 0;
  
}

function push_lex_mode(env, mode) {
  env.lex_mode_stack.contents = {
    hd: mode,
    tl: env.lex_mode_stack.contents
  };
  env.lookahead.contents = create$4(env.lex_env.contents, list.hd(env.lex_mode_stack.contents));
  
}

function pop_lex_mode(env) {
  var match = env.lex_mode_stack.contents;
  var new_stack = match ? match.tl : pervasives.failwith("Popping lex mode from empty stack");
  env.lex_mode_stack.contents = new_stack;
  env.lookahead.contents = create$4(env.lex_env.contents, list.hd(env.lex_mode_stack.contents));
  
}

function double_pop_lex_mode(env) {
  var match = env.lex_mode_stack.contents;
  var new_stack;
  if (match) {
    var match$1 = match.tl;
    new_stack = match$1 ? match$1.tl : pervasives.failwith("Popping lex mode from empty stack");
  } else {
    new_stack = pervasives.failwith("Popping lex mode from empty stack");
  }
  env.lex_mode_stack.contents = new_stack;
  env.lookahead.contents = create$4(env.lex_env.contents, list.hd(env.lex_mode_stack.contents));
  
}

function semicolon(env) {
  if (!is_implicit_semicolon(env)) {
    if (token$3(undefined, env) === /* T_SEMICOLON */9) {
      return token$1$1(env);
    } else {
      return error_unexpected(env);
    }
  }
  
}

var Eat = {
  token: token$1$1,
  push_lex_mode: push_lex_mode,
  pop_lex_mode: pop_lex_mode,
  double_pop_lex_mode: double_pop_lex_mode,
  semicolon: semicolon
};

function token$2$1(env, t) {
  if (caml_obj.caml_notequal(token$3(undefined, env), t)) {
    error_unexpected(env);
  }
  return token$1$1(env);
}

function maybe(env, t) {
  if (caml_obj.caml_equal(token$3(undefined, env), t)) {
    token$1$1(env);
    return true;
  } else {
    return false;
  }
}

function contextual(env, str) {
  if (value$1(undefined, env) !== str) {
    error_unexpected(env);
  }
  return token$1$1(env);
}

var Expect = {
  token: token$2$1,
  maybe: maybe,
  contextual: contextual
};

var Rollback = caml_exceptions.create("Parser_env.Try.Rollback");

function save_state(env) {
  var orig_token_sink = env.token_sink.contents;
  var token_buffer;
  if (orig_token_sink !== undefined) {
    var buffer = queue.create(undefined);
    env.token_sink.contents = (function (token_data) {
        return queue.add(token_data, buffer);
      });
    token_buffer = [
      orig_token_sink,
      buffer
    ];
  } else {
    token_buffer = undefined;
  }
  return {
          saved_errors: env.errors.contents,
          saved_comments: env.comments.contents,
          saved_last_loc: env.last_loc.contents,
          saved_lex_mode_stack: env.lex_mode_stack.contents,
          saved_lex_env: env.lex_env.contents,
          token_buffer: token_buffer
        };
}

function reset_token_sink(flush, env, token_buffer_info) {
  if (token_buffer_info === undefined) {
    return ;
  }
  var orig_token_sink = token_buffer_info[0];
  env.token_sink.contents = orig_token_sink;
  if (flush) {
    return queue.iter(orig_token_sink, token_buffer_info[1]);
  }
  
}

function to_parse(env, parse) {
  var saved_state = save_state(env);
  try {
    var result = curry._1(parse, env);
    reset_token_sink(true, env, saved_state.token_buffer);
    return /* ParsedSuccessfully */{
            _0: result
          };
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Rollback) {
      reset_token_sink(false, env, saved_state.token_buffer);
      env.errors.contents = saved_state.saved_errors;
      env.comments.contents = saved_state.saved_comments;
      env.last_loc.contents = saved_state.saved_last_loc;
      env.lex_mode_stack.contents = saved_state.saved_lex_mode_stack;
      env.lex_env.contents = saved_state.saved_lex_env;
      env.lookahead.contents = create$4(env.lex_env.contents, list.hd(env.lex_mode_stack.contents));
      return /* FailedToParse */0;
    }
    throw exn;
  }
}

var Peek = {
  token: token$3,
  value: value$1,
  loc: loc$1,
  errors: errors$1$1,
  comments: comments$1$1,
  is_line_terminator: is_line_terminator,
  is_implicit_semicolon: is_implicit_semicolon,
  semicolon_loc: semicolon_loc,
  is_identifier: is_identifier,
  is_literal_property_name: is_literal_property_name,
  is_function: is_function,
  is_class: is_class
};

var Try = {
  Rollback: Rollback,
  to_parse: to_parse
};

var SSet_1 = SSet;
var Lex_mode_1 = Lex_mode;
var default_parse_options_1 = default_parse_options;
var init_env_1 = init_env;
var in_strict_mode_1 = in_strict_mode;
var last_loc_1 = last_loc;
var in_export_1 = in_export;
var labels_1 = labels;
var comments_1 = comments$1;
var in_loop_1 = in_loop;
var in_switch_1 = in_switch;
var in_function_1 = in_function;
var allow_yield_1 = allow_yield;
var allow_await_1 = allow_await;
var allow_directive_1 = allow_directive;
var no_in_1 = no_in;
var no_call_1 = no_call;
var no_let_1 = no_let;
var no_anon_function_type_1 = no_anon_function_type;
var no_new_1 = no_new;
var errors_1 = errors$1;
var parse_options_1 = parse_options;
var source_1$1 = source$2;
var should_parse_types_1 = should_parse_types;
var error_at_1 = error_at;
var error_1$1 = error$2;
var error_unexpected_1 = error_unexpected;
var error_on_decorators_1 = error_on_decorators;
var strict_error_1 = strict_error;
var strict_error_at_1 = strict_error_at;
var get_unexpected_error_1 = get_unexpected_error;
var comment_list_1 = comment_list;
var error_list_1 = error_list;
var record_export_1 = record_export;
var with_strict_1 = with_strict;
var with_in_function_1 = with_in_function;
var with_allow_yield_1 = with_allow_yield;
var with_allow_await_1 = with_allow_await;
var with_allow_directive_1 = with_allow_directive;
var with_no_let_1 = with_no_let;
var with_in_loop_1 = with_in_loop;
var with_no_in_1 = with_no_in;
var with_no_anon_function_type_1 = with_no_anon_function_type;
var with_no_new_1 = with_no_new;
var with_in_switch_1 = with_in_switch;
var with_in_export_1 = with_in_export;
var with_no_call_1 = with_no_call;
var with_error_callback_1 = with_error_callback;
var without_error_callback_1 = without_error_callback;
var add_label_1 = add_label;
var enter_function_1 = enter_function;
var is_future_reserved_1 = is_future_reserved;
var is_strict_reserved_1 = is_strict_reserved;
var is_restricted_1 = is_restricted;
var Peek_1 = Peek;
var Eat_1 = Eat;
var Expect_1 = Expect;
var Try_1 = Try;
/* SSet Not a pure module */

var parser_env_bs = {
	SSet: SSet_1,
	Lex_mode: Lex_mode_1,
	default_parse_options: default_parse_options_1,
	init_env: init_env_1,
	in_strict_mode: in_strict_mode_1,
	last_loc: last_loc_1,
	in_export: in_export_1,
	labels: labels_1,
	comments: comments_1,
	in_loop: in_loop_1,
	in_switch: in_switch_1,
	in_function: in_function_1,
	allow_yield: allow_yield_1,
	allow_await: allow_await_1,
	allow_directive: allow_directive_1,
	no_in: no_in_1,
	no_call: no_call_1,
	no_let: no_let_1,
	no_anon_function_type: no_anon_function_type_1,
	no_new: no_new_1,
	errors: errors_1,
	parse_options: parse_options_1,
	source: source_1$1,
	should_parse_types: should_parse_types_1,
	error_at: error_at_1,
	error: error_1$1,
	error_unexpected: error_unexpected_1,
	error_on_decorators: error_on_decorators_1,
	strict_error: strict_error_1,
	strict_error_at: strict_error_at_1,
	get_unexpected_error: get_unexpected_error_1,
	comment_list: comment_list_1,
	error_list: error_list_1,
	record_export: record_export_1,
	with_strict: with_strict_1,
	with_in_function: with_in_function_1,
	with_allow_yield: with_allow_yield_1,
	with_allow_await: with_allow_await_1,
	with_allow_directive: with_allow_directive_1,
	with_no_let: with_no_let_1,
	with_in_loop: with_in_loop_1,
	with_no_in: with_no_in_1,
	with_no_anon_function_type: with_no_anon_function_type_1,
	with_no_new: with_no_new_1,
	with_in_switch: with_in_switch_1,
	with_in_export: with_in_export_1,
	with_no_call: with_no_call_1,
	with_error_callback: with_error_callback_1,
	without_error_callback: without_error_callback_1,
	add_label: add_label_1,
	enter_function: enter_function_1,
	is_future_reserved: is_future_reserved_1,
	is_strict_reserved: is_strict_reserved_1,
	is_restricted: is_restricted_1,
	Peek: Peek_1,
	Eat: Eat_1,
	Expect: Expect_1,
	Try: Try_1
};

function JSX(Parse) {
  var spread_attribute = function (env) {
    parser_env_bs.Eat.push_lex_mode(env, /* NORMAL */0);
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_LCURLY */1);
    parser_env_bs.Expect.token(env, /* T_ELLIPSIS */13);
    var argument = curry._1(Parse.assignment, env);
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RCURLY */2);
    parser_env_bs.Eat.pop_lex_mode(env);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              argument: argument
            }
          ];
  };
  var expression_container = function (env) {
    parser_env_bs.Eat.push_lex_mode(env, /* NORMAL */0);
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_LCURLY */1);
    var expression;
    if (parser_env_bs.Peek.token(undefined, env) === /* T_RCURLY */2) {
      var empty_loc = loc_bs.btwn_exclusive(start_loc, parser_env_bs.Peek.loc(undefined, env));
      expression = {
        TAG: /* EmptyExpression */1,
        _0: empty_loc
      };
    } else {
      expression = {
        TAG: /* Expression */0,
        _0: curry._1(Parse.expression, env)
      };
    }
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RCURLY */2);
    parser_env_bs.Eat.pop_lex_mode(env);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              expression: expression
            }
          ];
  };
  var identifier = function (env) {
    var loc = parser_env_bs.Peek.loc(undefined, env);
    var name = parser_env_bs.Peek.value(undefined, env);
    parser_env_bs.Expect.token(env, /* T_JSX_IDENTIFIER */109);
    return [
            loc,
            {
              name: name
            }
          ];
  };
  var member_expression = function (env, _member) {
    while(true) {
      var member = _member;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match !== "number") {
        return member;
      }
      if (match !== 11) {
        return member;
      }
      var _object = {
        TAG: /* MemberExpression */1,
        _0: member
      };
      parser_env_bs.Expect.token(env, /* T_PERIOD */11);
      var property = identifier(env);
      var loc = loc_bs.btwn(member[0], property[0]);
      var member_1 = {
        _object: _object,
        property: property
      };
      var member$1 = [
        loc,
        member_1
      ];
      _member = member$1;
      continue ;
    }  };
  var name = function (env) {
    var name$1 = identifier(env);
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match !== "number") {
      return {
              TAG: /* Identifier */0,
              _0: name$1
            };
    }
    if (match !== 11) {
      if (match !== 80) {
        return {
                TAG: /* Identifier */0,
                _0: name$1
              };
      }
      parser_env_bs.Expect.token(env, /* T_COLON */80);
      var name$2 = identifier(env);
      var loc = loc_bs.btwn(name$1[0], name$2[0]);
      return {
              TAG: /* NamespacedName */1,
              _0: [
                loc,
                {
                  namespace: name$1,
                  name: name$2
                }
              ]
            };
    }
    var _object = {
      TAG: /* Identifier */0,
      _0: name$1
    };
    parser_env_bs.Expect.token(env, /* T_PERIOD */11);
    var property = identifier(env);
    var loc$1 = loc_bs.btwn(name$1[0], property[0]);
    var member_1 = {
      _object: _object,
      property: property
    };
    var member = [
      loc$1,
      member_1
    ];
    return {
            TAG: /* MemberExpression */2,
            _0: member_expression(env, member)
          };
  };
  var attribute = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var name = identifier(env);
    var match;
    if (parser_env_bs.Peek.token(undefined, env) === /* T_COLON */80) {
      parser_env_bs.Expect.token(env, /* T_COLON */80);
      var name$1 = identifier(env);
      var loc = loc_bs.btwn(name[0], name$1[0]);
      match = [
        loc,
        {
          TAG: /* NamespacedName */1,
          _0: [
            loc,
            {
              namespace: name,
              name: name$1
            }
          ]
        }
      ];
    } else {
      match = [
        name[0],
        {
          TAG: /* Identifier */0,
          _0: name
        }
      ];
    }
    var match$1;
    if (parser_env_bs.Peek.token(undefined, env) === /* T_ASSIGN */78) {
      parser_env_bs.Expect.token(env, /* T_ASSIGN */78);
      var token = parser_env_bs.Peek.token(undefined, env);
      var exit = 0;
      if (typeof token === "number") {
        if (token === /* T_LCURLY */1) {
          var match$2 = expression_container(env);
          var expression_container$1 = match$2[1];
          var loc$1 = match$2[0];
          var match$3 = expression_container$1.expression;
          if (match$3.TAG !== /* Expression */0) {
            parser_env_bs.error_at(env, [
                  loc$1,
                  /* JSXAttributeValueEmptyExpression */41
                ]);
          }
          match$1 = [
            loc$1,
            {
              TAG: /* ExpressionContainer */1,
              _0: loc$1,
              _1: expression_container$1
            }
          ];
        } else {
          exit = 1;
        }
      } else if (token.TAG === /* T_JSX_TEXT */4) {
        var match$4 = token._0;
        var loc$2 = match$4[0];
        parser_env_bs.Expect.token(env, token);
        var value = {
          TAG: /* String */0,
          _0: match$4[1]
        };
        match$1 = [
          loc$2,
          {
            TAG: /* Literal */0,
            _0: loc$2,
            _1: {
              value: value,
              raw: match$4[2]
            }
          }
        ];
      } else {
        exit = 1;
      }
      if (exit === 1) {
        parser_env_bs.error(env, /* InvalidJSXAttributeValue */42);
        var loc$3 = parser_env_bs.Peek.loc(undefined, env);
        match$1 = [
          loc$3,
          {
            TAG: /* Literal */0,
            _0: loc$3,
            _1: {
              value: {
                TAG: /* String */0,
                _0: ""
              },
              raw: ""
            }
          }
        ];
      }
      
    } else {
      match$1 = [
        match[0],
        undefined
      ];
    }
    return [
            loc_bs.btwn(start_loc, match$1[0]),
            {
              name: match[1],
              value: match$1[1]
            }
          ];
  };
  var attributes = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        if (match >= 94) {
          if (match === 99) {
            return list.rev(acc);
          }
          if (match === 108) {
            return list.rev(acc);
          }
          
        } else if (match !== 1) {
          if (match >= 93) {
            return list.rev(acc);
          }
          
        } else {
          var attribute$1 = {
            TAG: /* SpreadAttribute */1,
            _0: spread_attribute(env)
          };
          _acc = {
            hd: attribute$1,
            tl: acc
          };
          continue ;
        }
      }
      var attribute$2 = {
        TAG: /* Attribute */0,
        _0: attribute(env)
      };
      _acc = {
        hd: attribute$2,
        tl: acc
      };
      continue ;
    }  };
  var opening_element_without_lt = function (env, start_loc) {
    var name$1 = name(env);
    var attributes$1 = attributes(env, /* [] */0);
    var selfClosing = parser_env_bs.Peek.token(undefined, env) === /* T_DIV */99;
    if (selfClosing) {
      parser_env_bs.Expect.token(env, /* T_DIV */99);
    }
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_GREATER_THAN */93);
    parser_env_bs.Eat.pop_lex_mode(env);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              name: name$1,
              selfClosing: selfClosing,
              attributes: attributes$1
            }
          ];
  };
  var closing_element_without_lt = function (env, start_loc) {
    parser_env_bs.Expect.token(env, /* T_DIV */99);
    var name$1 = name(env);
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_GREATER_THAN */93);
    parser_env_bs.Eat.double_pop_lex_mode(env);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              name: name$1
            }
          ];
  };
  var child = function (env) {
    var token = parser_env_bs.Peek.token(undefined, env);
    if (typeof token === "number") {
      if (token === /* T_LCURLY */1) {
        var expression_container$1 = expression_container(env);
        return [
                expression_container$1[0],
                {
                  TAG: /* ExpressionContainer */1,
                  _0: expression_container$1[1]
                }
              ];
      }
      
    } else if (token.TAG === /* T_JSX_TEXT */4) {
      var match = token._0;
      parser_env_bs.Expect.token(env, token);
      return [
              match[0],
              {
                TAG: /* Text */2,
                _0: {
                  value: match[1],
                  raw: match[2]
                }
              }
            ];
    }
    var element$1 = element(env);
    return [
            element$1[0],
            {
              TAG: /* Element */0,
              _0: element$1[1]
            }
          ];
  };
  var element = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Eat.push_lex_mode(env, /* JSX_TAG */2);
    parser_env_bs.Expect.token(env, /* T_LESS_THAN */92);
    return curry._2(element_without_lt, env, start_loc);
  };
  var element_or_closing = function (env) {
    parser_env_bs.Eat.push_lex_mode(env, /* JSX_TAG */2);
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_LESS_THAN */92);
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match === "number" && !(match !== 99 && match !== 108)) {
      return {
              TAG: /* Closing */0,
              _0: closing_element_without_lt(env, start_loc)
            };
    } else {
      return {
              TAG: /* ChildElement */1,
              _0: curry._2(element_without_lt, env, start_loc)
            };
    }
  };
  var children_and_closing = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        if (match !== 92) {
          if (match !== 108) {
            _acc = {
              hd: child(env),
              tl: acc
            };
            continue ;
          }
          parser_env_bs.error_unexpected(env);
          return [
                  list.rev(acc),
                  undefined
                ];
        }
        var closingElement = element_or_closing(env);
        if (closingElement.TAG === /* Closing */0) {
          return [
                  list.rev(acc),
                  closingElement._0
                ];
        }
        var element = closingElement._0;
        var element_0 = element[0];
        var element_1 = {
          TAG: /* Element */0,
          _0: element[1]
        };
        var element$1 = [
          element_0,
          element_1
        ];
        _acc = {
          hd: element$1,
          tl: acc
        };
        continue ;
      }
      _acc = {
        hd: child(env),
        tl: acc
      };
      continue ;
    }  };
  var normalize = function (name) {
    switch (name.TAG | 0) {
      case /* Identifier */0 :
          return name._0[1].name;
      case /* NamespacedName */1 :
          var match = name._0[1];
          return match.namespace[1].name + (":" + match.name[1].name);
      case /* MemberExpression */2 :
          var match$1 = name._0[1];
          var _object = match$1._object;
          var _object$1;
          _object$1 = _object.TAG === /* Identifier */0 ? _object._0[1].name : normalize({
                  TAG: /* MemberExpression */2,
                  _0: _object._0
                });
          return _object$1 + ("." + match$1.property[1].name);
      
    }
  };
  var element_without_lt = function (env, start_loc) {
    var openingElement = opening_element_without_lt(env, start_loc);
    var match = openingElement[1].selfClosing ? [
        /* [] */0,
        undefined
      ] : (parser_env_bs.Eat.push_lex_mode(env, /* JSX_CHILD */3), children_and_closing(env, /* [] */0));
    var closingElement = match[1];
    var end_loc;
    if (closingElement !== undefined) {
      var opening_name = normalize(openingElement[1].name);
      if (normalize(closingElement[1].name) !== opening_name) {
        parser_env_bs.error(env, {
              TAG: /* ExpectedJSXClosingTag */6,
              _0: opening_name
            });
      }
      end_loc = closingElement[0];
    } else {
      end_loc = openingElement[0];
    }
    return [
            loc_bs.btwn(openingElement[0], end_loc),
            {
              openingElement: openingElement,
              closingElement: closingElement,
              children: match[0]
            }
          ];
  };
  return {
          spread_attribute: spread_attribute,
          expression_container: expression_container,
          identifier: identifier,
          name: name,
          attribute: attribute,
          opening_element_without_lt: opening_element_without_lt,
          closing_element_without_lt: closing_element_without_lt,
          child: child,
          element_without_lt: element_without_lt,
          element: element
        };
}

var Token$1;

var Ast$1;

var $$Error$2;

var Token_1$1 = Token$1;
var Ast_1$1 = Ast$1;
var $$Error_1$2 = $$Error$2;
var JSX_1 = JSX;
/* Loc Not a pure module */

var jsx_parser_bs = {
	Token: Token_1$1,
	Ast: Ast_1$1,
	$$Error: $$Error_1$2,
	JSX: JSX_1
};

function init_mod(loc, shape) {
  var undef_module = function (param) {
    throw {
          RE_EXN_ID: "Undefined_recursive_module",
          _1: loc,
          Error: new Error()
        };
  };
  var loop = function (shape, struct_, idx) {
    if (typeof shape === "number") {
      switch (shape) {
        case /* Function */0 :
            struct_[idx] = undef_module;
            return ;
        case /* Lazy */1 :
            struct_[idx] = {
              LAZY_DONE: true,
              VAL: undef_module
            };
            return ;
        case /* Class */2 :
            struct_[idx] = [
              undef_module,
              undef_module,
              undef_module,
              0
            ];
            return ;
        
      }
    } else {
      if (shape.TAG === /* Module */0) {
        var comps = shape._0;
        var v = {};
        struct_[idx] = v;
        var len = comps.length;
        for(var i = 0; i < len; ++i){
          var match = comps[i];
          loop(match[0], v, match[1]);
        }
        return ;
      }
      struct_[idx] = shape._0;
      return ;
    }
  };
  var res = {};
  var dummy_name = "dummy";
  loop(shape, res, dummy_name);
  return res[dummy_name];
}

function update_mod(shape, o, n) {
  var aux = function (shape, o, n, parent, i) {
    if (typeof shape === "number") {
      switch (shape) {
        case /* Function */0 :
            parent[i] = n;
            return ;
        case /* Lazy */1 :
        case /* Class */2 :
            return caml_obj.update_dummy(o, n);
        
      }
    } else {
      if (shape.TAG !== /* Module */0) {
        return ;
      }
      var comps = shape._0;
      for(var i$1 = 0 ,i_finish = comps.length; i$1 < i_finish; ++i$1){
        var match = comps[i$1];
        var name = match[1];
        aux(match[0], o[name], n[name], o, name);
      }
      return ;
    }
  };
  if (typeof shape === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "caml_module.ml",
            107,
            10
          ],
          Error: new Error()
        };
  }
  if (shape.TAG === /* Module */0) {
    var comps = shape._0;
    for(var i = 0 ,i_finish = comps.length; i < i_finish; ++i){
      var match = comps[i];
      var name = match[1];
      aux(match[0], o[name], n[name], o, name);
    }
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "caml_module.ml",
          107,
          10
        ],
        Error: new Error()
      };
}

var init_mod_1 = init_mod;
var update_mod_1 = update_mod;
/* No side effect */

var caml_module = {
	init_mod: init_mod_1,
	update_mod: update_mod_1
};

function Type(Parse) {
  var union = function (env) {
    parser_env_bs.Expect.maybe(env, /* T_BIT_OR */83);
    var left = intersection(env);
    return curry._2(union_with, env, left);
  };
  var anonymous_function_param = function (_env, typeAnnotation) {
    return [
            typeAnnotation[0],
            {
              name: undefined,
              typeAnnotation: typeAnnotation,
              optional: false
            }
          ];
  };
  var function_param_with_id = function (env, name) {
    if (!parser_env_bs.should_parse_types(env)) {
      parser_env_bs.error(env, /* UnexpectedTypeAnnotation */7);
    }
    var optional = parser_env_bs.Expect.maybe(env, /* T_PLING */79);
    parser_env_bs.Expect.token(env, /* T_COLON */80);
    var typeAnnotation = union(env);
    return [
            loc_bs.btwn(name[0], typeAnnotation[0]),
            {
              name: name,
              typeAnnotation: typeAnnotation,
              optional: optional
            }
          ];
  };
  var primary = function (env) {
    var loc = parser_env_bs.Peek.loc(undefined, env);
    var token = parser_env_bs.Peek.token(undefined, env);
    var exit = 0;
    if (typeof token === "number") {
      switch (token) {
        case /* T_IDENTIFIER */0 :
            var match = generic(env);
            return [
                    match[0],
                    {
                      TAG: /* Generic */4,
                      _0: match[1]
                    }
                  ];
        case /* T_LCURLY */1 :
        case /* T_LCURLYBAR */3 :
            exit = 2;
            break;
        case /* T_LPAREN */5 :
            var start_loc = parser_env_bs.Peek.loc(undefined, env);
            var params = param_list_or_type(env);
            if (params.TAG === /* ParamList */0) {
              return function_with_params(env, start_loc, undefined, params._0);
            } else {
              return params._0;
            }
        case /* T_LBRACKET */7 :
            var start_loc$1 = parser_env_bs.Peek.loc(undefined, env);
            parser_env_bs.Expect.token(env, /* T_LBRACKET */7);
            var tl = types(env, /* [] */0);
            var end_loc = parser_env_bs.Peek.loc(undefined, env);
            parser_env_bs.Expect.token(env, /* T_RBRACKET */8);
            return [
                    loc_bs.btwn(start_loc$1, end_loc),
                    {
                      TAG: /* Tuple */8,
                      _0: tl
                    }
                  ];
        case /* T_FALSE */30 :
        case /* T_TRUE */31 :
            exit = 3;
            break;
        case /* T_TYPEOF */46 :
            var start_loc$2 = parser_env_bs.Peek.loc(undefined, env);
            parser_env_bs.Expect.token(env, /* T_TYPEOF */46);
            var t = primary(env);
            return [
                    loc_bs.btwn(start_loc$2, t[0]),
                    {
                      TAG: /* Typeof */7,
                      _0: t
                    }
                  ];
        case /* T_LESS_THAN */92 :
            var start_loc$3 = parser_env_bs.Peek.loc(undefined, env);
            var typeParameters = curry._2(type_parameter_declaration, false, env);
            var params$1 = function_param_list(env);
            return function_with_params(env, start_loc$3, typeParameters, params$1);
        case /* T_MULT */100 :
            parser_env_bs.Expect.token(env, /* T_MULT */100);
            return [
                    loc,
                    /* Exists */8
                  ];
        default:
          exit = 1;
      }
    } else {
      switch (token.TAG | 0) {
        case /* T_STRING */1 :
            var match$1 = token._0;
            var octal = match$1[3];
            var raw = match$1[2];
            var value = match$1[1];
            var loc$1 = match$1[0];
            if (octal) {
              parser_env_bs.strict_error(env, /* StrictOctalLiteral */32);
            }
            parser_env_bs.Expect.token(env, {
                  TAG: /* T_STRING */1,
                  _0: [
                    loc$1,
                    value,
                    raw,
                    octal
                  ]
                });
            return [
                    loc$1,
                    {
                      TAG: /* StringLiteral */9,
                      _0: {
                        value: value,
                        raw: raw
                      }
                    }
                  ];
        case /* T_NUMBER_SINGLETON_TYPE */5 :
            var value$1 = token._1;
            var number_type = token._0;
            var raw$1 = parser_env_bs.Peek.value(undefined, env);
            parser_env_bs.Expect.token(env, {
                  TAG: /* T_NUMBER_SINGLETON_TYPE */5,
                  _0: number_type,
                  _1: value$1
                });
            if (number_type === /* LEGACY_OCTAL */1) {
              parser_env_bs.strict_error(env, /* StrictOctalLiteral */32);
            }
            return [
                    loc,
                    {
                      TAG: /* NumberLiteral */10,
                      _0: {
                        value: value$1,
                        raw: raw$1
                      }
                    }
                  ];
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          var t$1 = primitive(token);
          if (t$1 !== undefined) {
            parser_env_bs.Expect.token(env, token);
            return [
                    loc,
                    t$1
                  ];
          } else {
            parser_env_bs.error_unexpected(env);
            return [
                    loc,
                    /* Any */0
                  ];
          }
      case 2 :
          var match$2 = curry._4(_object, false, true, true, env);
          return [
                  match$2[0],
                  {
                    TAG: /* Object */2,
                    _0: match$2[1]
                  }
                ];
      case 3 :
          var raw$2 = parser_env_bs.Peek.value(undefined, env);
          parser_env_bs.Expect.token(env, token);
          var value$2 = token === /* T_TRUE */31;
          return [
                  loc,
                  {
                    TAG: /* BooleanLiteral */11,
                    _0: {
                      value: value$2,
                      raw: raw$2
                    }
                  }
                ];
      
    }
  };
  var postfix_with = function (env, _t) {
    while(true) {
      var t = _t;
      if (!(!parser_env_bs.Peek.is_line_terminator(env) && parser_env_bs.Expect.maybe(env, /* T_LBRACKET */7))) {
        return t;
      }
      var end_loc = parser_env_bs.Peek.loc(undefined, env);
      parser_env_bs.Expect.token(env, /* T_RBRACKET */8);
      var loc = loc_bs.btwn(t[0], end_loc);
      var t_1 = {
        TAG: /* Array */3,
        _0: t
      };
      var t$1 = [
        loc,
        t_1
      ];
      _t = t$1;
      continue ;
    }  };
  var function_with_params = function (env, start_loc, typeParameters, params) {
    parser_env_bs.Expect.token(env, /* T_ARROW */12);
    var returnType = union(env);
    var end_loc = returnType[0];
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              TAG: /* Function */1,
              _0: {
                params: params,
                returnType: returnType,
                typeParameters: typeParameters
              }
            }
          ];
  };
  var param_list_or_type = function (env) {
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    var env$1 = parser_env_bs.with_no_anon_function_type(false, env);
    var token = parser_env_bs.Peek.token(undefined, env$1);
    var ret;
    var exit = 0;
    if (typeof token === "number") {
      if (token >= 13) {
        if (token !== 108 && token >= 14) {
          exit = 1;
        } else {
          ret = {
            TAG: /* ParamList */0,
            _0: curry._2(function_param_list_without_parens, env$1, /* [] */0)
          };
        }
      } else if (token !== 6) {
        if (token !== 0) {
          exit = 1;
        } else {
          ret = function_param_or_generic_type(env$1);
        }
      } else {
        ret = {
          TAG: /* ParamList */0,
          _0: [
            /* [] */0,
            undefined
          ]
        };
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match = primitive(token);
      if (match !== undefined) {
        var match$1 = parser_env_bs.Peek.token(1, env$1);
        ret = typeof match$1 === "number" && (match$1 === 80 || match$1 === 79) ? ({
              TAG: /* ParamList */0,
              _0: curry._2(function_param_list_without_parens, env$1, /* [] */0)
            }) : ({
              TAG: /* Type */1,
              _0: union(env$1)
            });
      } else {
        ret = {
          TAG: /* Type */1,
          _0: union(env$1)
        };
      }
    }
    var ret$1;
    if (ret.TAG === /* ParamList */0) {
      ret$1 = ret;
    } else {
      var t = ret._0;
      if (parser_env_bs.no_anon_function_type(env)) {
        ret$1 = ret;
      } else {
        var match$2 = parser_env_bs.Peek.token(undefined, env);
        if (typeof match$2 === "number") {
          if (match$2 !== 6) {
            if (match$2 !== 10) {
              ret$1 = ret;
            } else {
              parser_env_bs.Expect.token(env, /* T_COMMA */10);
              var param = anonymous_function_param(env, t);
              ret$1 = {
                TAG: /* ParamList */0,
                _0: curry._2(function_param_list_without_parens, env, {
                      hd: param,
                      tl: /* [] */0
                    })
              };
            }
          } else if (parser_env_bs.Peek.token(1, env) === /* T_ARROW */12) {
            var param$1 = anonymous_function_param(env, t);
            ret$1 = {
              TAG: /* ParamList */0,
              _0: curry._2(function_param_list_without_parens, env, {
                    hd: param$1,
                    tl: /* [] */0
                  })
            };
          } else {
            ret$1 = {
              TAG: /* Type */1,
              _0: t
            };
          }
        } else {
          ret$1 = ret;
        }
      }
    }
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    return ret$1;
  };
  var generic_type_with_identifier = function (env, id) {
    var match = curry._2(raw_generic_with_identifier, env, id);
    return [
            match[0],
            {
              TAG: /* Generic */4,
              _0: match[1]
            }
          ];
  };
  var anon_function_without_parens_with = function (env, param) {
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match !== "number") {
      return param;
    }
    if (match !== 12) {
      return param;
    }
    if (parser_env_bs.no_anon_function_type(env)) {
      return param;
    }
    var param$1 = anonymous_function_param(env, param);
    var start_loc = param$1[0];
    var params_0 = {
      hd: param$1,
      tl: /* [] */0
    };
    var params = [
      params_0,
      undefined
    ];
    return function_with_params(env, start_loc, undefined, params);
  };
  var postfix = function (env) {
    var t = primary(env);
    return postfix_with(env, t);
  };
  var prefix = function (env) {
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match !== "number") {
      return postfix(env);
    }
    if (match !== 79) {
      return postfix(env);
    }
    var loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_PLING */79);
    var t = prefix(env);
    return [
            loc_bs.btwn(loc, t[0]),
            {
              TAG: /* Nullable */0,
              _0: t
            }
          ];
  };
  var variance = function (env) {
    var loc = parser_env_bs.Peek.loc(undefined, env);
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match === "number") {
      if (match !== 97) {
        if (match !== 98) {
          return ;
        } else {
          parser_env_bs.Eat.token(env);
          return [
                  loc,
                  /* Minus */1
                ];
        }
      } else {
        parser_env_bs.Eat.token(env);
        return [
                loc,
                /* Plus */0
              ];
      }
    }
    
  };
  var function_param_list = function (env) {
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    var ret = curry._2(function_param_list_without_parens, env, /* [] */0);
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    return ret;
  };
  var anon_function_without_parens = function (env) {
    var param = prefix(env);
    return anon_function_without_parens_with(env, param);
  };
  var generic = function (env) {
    return curry._2(raw_generic_with_identifier, env, curry._2(Parse.identifier, undefined, env));
  };
  var primitive = function (param) {
    if (typeof param !== "number") {
      return ;
    }
    if (param === 29) {
      return /* Null */4;
    }
    if (param < 110) {
      return ;
    }
    switch (param - 110 | 0) {
      case /* T_IDENTIFIER */0 :
          return /* Any */0;
      case /* T_LCURLY */1 :
          return /* Mixed */1;
      case /* T_RCURLY */2 :
          return /* Empty */2;
      case /* T_LCURLYBAR */3 :
          return /* Boolean */7;
      case /* T_RCURLYBAR */4 :
          return /* Number */5;
      case /* T_LPAREN */5 :
          return /* String */6;
      case /* T_RPAREN */6 :
          return /* Void */3;
      
    }
  };
  var rev_nonempty_acc = function (acc) {
    var end_loc;
    if (acc) {
      end_loc = acc.hd[0];
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "type_parser.ml",
              65,
              11
            ],
            Error: new Error()
          };
    }
    var acc$1 = list.rev(acc);
    var start_loc;
    if (acc$1) {
      start_loc = acc$1.hd[0];
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "type_parser.ml",
              69,
              11
            ],
            Error: new Error()
          };
    }
    return [
            loc_bs.btwn(start_loc, end_loc),
            acc$1
          ];
  };
  var intersection = function (env) {
    parser_env_bs.Expect.maybe(env, /* T_BIT_AND */85);
    var left = anon_function_without_parens(env);
    return curry._2(intersection_with, env, left);
  };
  var function_param_or_generic_type = function (env) {
    var id = curry._2(Parse.identifier, undefined, env);
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match === "number" && (match === 80 || match === 79)) {
      var param = function_param_with_id(env, id);
      parser_env_bs.Expect.maybe(env, /* T_COMMA */10);
      return {
              TAG: /* ParamList */0,
              _0: curry._2(function_param_list_without_parens, env, {
                    hd: param,
                    tl: /* [] */0
                  })
            };
    }
    return {
            TAG: /* Type */1,
            _0: curry._2(union_with, env, curry._2(intersection_with, env, anon_function_without_parens_with(env, postfix_with(env, generic_type_with_identifier(env, id)))))
          };
  };
  var identifier = function (env, _param) {
    while(true) {
      var param = _param;
      var qualification = param[1];
      var q_loc = param[0];
      if (parser_env_bs.Peek.token(undefined, env) !== /* T_PERIOD */11) {
        return [
                q_loc,
                qualification
              ];
      }
      parser_env_bs.Expect.token(env, /* T_PERIOD */11);
      var id = curry._2(Parse.identifier, undefined, env);
      var loc = loc_bs.btwn(q_loc, id[0]);
      var qualification$1 = {
        TAG: /* Qualified */1,
        _0: [
          loc,
          {
            qualification: qualification,
            id: id
          }
        ]
      };
      _param = [
        loc,
        qualification$1
      ];
      continue ;
    }  };
  var raw_generic_with_identifier = function (env, id) {
    var id_0 = id[0];
    var id_1 = {
      TAG: /* Unqualified */0,
      _0: id
    };
    var id$1 = [
      id_0,
      id_1
    ];
    var match = identifier(env, id$1);
    var id_loc = match[0];
    var typeParameters = curry._1(type_parameter_instantiation, env);
    var loc = typeParameters !== undefined ? loc_bs.btwn(id_loc, typeParameters[0]) : id_loc;
    return [
            loc,
            {
              id: match[1],
              typeParameters: typeParameters
            }
          ];
  };
  var union_with = function (env, left) {
    if (parser_env_bs.Peek.token(undefined, env) === /* T_BIT_OR */83) {
      var _acc = {
        hd: left,
        tl: /* [] */0
      };
      while(true) {
        var acc = _acc;
        var match = parser_env_bs.Peek.token(undefined, env);
        if (typeof match === "number" && match === 83) {
          parser_env_bs.Expect.token(env, /* T_BIT_OR */83);
          _acc = {
            hd: intersection(env),
            tl: acc
          };
          continue ;
        }
        var match$1 = rev_nonempty_acc(acc);
        var acc$1 = match$1[1];
        if (acc$1) {
          var match$2 = acc$1.tl;
          if (match$2) {
            return [
                    match$1[0],
                    {
                      TAG: /* Union */5,
                      _0: acc$1.hd,
                      _1: match$2.hd,
                      _2: match$2.tl
                    }
                  ];
          }
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "type_parser.ml",
                  87,
                  17
                ],
                Error: new Error()
              };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "type_parser.ml",
                87,
                17
              ],
              Error: new Error()
            };
      }    } else {
      return left;
    }
  };
  var intersection_with = function (env, left) {
    if (parser_env_bs.Peek.token(undefined, env) === /* T_BIT_AND */85) {
      var _acc = {
        hd: left,
        tl: /* [] */0
      };
      while(true) {
        var acc = _acc;
        var match = parser_env_bs.Peek.token(undefined, env);
        if (typeof match === "number" && match === 85) {
          parser_env_bs.Expect.token(env, /* T_BIT_AND */85);
          _acc = {
            hd: anon_function_without_parens(env),
            tl: acc
          };
          continue ;
        }
        var match$1 = rev_nonempty_acc(acc);
        var acc$1 = match$1[1];
        if (acc$1) {
          var match$2 = acc$1.tl;
          if (match$2) {
            return [
                    match$1[0],
                    {
                      TAG: /* Intersection */6,
                      _0: acc$1.hd,
                      _1: match$2.hd,
                      _2: match$2.tl
                    }
                  ];
          }
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "type_parser.ml",
                  108,
                  17
                ],
                Error: new Error()
              };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "type_parser.ml",
                108,
                17
              ],
              Error: new Error()
            };
      }    } else {
      return left;
    }
  };
  var param = function (env) {
    var match = parser_env_bs.Peek.token(1, env);
    if (typeof match === "number" && (match === 80 || match === 79)) {
      var match$1 = curry._1(Parse.identifier_or_reserved_keyword, env);
      return function_param_with_id(env, match$1[0]);
    }
    var typeAnnotation = union(env);
    return anonymous_function_param(env, typeAnnotation);
  };
  var function_param_list_without_parens = function (env) {
    return function (param$1) {
      var _acc = param$1;
      while(true) {
        var acc = _acc;
        var t = parser_env_bs.Peek.token(undefined, env);
        var exit = 0;
        if (typeof t === "number") {
          var switcher = t - 6 | 0;
          exit = switcher > 7 || switcher < 0 ? (
              switcher !== 102 ? 1 : 2
            ) : (
              switcher > 6 || switcher < 1 ? 2 : 1
            );
        } else {
          exit = 1;
        }
        switch (exit) {
          case 1 :
              var acc_0 = param(env);
              var acc$1 = {
                hd: acc_0,
                tl: acc
              };
              if (parser_env_bs.Peek.token(undefined, env) !== /* T_RPAREN */6) {
                parser_env_bs.Expect.token(env, /* T_COMMA */10);
              }
              _acc = acc$1;
              continue ;
          case 2 :
              var rest;
              if (t === /* T_ELLIPSIS */13) {
                var start_loc = parser_env_bs.Peek.loc(undefined, env);
                parser_env_bs.Expect.token(env, /* T_ELLIPSIS */13);
                var argument = param(env);
                var loc = loc_bs.btwn(start_loc, argument[0]);
                rest = [
                  loc,
                  {
                    argument: argument
                  }
                ];
              } else {
                rest = undefined;
              }
              return [
                      list.rev(acc),
                      rest
                    ];
          
        }
      }    };
  };
  var params = function (env, allow_default, _require_default, _acc) {
    while(true) {
      var acc = _acc;
      var require_default = _require_default;
      var variance$1 = variance(env);
      var match = curry._3(Parse.identifier_with_type, env, undefined, /* StrictParamName */29);
      var match$1 = match[1];
      var loc = match[0];
      var match$2 = parser_env_bs.Peek.token(undefined, env);
      var match$3;
      if (allow_default) {
        var exit = 0;
        if (typeof match$2 === "number" && match$2 === 78) {
          parser_env_bs.Eat.token(env);
          match$3 = [
            union(env),
            true
          ];
        } else {
          exit = 1;
        }
        if (exit === 1) {
          if (require_default) {
            parser_env_bs.error_at(env, [
                  loc,
                  /* MissingTypeParamDefault */58
                ]);
          }
          match$3 = [
            undefined,
            require_default
          ];
        }
        
      } else {
        match$3 = [
          undefined,
          false
        ];
      }
      var param_1 = {
        name: match$1.name[1],
        bound: match$1.typeAnnotation,
        variance: variance$1,
        default: match$3[0]
      };
      var param = [
        loc,
        param_1
      ];
      var acc$1 = {
        hd: param,
        tl: acc
      };
      var match$4 = parser_env_bs.Peek.token(undefined, env);
      if (typeof match$4 === "number") {
        if (match$4 === 93) {
          return list.rev(acc$1);
        }
        if (match$4 === 108) {
          return list.rev(acc$1);
        }
        
      }
      parser_env_bs.Expect.token(env, /* T_COMMA */10);
      if (parser_env_bs.Peek.token(undefined, env) === /* T_GREATER_THAN */93) {
        return list.rev(acc$1);
      }
      _acc = acc$1;
      _require_default = match$3[1];
      continue ;
    }  };
  var type_parameter_declaration = function (allow_default, env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    if (parser_env_bs.Peek.token(undefined, env) !== /* T_LESS_THAN */92) {
      return ;
    }
    if (!parser_env_bs.should_parse_types(env)) {
      parser_env_bs.error(env, /* UnexpectedTypeAnnotation */7);
    }
    parser_env_bs.Expect.token(env, /* T_LESS_THAN */92);
    var params$1 = params(env, allow_default, false, /* [] */0);
    var loc = loc_bs.btwn(start_loc, parser_env_bs.Peek.loc(undefined, env));
    parser_env_bs.Expect.token(env, /* T_GREATER_THAN */93);
    return [
            loc,
            {
              params: params$1
            }
          ];
  };
  var methodish = function (env, start_loc, type_params) {
    var params = function_param_list(env);
    parser_env_bs.Expect.token(env, /* T_COLON */80);
    var returnType = union(env);
    var loc = loc_bs.btwn(start_loc, returnType[0]);
    return [
            loc,
            {
              params: params,
              returnType: returnType,
              typeParameters: type_params
            }
          ];
  };
  var method_property = function (env, start_loc, $$static, key) {
    var type_params = curry._2(type_parameter_declaration, false, env);
    var value = methodish(env, start_loc, type_params);
    var value_0 = value[0];
    var value_1 = {
      TAG: /* Function */1,
      _0: value[1]
    };
    var value$1 = [
      value_0,
      value_1
    ];
    return {
            TAG: /* Property */0,
            _0: [
              value_0,
              {
                key: key,
                value: {
                  TAG: /* Init */0,
                  _0: value$1
                },
                optional: false,
                static: $$static,
                _method: true,
                variance: undefined
              }
            ]
          };
  };
  var call_property = function (env, start_loc, $$static) {
    var type_params = curry._2(type_parameter_declaration, false, env);
    var value = methodish(env, parser_env_bs.Peek.loc(undefined, env), type_params);
    return {
            TAG: /* CallProperty */3,
            _0: [
              loc_bs.btwn(start_loc, value[0]),
              {
                value: value,
                static: $$static
              }
            ]
          };
  };
  var property = function (env, start_loc, $$static, variance, key) {
    if (!parser_env_bs.should_parse_types(env)) {
      parser_env_bs.error(env, /* UnexpectedTypeAnnotation */7);
    }
    var optional = parser_env_bs.Expect.maybe(env, /* T_PLING */79);
    parser_env_bs.Expect.token(env, /* T_COLON */80);
    var value = union(env);
    return {
            TAG: /* Property */0,
            _0: [
              loc_bs.btwn(start_loc, value[0]),
              {
                key: key,
                value: {
                  TAG: /* Init */0,
                  _0: value
                },
                optional: optional,
                static: $$static,
                _method: false,
                variance: variance
              }
            ]
          };
  };
  var getter_or_setter = function (is_getter, env, start_loc, $$static, key) {
    var value = methodish(env, start_loc, undefined);
    var params = value[1].params;
    var key_loc = key[0];
    if (is_getter) {
      if (params[0] || params[1] !== undefined) {
        parser_env_bs.error_at(env, [
              key_loc,
              /* GetterArity */62
            ]);
      }
      
    } else {
      var match = params[0];
      if (params[1] !== undefined || !(match && !match.tl)) {
        parser_env_bs.error_at(env, [
              key_loc,
              /* SetterArity */63
            ]);
      }
      
    }
    return {
            TAG: /* Property */0,
            _0: [
              loc_bs.btwn(start_loc, value[0]),
              {
                key: key[1],
                value: is_getter ? ({
                      TAG: /* Get */1,
                      _0: value
                    }) : ({
                      TAG: /* Set */2,
                      _0: value
                    }),
                optional: false,
                static: $$static,
                _method: false,
                variance: undefined
              }
            ]
          };
  };
  var indexer_property = function (env, start_loc, $$static, variance) {
    parser_env_bs.Expect.token(env, /* T_LBRACKET */7);
    var id;
    if (parser_env_bs.Peek.token(1, env) === /* T_COLON */80) {
      var match = curry._1(Parse.identifier_or_reserved_keyword, env);
      parser_env_bs.Expect.token(env, /* T_COLON */80);
      id = match[0];
    } else {
      id = undefined;
    }
    var key = union(env);
    parser_env_bs.Expect.token(env, /* T_RBRACKET */8);
    parser_env_bs.Expect.token(env, /* T_COLON */80);
    var value = union(env);
    return {
            TAG: /* Indexer */2,
            _0: [
              loc_bs.btwn(start_loc, value[0]),
              {
                id: id,
                key: key,
                value: value,
                static: $$static,
                variance: variance
              }
            ]
          };
  };
  var semicolon = function (exact, env) {
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match !== "number") {
      return parser_env_bs.error_unexpected(env);
    }
    if (match >= 11) {
      return parser_env_bs.error_unexpected(env);
    }
    switch (match) {
      case /* T_RCURLY */2 :
          if (exact) {
            return parser_env_bs.error_unexpected(env);
          } else {
            return ;
          }
      case /* T_RCURLYBAR */4 :
          if (exact) {
            return ;
          } else {
            return parser_env_bs.error_unexpected(env);
          }
      case /* T_IDENTIFIER */0 :
      case /* T_LCURLY */1 :
      case /* T_LCURLYBAR */3 :
      case /* T_LPAREN */5 :
      case /* T_RPAREN */6 :
      case /* T_LBRACKET */7 :
      case /* T_RBRACKET */8 :
          return parser_env_bs.error_unexpected(env);
      case /* T_SEMICOLON */9 :
      case /* T_COMMA */10 :
          return parser_env_bs.Eat.token(env);
      
    }
  };
  var error_unsupported_variance = function (env, param) {
    if (param !== undefined) {
      return parser_env_bs.error_at(env, [
                  param[0],
                  /* UnexpectedVariance */5
                ]);
    }
    
  };
  var properties = function (allow_static, allow_spread, exact, env, _acc) {
    while(true) {
      var acc = _acc;
      if (allow_static && allow_spread) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "type_parser.ml",
                496,
                6
              ],
              Error: new Error()
            };
      }
      var start_loc = parser_env_bs.Peek.loc(undefined, env);
      var $$static = allow_static && parser_env_bs.Expect.maybe(env, /* T_STATIC */42);
      var variance$1 = variance(env);
      var token = parser_env_bs.Peek.token(undefined, env);
      var exit = 0;
      if (typeof token === "number") {
        if (token !== 92) {
          if (token === 108) {
            return list.rev(acc);
          }
          if (token >= 14) {
            exit = 1;
          } else {
            switch (token) {
              case /* T_RCURLY */2 :
                  if (!exact) {
                    return list.rev(acc);
                  }
                  exit = 1;
                  break;
              case /* T_RCURLYBAR */4 :
                  if (exact) {
                    return list.rev(acc);
                  }
                  exit = 1;
                  break;
              case /* T_LPAREN */5 :
                  exit = 2;
                  break;
              case /* T_LBRACKET */7 :
                  var indexer = indexer_property(env, start_loc, $$static, variance$1);
                  semicolon(exact, env);
                  _acc = {
                    hd: indexer,
                    tl: acc
                  };
                  continue ;
              case /* T_IDENTIFIER */0 :
              case /* T_LCURLY */1 :
              case /* T_LCURLYBAR */3 :
              case /* T_RPAREN */6 :
              case /* T_RBRACKET */8 :
              case /* T_SEMICOLON */9 :
              case /* T_COMMA */10 :
              case /* T_PERIOD */11 :
              case /* T_ARROW */12 :
                  exit = 1;
                  break;
              case /* T_ELLIPSIS */13 :
                  if (allow_spread) {
                    parser_env_bs.Eat.token(env);
                    var argument = union(env);
                    var loc = loc_bs.btwn(start_loc, argument[0]);
                    var property$1 = {
                      TAG: /* SpreadProperty */1,
                      _0: [
                        loc,
                        {
                          argument: argument
                        }
                      ]
                    };
                    semicolon(exact, env);
                    _acc = {
                      hd: property$1,
                      tl: acc
                    };
                    continue ;
                  }
                  exit = 1;
                  break;
              
            }
          }
        } else {
          exit = 2;
        }
      } else {
        exit = 1;
      }
      switch (exit) {
        case 1 :
            var property$2;
            var exit$1 = 0;
            if ($$static && !(variance$1 !== undefined || !(typeof token === "number" && token === 80))) {
              parser_env_bs.strict_error_at(env, [
                    start_loc,
                    /* StrictReservedWord */40
                  ]);
              var key = {
                TAG: /* Identifier */1,
                _0: [
                  start_loc,
                  "static"
                ]
              };
              var match = parser_env_bs.Peek.token(undefined, env);
              var exit$2 = 0;
              if (typeof match === "number" && !(match !== 5 && match !== 92)) {
                exit$2 = 4;
              } else {
                property$2 = property(env, start_loc, false, variance$1, key);
              }
              if (exit$2 === 4) {
                error_unsupported_variance(env, variance$1);
                property$2 = method_property(env, start_loc, false, key);
              }
              
            } else {
              exit$1 = 3;
            }
            if (exit$1 === 3) {
              var object_key = function (env) {
                parser_env_bs.Eat.push_lex_mode(env, /* NORMAL */0);
                var result = curry._1(Parse.object_key, env);
                parser_env_bs.Eat.pop_lex_mode(env);
                return result;
              };
              var match$1 = object_key(env);
              var key$1 = match$1[1];
              var exit$3 = 0;
              switch (key$1.TAG | 0) {
                case /* Identifier */1 :
                    var name = key$1._0[1];
                    var exit$4 = 0;
                    switch (name) {
                      case "get" :
                      case "set" :
                          exit$4 = 5;
                          break;
                      default:
                        exit$3 = 4;
                    }
                    if (exit$4 === 5) {
                      var match$2 = parser_env_bs.Peek.token(undefined, env);
                      var exit$5 = 0;
                      if (typeof match$2 === "number") {
                        var switcher = match$2 - 6 | 0;
                        if (switcher > 85 || switcher < 0) {
                          if ((switcher + 1 >>> 0) > 87) {
                            exit$5 = 6;
                          } else {
                            error_unsupported_variance(env, variance$1);
                            property$2 = method_property(env, start_loc, $$static, key$1);
                          }
                        } else if (switcher === 74 || switcher === 73) {
                          property$2 = property(env, start_loc, $$static, variance$1, key$1);
                        } else {
                          exit$5 = 6;
                        }
                      } else {
                        exit$5 = 6;
                      }
                      if (exit$5 === 6) {
                        var key$2 = object_key(env);
                        var is_getter = name === "get";
                        error_unsupported_variance(env, variance$1);
                        property$2 = getter_or_setter(is_getter, env, start_loc, $$static, key$2);
                      }
                      
                    }
                    break;
                case /* Literal */0 :
                case /* Computed */2 :
                    exit$3 = 4;
                    break;
                
              }
              if (exit$3 === 4) {
                var match$3 = parser_env_bs.Peek.token(undefined, env);
                var exit$6 = 0;
                if (typeof match$3 === "number" && !(match$3 !== 5 && match$3 !== 92)) {
                  exit$6 = 5;
                } else {
                  property$2 = property(env, start_loc, $$static, variance$1, key$1);
                }
                if (exit$6 === 5) {
                  error_unsupported_variance(env, variance$1);
                  property$2 = method_property(env, start_loc, $$static, key$1);
                }
                
              }
              
            }
            semicolon(exact, env);
            _acc = {
              hd: property$2,
              tl: acc
            };
            continue ;
        case 2 :
            error_unsupported_variance(env, variance$1);
            var call_prop = call_property(env, start_loc, $$static);
            semicolon(exact, env);
            _acc = {
              hd: call_prop,
              tl: acc
            };
            continue ;
        
      }
    }  };
  var _object = function (allow_static, allow_exact, allow_spread, env) {
    var exact = allow_exact && parser_env_bs.Peek.token(undefined, env) === /* T_LCURLYBAR */3;
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, exact ? /* T_LCURLYBAR */3 : /* T_LCURLY */1);
    var properties$1 = properties(allow_static, allow_spread, exact, env, /* [] */0);
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, exact ? /* T_RCURLYBAR */4 : /* T_RCURLY */2);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              exact: exact,
              properties: properties$1
            }
          ];
  };
  var types = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        if (match === 8) {
          return list.rev(acc);
        }
        if (match === 108) {
          return list.rev(acc);
        }
        
      }
      var acc_0 = union(env);
      var acc$1 = {
        hd: acc_0,
        tl: acc
      };
      if (parser_env_bs.Peek.token(undefined, env) !== /* T_RBRACKET */8) {
        parser_env_bs.Expect.token(env, /* T_COMMA */10);
      }
      _acc = acc$1;
      continue ;
    }  };
  var params$1 = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        if (match === 93) {
          return list.rev(acc);
        }
        if (match === 108) {
          return list.rev(acc);
        }
        
      }
      var acc_0 = union(env);
      var acc$1 = {
        hd: acc_0,
        tl: acc
      };
      if (parser_env_bs.Peek.token(undefined, env) !== /* T_GREATER_THAN */93) {
        parser_env_bs.Expect.token(env, /* T_COMMA */10);
      }
      _acc = acc$1;
      continue ;
    }  };
  var type_parameter_instantiation = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    if (parser_env_bs.Peek.token(undefined, env) !== /* T_LESS_THAN */92) {
      return ;
    }
    parser_env_bs.Expect.token(env, /* T_LESS_THAN */92);
    var params$2 = params$1(env, /* [] */0);
    var loc = loc_bs.btwn(start_loc, parser_env_bs.Peek.loc(undefined, env));
    parser_env_bs.Expect.token(env, /* T_GREATER_THAN */93);
    return [
            loc,
            {
              params: params$2
            }
          ];
  };
  var _type = union;
  var annotation = function (env) {
    if (!parser_env_bs.should_parse_types(env)) {
      parser_env_bs.error(env, /* UnexpectedTypeAnnotation */7);
    }
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_COLON */80);
    var typeAnnotation = union(env);
    var loc = parser_env_bs.last_loc(env);
    var end_loc;
    if (loc !== undefined) {
      end_loc = loc;
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "type_parser.ml",
              47,
              14
            ],
            Error: new Error()
          };
    }
    return [
            loc_bs.btwn(start_loc, end_loc),
            typeAnnotation
          ];
  };
  var annotation_opt = function (env) {
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match === "number" && match === 80) {
      return annotation(env);
    }
    
  };
  var predicate = function (env) {
    var checks_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_CHECKS */65);
    if (parser_env_bs.Peek.token(undefined, env) !== /* T_LPAREN */5) {
      return [
              checks_loc,
              /* Inferred */0
            ];
    }
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    parser_env_bs.Eat.push_lex_mode(env, /* NORMAL */0);
    var exp = curry._1(Parse.conditional, env);
    parser_env_bs.Eat.pop_lex_mode(env);
    var rparen_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    var loc = loc_bs.btwn(checks_loc, rparen_loc);
    return [
            loc,
            /* Declared */{
              _0: exp
            }
          ];
  };
  var predicate_opt = function (env) {
    var env$1 = parser_env_bs.with_no_anon_function_type(false, env);
    var match = parser_env_bs.Peek.token(undefined, env$1);
    if (typeof match === "number" && match === 65) {
      return predicate(env$1);
    }
    
  };
  var annotation_and_predicate_opt = function (env) {
    var match = parser_env_bs.Peek.token(undefined, env);
    var match$1 = parser_env_bs.Peek.token(1, env);
    if (typeof match !== "number") {
      return [
              undefined,
              undefined
            ];
    }
    if (match !== 80) {
      return [
              undefined,
              undefined
            ];
    }
    if (typeof match$1 === "number" && match$1 === 65) {
      parser_env_bs.Expect.token(env, /* T_COLON */80);
      return [
              undefined,
              predicate_opt(env)
            ];
    }
    var annotation = annotation_opt(env);
    var predicate = predicate_opt(env);
    return [
            annotation,
            predicate
          ];
  };
  var wrap = function (f, env) {
    var env$1 = parser_env_bs.with_strict(true, env);
    parser_env_bs.Eat.push_lex_mode(env$1, /* TYPE */1);
    var ret = curry._1(f, env$1);
    parser_env_bs.Eat.pop_lex_mode(env$1);
    return ret;
  };
  var _type$1 = function (param) {
    return wrap(_type, param);
  };
  var partial_arg = curry._1(type_parameter_declaration, true);
  var type_parameter_declaration_with_defaults = function (param) {
    return wrap(partial_arg, param);
  };
  var partial_arg$1 = curry._1(type_parameter_declaration, false);
  var type_parameter_declaration$1 = function (param) {
    return wrap(partial_arg$1, param);
  };
  var type_parameter_instantiation$1 = function (param) {
    return wrap(type_parameter_instantiation, param);
  };
  var _object$1 = function (allow_static, env) {
    return wrap(curry._3(_object, allow_static, false, false), env);
  };
  var function_param_list$1 = function (param) {
    return wrap(function_param_list, param);
  };
  var annotation$1 = function (param) {
    return wrap(annotation, param);
  };
  var annotation_opt$1 = function (param) {
    return wrap(annotation_opt, param);
  };
  var predicate_opt$1 = function (param) {
    return wrap(predicate_opt, param);
  };
  var annotation_and_predicate_opt$1 = function (param) {
    return wrap(annotation_and_predicate_opt, param);
  };
  var generic$1 = function (param) {
    return wrap(generic, param);
  };
  return {
          _type: _type$1,
          type_parameter_declaration: type_parameter_declaration$1,
          type_parameter_declaration_with_defaults: type_parameter_declaration_with_defaults,
          type_parameter_instantiation: type_parameter_instantiation$1,
          generic: generic$1,
          _object: _object$1,
          function_param_list: function_param_list$1,
          annotation: annotation$1,
          annotation_opt: annotation_opt$1,
          predicate_opt: predicate_opt$1,
          annotation_and_predicate_opt: annotation_and_predicate_opt$1
        };
}

var Token$2;

var Ast$2;

var $$Error$3;

var Token_1$2 = Token$2;
var Ast_1$2 = Ast$2;
var $$Error_1$3 = $$Error$3;
var Type_1 = Type;
/* Loc Not a pure module */

var type_parser_bs = {
	Token: Token_1$2,
	Ast: Ast_1$2,
	$$Error: $$Error_1$3,
	Type: Type_1
};

function $$Object(Parse, Type, Declaration, Expression) {
  var decorator_list_helper = function (env, _decorators) {
    while(true) {
      var decorators = _decorators;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match !== "number") {
        return decorators;
      }
      if (match !== 14) {
        return decorators;
      }
      parser_env_bs.Eat.token(env);
      _decorators = {
        hd: curry._1(Expression.left_hand_side, env),
        tl: decorators
      };
      continue ;
    }  };
  var decorator_list = function (env) {
    if (parser_env_bs.parse_options(env).esproposal_decorators) {
      return list.rev(decorator_list_helper(env, /* [] */0));
    } else {
      return /* [] */0;
    }
  };
  var key = function (env) {
    var number_type = parser_env_bs.Peek.token(undefined, env);
    if (typeof number_type === "number") {
      if (number_type === /* T_LBRACKET */7) {
        var start_loc = parser_env_bs.Peek.loc(undefined, env);
        parser_env_bs.Expect.token(env, /* T_LBRACKET */7);
        var expr = curry._1(Parse.assignment, parser_env_bs.with_no_in(false, env));
        var end_loc = parser_env_bs.Peek.loc(undefined, env);
        parser_env_bs.Expect.token(env, /* T_RBRACKET */8);
        return [
                loc_bs.btwn(start_loc, end_loc),
                {
                  TAG: /* Computed */2,
                  _0: expr
                }
              ];
      }
      
    } else {
      switch (number_type.TAG | 0) {
        case /* T_NUMBER */0 :
            var raw = parser_env_bs.Peek.value(undefined, env);
            var loc = parser_env_bs.Peek.loc(undefined, env);
            var value = curry._2(Expression.number, env, number_type._0);
            var value$1 = {
              TAG: /* Number */2,
              _0: value
            };
            return [
                    loc,
                    {
                      TAG: /* Literal */0,
                      _0: [
                        loc,
                        {
                          value: value$1,
                          raw: raw
                        }
                      ]
                    }
                  ];
        case /* T_STRING */1 :
            var match = number_type._0;
            var octal = match[3];
            var raw$1 = match[2];
            var value$2 = match[1];
            var loc$1 = match[0];
            if (octal) {
              parser_env_bs.strict_error(env, /* StrictOctalLiteral */32);
            }
            parser_env_bs.Expect.token(env, {
                  TAG: /* T_STRING */1,
                  _0: [
                    loc$1,
                    value$2,
                    raw$1,
                    octal
                  ]
                });
            var value$3 = {
              TAG: /* String */0,
              _0: value$2
            };
            return [
                    loc$1,
                    {
                      TAG: /* Literal */0,
                      _0: [
                        loc$1,
                        {
                          value: value$3,
                          raw: raw$1
                        }
                      ]
                    }
                  ];
          
      }
    }
    var match$1 = curry._1(Expression.identifier_or_reserved_keyword, env);
    var id = match$1[0];
    return [
            id[0],
            {
              TAG: /* Identifier */1,
              _0: id
            }
          ];
  };
  var getter_or_setter = function (env, is_getter) {
    var generator = curry._1(Declaration.generator, env);
    var match = key(env);
    var key_loc = match[0];
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var params = curry._1(Declaration.function_params, env);
    if (is_getter) {
      if (params[0] || params[1] !== undefined) {
        parser_env_bs.error_at(env, [
              key_loc,
              /* GetterArity */62
            ]);
      }
      
    } else {
      var match$1 = params[0];
      if (params[1] !== undefined || !(match$1 && !match$1.tl)) {
        parser_env_bs.error_at(env, [
              key_loc,
              /* SetterArity */63
            ]);
      }
      
    }
    var returnType = curry._1(Type.annotation_opt, env);
    var match$2 = curry._3(Declaration.function_body, env, false, generator);
    var body = match$2[1];
    var simple = curry._1(Declaration.is_simple_function_params, params);
    curry._5(Declaration.strict_post_check, env, match$2[2], simple, undefined, params);
    var match$3;
    match$3 = body.TAG === /* BodyBlock */0 ? [
        body._0[0],
        false
      ] : [
        body._0[0],
        true
      ];
    var loc = loc_bs.btwn(start_loc, match$3[0]);
    var value_1 = {
      id: undefined,
      params: params,
      body: body,
      async: false,
      generator: generator,
      predicate: undefined,
      expression: match$3[1],
      returnType: returnType,
      typeParameters: undefined
    };
    var value = [
      loc,
      value_1
    ];
    return [
            match[1],
            value
          ];
  };
  var property = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    if (parser_env_bs.Peek.token(undefined, env) === /* T_ELLIPSIS */13) {
      parser_env_bs.Expect.token(env, /* T_ELLIPSIS */13);
      var argument = curry._1(Parse.assignment, env);
      return {
              TAG: /* SpreadProperty */1,
              _0: [
                loc_bs.btwn(start_loc, argument[0]),
                {
                  argument: argument
                }
              ]
            };
    }
    var async = parser_env_bs.Peek.is_literal_property_name(1, env) && curry._1(Declaration.async, env);
    var match = curry._1(Declaration.generator, env);
    var match$1 = key(env);
    var tmp;
    var exit = 0;
    if (async || match) {
      exit = 1;
    } else {
      var key$1 = match$1[1];
      switch (key$1.TAG | 0) {
        case /* Identifier */1 :
            switch (key$1._0[1]) {
              case "get" :
                  var match$2 = parser_env_bs.Peek.token(undefined, env);
                  var exit$1 = 0;
                  if (typeof match$2 === "number") {
                    var switcher = match$2 - 80 | 0;
                    if (switcher > 12 || switcher < 0) {
                      if (switcher >= -69) {
                        tmp = get(env, start_loc);
                      } else {
                        switch (switcher + 80 | 0) {
                          case /* T_IDENTIFIER */0 :
                          case /* T_LCURLY */1 :
                          case /* T_LCURLYBAR */3 :
                          case /* T_RCURLYBAR */4 :
                          case /* T_RPAREN */6 :
                          case /* T_LBRACKET */7 :
                          case /* T_RBRACKET */8 :
                          case /* T_SEMICOLON */9 :
                              tmp = get(env, start_loc);
                              break;
                          case /* T_RCURLY */2 :
                          case /* T_LPAREN */5 :
                          case /* T_COMMA */10 :
                              exit$1 = 2;
                              break;
                          
                        }
                      }
                    } else if (switcher > 11 || switcher < 1) {
                      exit$1 = 2;
                    } else {
                      tmp = get(env, start_loc);
                    }
                  } else {
                    tmp = get(env, start_loc);
                  }
                  if (exit$1 === 2) {
                    tmp = init(env, start_loc, key$1, false, false);
                  }
                  break;
              case "set" :
                  var match$3 = parser_env_bs.Peek.token(undefined, env);
                  var exit$2 = 0;
                  if (typeof match$3 === "number") {
                    var switcher$1 = match$3 - 80 | 0;
                    if (switcher$1 > 12 || switcher$1 < 0) {
                      if (switcher$1 >= -69) {
                        tmp = set(env, start_loc);
                      } else {
                        switch (switcher$1 + 80 | 0) {
                          case /* T_IDENTIFIER */0 :
                          case /* T_LCURLY */1 :
                          case /* T_LCURLYBAR */3 :
                          case /* T_RCURLYBAR */4 :
                          case /* T_RPAREN */6 :
                          case /* T_LBRACKET */7 :
                          case /* T_RBRACKET */8 :
                          case /* T_SEMICOLON */9 :
                              tmp = set(env, start_loc);
                              break;
                          case /* T_RCURLY */2 :
                          case /* T_LPAREN */5 :
                          case /* T_COMMA */10 :
                              exit$2 = 2;
                              break;
                          
                        }
                      }
                    } else if (switcher$1 > 11 || switcher$1 < 1) {
                      exit$2 = 2;
                    } else {
                      tmp = set(env, start_loc);
                    }
                  } else {
                    tmp = set(env, start_loc);
                  }
                  if (exit$2 === 2) {
                    tmp = init(env, start_loc, key$1, false, false);
                  }
                  break;
              default:
                exit = 1;
            }
            break;
        case /* Literal */0 :
        case /* Computed */2 :
            exit = 1;
            break;
        
      }
    }
    if (exit === 1) {
      tmp = init(env, start_loc, match$1[1], async, match);
    }
    return {
            TAG: /* Property */0,
            _0: tmp
          };
  };
  var get = function (env, start_loc) {
    var match = getter_or_setter(env, true);
    var match$1 = match[1];
    var end_loc = match$1[0];
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              key: match[0],
              value: {
                TAG: /* Get */1,
                _0: [
                  end_loc,
                  match$1[1]
                ]
              },
              _method: false,
              shorthand: false
            }
          ];
  };
  var set = function (env, start_loc) {
    var match = getter_or_setter(env, false);
    var match$1 = match[1];
    var end_loc = match$1[0];
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              key: match[0],
              value: {
                TAG: /* Set */2,
                _0: [
                  end_loc,
                  match$1[1]
                ]
              },
              _method: false,
              shorthand: false
            }
          ];
  };
  var init = function (env, start_loc, key, async, generator) {
    var match = parser_env_bs.Peek.token(undefined, env);
    var match$1;
    var exit = 0;
    if (typeof match === "number") {
      if (match !== 92) {
        if (match >= 11) {
          exit = 1;
        } else {
          switch (match) {
            case /* T_LPAREN */5 :
                exit = 3;
                break;
            case /* T_IDENTIFIER */0 :
            case /* T_LCURLY */1 :
            case /* T_LCURLYBAR */3 :
            case /* T_RCURLYBAR */4 :
            case /* T_RPAREN */6 :
            case /* T_LBRACKET */7 :
            case /* T_RBRACKET */8 :
            case /* T_SEMICOLON */9 :
                exit = 1;
                break;
            case /* T_RCURLY */2 :
            case /* T_COMMA */10 :
                exit = 2;
                break;
            
          }
        }
      } else {
        exit = 3;
      }
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 :
          parser_env_bs.Expect.token(env, /* T_COLON */80);
          match$1 = [
            curry._1(Parse.assignment, env),
            false,
            false
          ];
          break;
      case 2 :
          var tmp;
          switch (key.TAG | 0) {
            case /* Literal */0 :
                var lit = key._0;
                tmp = [
                  lit[0],
                  {
                    TAG: /* Literal */18,
                    _0: lit[1]
                  }
                ];
                break;
            case /* Identifier */1 :
                var id = key._0;
                tmp = [
                  id[0],
                  {
                    TAG: /* Identifier */17,
                    _0: id
                  }
                ];
                break;
            case /* Computed */2 :
                tmp = key._0;
                break;
            
          }
          match$1 = [
            tmp,
            true,
            false
          ];
          break;
      case 3 :
          var start_loc$1 = parser_env_bs.Peek.loc(undefined, env);
          var typeParameters = curry._1(Type.type_parameter_declaration, env);
          var params = curry._1(Declaration.function_params, env);
          var returnType = curry._1(Type.annotation_opt, env);
          var match$2 = curry._3(Declaration.function_body, env, async, generator);
          var body = match$2[1];
          var simple = curry._1(Declaration.is_simple_function_params, params);
          curry._5(Declaration.strict_post_check, env, match$2[2], simple, undefined, params);
          var match$3;
          match$3 = body.TAG === /* BodyBlock */0 ? [
              body._0[0],
              false
            ] : [
              body._0[0],
              true
            ];
          var loc = loc_bs.btwn(start_loc$1, match$3[0]);
          var value_1 = {
            TAG: /* Function */2,
            _0: {
              id: undefined,
              params: params,
              body: body,
              async: async,
              generator: generator,
              predicate: undefined,
              expression: match$3[1],
              returnType: returnType,
              typeParameters: typeParameters
            }
          };
          var value = [
            loc,
            value_1
          ];
          match$1 = [
            value,
            false,
            true
          ];
          break;
      
    }
    var value$1 = match$1[0];
    return [
            loc_bs.btwn(start_loc, value$1[0]),
            {
              key: key,
              value: {
                TAG: /* Init */0,
                _0: value$1
              },
              _method: match$1[2],
              shorthand: match$1[1]
            }
          ];
  };
  var properties = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        if (match === 2) {
          return list.rev(acc);
        }
        if (match === 108) {
          return list.rev(acc);
        }
        
      }
      var prop = property(env);
      if (parser_env_bs.Peek.token(undefined, env) !== /* T_RCURLY */2) {
        parser_env_bs.Expect.token(env, /* T_COMMA */10);
      }
      _acc = {
        hd: prop,
        tl: acc
      };
      continue ;
    }  };
  var _initializer = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_LCURLY */1);
    var props = properties(env, /* [] */0);
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RCURLY */2);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              properties: props
            }
          ];
  };
  var class_implements = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var id = curry._2(Parse.identifier, undefined, env);
      var typeParameters = curry._1(Type.type_parameter_instantiation, env);
      var loc = typeParameters !== undefined ? loc_bs.btwn(id[0], typeParameters[0]) : id[0];
      var implement_1 = {
        id: id,
        typeParameters: typeParameters
      };
      var implement = [
        loc,
        implement_1
      ];
      var acc$1 = {
        hd: implement,
        tl: acc
      };
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match !== "number") {
        return list.rev(acc$1);
      }
      if (match !== 10) {
        return list.rev(acc$1);
      }
      parser_env_bs.Expect.token(env, /* T_COMMA */10);
      _acc = acc$1;
      continue ;
    }  };
  var error_unsupported_variance = function (env, param) {
    if (param !== undefined) {
      return parser_env_bs.error_at(env, [
                  param[0],
                  /* UnexpectedVariance */5
                ]);
    }
    
  };
  var init$1 = function (env, start_loc, decorators, key, async, generator, $$static, variance) {
    while(true) {
      var match = parser_env_bs.Peek.token(undefined, env);
      var exit = 0;
      if (typeof match === "number") {
        var switcher = match - 78 | 0;
        if (switcher > 2 || switcher < 0) {
          if (switcher === -69) {
            exit = 2;
          }
          
        } else if (switcher !== 1) {
          exit = 2;
        } else {
          parser_env_bs.error_unexpected(env);
          parser_env_bs.Eat.token(env);
          continue ;
        }
      }
      if (exit === 2 && !async && !generator) {
        var typeAnnotation = curry._1(Type.annotation_opt, env);
        var options = parser_env_bs.parse_options(env);
        var value = parser_env_bs.Peek.token(undefined, env) === /* T_ASSIGN */78 && ($$static && options.esproposal_class_static_fields || !$$static && options.esproposal_class_instance_fields) ? (parser_env_bs.Expect.token(env, /* T_ASSIGN */78), curry._1(Parse.expression, env)) : undefined;
        var end_loc = parser_env_bs.Peek.loc(undefined, env);
        if (parser_env_bs.Expect.maybe(env, /* T_SEMICOLON */9) || !(parser_env_bs.Peek.token(undefined, env) === /* T_LBRACKET */7 || parser_env_bs.Peek.token(undefined, env) === /* T_LPAREN */5)) ; else {
          parser_env_bs.error_unexpected(env);
        }
        var loc = loc_bs.btwn(start_loc, end_loc);
        return {
                TAG: /* Property */1,
                _0: [
                  loc,
                  {
                    key: key,
                    value: value,
                    typeAnnotation: typeAnnotation,
                    static: $$static,
                    variance: variance
                  }
                ]
              };
      }
      error_unsupported_variance(env, variance);
      var func_loc = parser_env_bs.Peek.loc(undefined, env);
      var typeParameters = curry._1(Type.type_parameter_declaration, env);
      var params = curry._1(Declaration.function_params, env);
      var returnType = curry._1(Type.annotation_opt, env);
      var match$1 = curry._3(Declaration.function_body, env, async, generator);
      var body = match$1[1];
      var simple = curry._1(Declaration.is_simple_function_params, params);
      curry._5(Declaration.strict_post_check, env, match$1[2], simple, undefined, params);
      var match$2;
      match$2 = body.TAG === /* BodyBlock */0 ? [
          body._0[0],
          false
        ] : [
          body._0[0],
          true
        ];
      var end_loc$1 = match$2[0];
      var loc$1 = loc_bs.btwn(func_loc, end_loc$1);
      var value_1 = {
        id: undefined,
        params: params,
        body: body,
        async: async,
        generator: generator,
        predicate: undefined,
        expression: match$2[1],
        returnType: returnType,
        typeParameters: typeParameters
      };
      var value$1 = [
        loc$1,
        value_1
      ];
      var kind;
      if ($$static) {
        kind = /* Method */1;
      } else {
        switch (key.TAG | 0) {
          case /* Literal */0 :
              var match$3 = key._0[1].value;
              kind = typeof match$3 === "number" || !(match$3.TAG === /* String */0 && match$3._0 === "constructor") ? /* Method */1 : /* Constructor */0;
              break;
          case /* Identifier */1 :
              kind = key._0[1] === "constructor" ? /* Constructor */0 : /* Method */1;
              break;
          case /* Computed */2 :
              kind = /* Method */1;
              break;
          
        }
      }
      return {
              TAG: /* Method */0,
              _0: [
                loc_bs.btwn(start_loc, end_loc$1),
                {
                  kind: kind,
                  key: key,
                  value: value$1,
                  static: $$static,
                  decorators: decorators
                }
              ]
            };
    }  };
  var class_element = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var decorators = decorator_list(env);
    var $$static = parser_env_bs.Peek.token(1, env) !== /* T_LPAREN */5 && parser_env_bs.Peek.token(1, env) !== /* T_LESS_THAN */92 && parser_env_bs.Expect.maybe(env, /* T_STATIC */42);
    var async = parser_env_bs.Peek.token(1, env) !== /* T_LPAREN */5 && parser_env_bs.Peek.token(1, env) !== /* T_COLON */80 && curry._1(Declaration.async, env);
    var generator = curry._1(Declaration.generator, env);
    var variance = curry._3(Declaration.variance, env, async, generator);
    var generator$1 = generator || variance === undefined ? generator : curry._1(Declaration.generator, env);
    var match = key(env);
    if (!async && !generator$1) {
      var key$1 = match[1];
      switch (key$1.TAG | 0) {
        case /* Identifier */1 :
            switch (key$1._0[1]) {
              case "get" :
                  var match$1 = parser_env_bs.Peek.token(undefined, env);
                  var exit = 0;
                  exit = typeof match$1 === "number" ? (
                      match$1 >= 78 ? (
                          match$1 >= 81 ? (
                              match$1 !== 92 ? 2 : 3
                            ) : (
                              match$1 !== 79 ? 3 : 2
                            )
                        ) : (
                          match$1 !== 5 && match$1 !== 9 ? 2 : 3
                        )
                    ) : 2;
                  switch (exit) {
                    case 2 :
                        error_unsupported_variance(env, variance);
                        var match$2 = getter_or_setter(env, true);
                        var value = match$2[1];
                        return {
                                TAG: /* Method */0,
                                _0: [
                                  loc_bs.btwn(start_loc, value[0]),
                                  {
                                    kind: /* Get */2,
                                    key: match$2[0],
                                    value: value,
                                    static: $$static,
                                    decorators: decorators
                                  }
                                ]
                              };
                    case 3 :
                        return init$1(env, start_loc, decorators, key$1, async, generator$1, $$static, variance);
                    
                  }
                  break;
              case "set" :
                  var match$3 = parser_env_bs.Peek.token(undefined, env);
                  var exit$1 = 0;
                  exit$1 = typeof match$3 === "number" ? (
                      match$3 >= 78 ? (
                          match$3 >= 81 ? (
                              match$3 !== 92 ? 2 : 3
                            ) : (
                              match$3 !== 79 ? 3 : 2
                            )
                        ) : (
                          match$3 !== 5 && match$3 !== 9 ? 2 : 3
                        )
                    ) : 2;
                  switch (exit$1) {
                    case 2 :
                        error_unsupported_variance(env, variance);
                        var match$4 = getter_or_setter(env, false);
                        var value$1 = match$4[1];
                        return {
                                TAG: /* Method */0,
                                _0: [
                                  loc_bs.btwn(start_loc, value$1[0]),
                                  {
                                    kind: /* Set */3,
                                    key: match$4[0],
                                    value: value$1,
                                    static: $$static,
                                    decorators: decorators
                                  }
                                ]
                              };
                    case 3 :
                        return init$1(env, start_loc, decorators, key$1, async, generator$1, $$static, variance);
                    
                  }
                  break;
                
            }
            break;
        
      }
    }
    return init$1(env, start_loc, decorators, match[1], async, generator$1, $$static, variance);
  };
  var elements = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        var switcher = match - 3 | 0;
        if (switcher > 104 || switcher < 0) {
          if ((switcher + 1 >>> 0) <= 106) {
            return list.rev(acc);
          }
          
        } else if (switcher === 6) {
          parser_env_bs.Expect.token(env, /* T_SEMICOLON */9);
          continue ;
        }
        
      }
      _acc = {
        hd: curry._1(class_element, env),
        tl: acc
      };
      continue ;
    }  };
  var class_body = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_LCURLY */1);
    var body = elements(env, /* [] */0);
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RCURLY */2);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              body: body
            }
          ];
  };
  var _class = function (env) {
    var match;
    if (parser_env_bs.Peek.token(undefined, env) === /* T_EXTENDS */41) {
      parser_env_bs.Expect.token(env, /* T_EXTENDS */41);
      var superClass = curry._1(Expression.left_hand_side, parser_env_bs.with_allow_yield(false, env));
      var superTypeParameters = curry._1(Type.type_parameter_instantiation, env);
      match = [
        superClass,
        superTypeParameters
      ];
    } else {
      match = [
        undefined,
        undefined
      ];
    }
    var $$implements = parser_env_bs.Peek.token(undefined, env) === /* T_IMPLEMENTS */52 ? (!parser_env_bs.should_parse_types(env) ? parser_env_bs.error(env, /* UnexpectedTypeInterface */11) : undefined, parser_env_bs.Expect.token(env, /* T_IMPLEMENTS */52), class_implements(env, /* [] */0)) : /* [] */0;
    var body = curry._1(class_body, env);
    return [
            body,
            match[0],
            match[1],
            $$implements
          ];
  };
  var class_declaration = function (env, decorators) {
    var env$1 = parser_env_bs.with_strict(true, env);
    var start_loc = parser_env_bs.Peek.loc(undefined, env$1);
    var decorators$1 = pervasives.$at(decorators, decorator_list(env$1));
    parser_env_bs.Expect.token(env$1, /* T_CLASS */40);
    var tmp_env = parser_env_bs.with_no_let(true, env$1);
    var match = parser_env_bs.in_export(env$1);
    var match$1 = parser_env_bs.Peek.is_identifier(undefined, tmp_env);
    var id = match && !match$1 ? undefined : curry._2(Parse.identifier, undefined, tmp_env);
    var typeParameters = curry._1(Type.type_parameter_declaration_with_defaults, env$1);
    var match$2 = _class(env$1);
    var body = match$2[0];
    var loc = loc_bs.btwn(start_loc, body[0]);
    return [
            loc,
            {
              TAG: /* ClassDeclaration */19,
              _0: {
                id: id,
                body: body,
                superClass: match$2[1],
                typeParameters: typeParameters,
                superTypeParameters: match$2[2],
                implements: match$2[3],
                classDecorators: decorators$1
              }
            }
          ];
  };
  var class_expression = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var decorators = decorator_list(env);
    parser_env_bs.Expect.token(env, /* T_CLASS */40);
    var match = parser_env_bs.Peek.token(undefined, env);
    var match$1;
    var exit = 0;
    if (typeof match === "number") {
      var switcher = match - 1 | 0;
      if (switcher > 40 || switcher < 0) {
        if (switcher !== 91) {
          exit = 1;
        } else {
          match$1 = [
            undefined,
            undefined
          ];
        }
      } else if (switcher > 39 || switcher < 1) {
        match$1 = [
          undefined,
          undefined
        ];
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var id = curry._2(Parse.identifier, undefined, env);
      var typeParameters = curry._1(Type.type_parameter_declaration_with_defaults, env);
      match$1 = [
        id,
        typeParameters
      ];
    }
    var match$2 = _class(env);
    var body = match$2[0];
    var loc = loc_bs.btwn(start_loc, body[0]);
    return [
            loc,
            {
              TAG: /* Class */22,
              _0: {
                id: match$1[0],
                body: body,
                superClass: match$2[1],
                typeParameters: match$1[1],
                superTypeParameters: match$2[2],
                implements: match$2[3],
                classDecorators: decorators
              }
            }
          ];
  };
  return {
          key: key,
          _initializer: _initializer,
          class_declaration: class_declaration,
          class_expression: class_expression,
          decorator_list: decorator_list
        };
}

var Token$3;

var Ast$3;

var $$Error$4;

var Token_1$3 = Token$3;
var Ast_1$3 = Ast$3;
var $$Error_1$4 = $$Error$4;
var $$Object_1 = $$Object;
/* Loc Not a pure module */

var object_parser_bs = {
	Token: Token_1$3,
	Ast: Ast_1$3,
	$$Error: $$Error_1$4,
	$$Object: $$Object_1
};

function with_loc(fn, env) {
  var start_loc = parser_env_bs.Peek.loc(undefined, env);
  var result = curry._1(fn, env);
  var loc = parser_env_bs.last_loc(env);
  var end_loc = loc !== undefined ? loc : (parser_env_bs.error(env, {
            TAG: /* Assertion */0,
            _0: "did not consume any tokens"
          }), parser_env_bs.Peek.loc(undefined, env));
  return [
          loc_bs.btwn(start_loc, end_loc),
          result
        ];
}

var Token$4;

var $$Error$5;

var Token_1$4 = Token$4;
var $$Error_1$5 = $$Error$5;
var with_loc_1 = with_loc;
/* Loc Not a pure module */

var parser_common_bs = {
	Token: Token_1$4,
	$$Error: $$Error_1$5,
	with_loc: with_loc_1
};

function Pattern(Parse, Type) {
  var object_from_expr = function (env, param) {
    var properties = list.map((function (param) {
            if (param.TAG === /* Property */0) {
              var match = param._0;
              var match$1 = match[1];
              var value = match$1.value;
              var key = match$1.key;
              var key$1;
              switch (key.TAG | 0) {
                case /* Literal */0 :
                    key$1 = {
                      TAG: /* Literal */0,
                      _0: key._0
                    };
                    break;
                case /* Identifier */1 :
                    key$1 = {
                      TAG: /* Identifier */1,
                      _0: key._0
                    };
                    break;
                case /* Computed */2 :
                    key$1 = {
                      TAG: /* Computed */2,
                      _0: key._0
                    };
                    break;
                
              }
              var pattern;
              var exit = 0;
              switch (value.TAG | 0) {
                case /* Init */0 :
                    pattern = curry._2(Parse.pattern_from_expr, env, value._0);
                    break;
                case /* Get */1 :
                case /* Set */2 :
                    exit = 1;
                    break;
                
              }
              if (exit === 1) {
                var match$2 = value._0;
                var loc = match$2[0];
                parser_env_bs.error_at(env, [
                      loc,
                      /* UnexpectedIdentifier */2
                    ]);
                pattern = [
                  loc,
                  {
                    TAG: /* Expression */4,
                    _0: [
                      loc,
                      {
                        TAG: /* Function */2,
                        _0: match$2[1]
                      }
                    ]
                  }
                ];
              }
              return {
                      TAG: /* Property */0,
                      _0: [
                        match[0],
                        {
                          key: key$1,
                          pattern: pattern,
                          shorthand: match$1.shorthand
                        }
                      ]
                    };
            }
            var match$3 = param._0;
            var argument = curry._2(Parse.pattern_from_expr, env, match$3[1].argument);
            return {
                    TAG: /* RestProperty */1,
                    _0: [
                      match$3[0],
                      {
                        argument: argument
                      }
                    ]
                  };
          }), param[1].properties);
    return [
            param[0],
            {
              TAG: /* Object */0,
              _0: {
                properties: properties,
                typeAnnotation: undefined
              }
            }
          ];
  };
  var array_from_expr = function (env, param) {
    var elements = list.map((function (param) {
            if (param === undefined) {
              return ;
            }
            if (param.TAG === /* Expression */0) {
              var match = param._0;
              return {
                      TAG: /* Element */0,
                      _0: curry._2(Parse.pattern_from_expr, env, [
                            match[0],
                            match[1]
                          ])
                    };
            }
            var match$1 = param._0;
            var argument = curry._2(Parse.pattern_from_expr, env, match$1[1].argument);
            return {
                    TAG: /* RestElement */1,
                    _0: [
                      match$1[0],
                      {
                        argument: argument
                      }
                    ]
                  };
          }), param[1].elements);
    return [
            param[0],
            {
              TAG: /* Array */1,
              _0: {
                elements: elements,
                typeAnnotation: undefined
              }
            }
          ];
  };
  var from_expr = function (env, param) {
    var expr = param[1];
    var loc = param[0];
    if (typeof expr !== "number") {
      switch (expr.TAG | 0) {
        case /* Array */0 :
            return array_from_expr(env, [
                        loc,
                        expr._0
                      ]);
        case /* Object */1 :
            return object_from_expr(env, [
                        loc,
                        expr._0
                      ]);
        case /* Assignment */7 :
            var match = expr._0;
            if (match.operator === 0) {
              return [
                      loc,
                      {
                        TAG: /* Assignment */2,
                        _0: {
                          left: match.left,
                          right: match.right
                        }
                      }
                    ];
            }
            break;
        case /* Identifier */17 :
            return [
                    loc,
                    {
                      TAG: /* Identifier */3,
                      _0: {
                        name: expr._0,
                        typeAnnotation: undefined,
                        optional: false
                      }
                    }
                  ];
          
      }
    }
    return [
            loc,
            {
              TAG: /* Expression */4,
              _0: [
                loc,
                expr
              ]
            }
          ];
  };
  var _object = function (restricted_error) {
    var property = function (env) {
      var start_loc = parser_env_bs.Peek.loc(undefined, env);
      if (parser_env_bs.Expect.maybe(env, /* T_ELLIPSIS */13)) {
        var argument = pattern(env, restricted_error);
        var loc = loc_bs.btwn(start_loc, argument[0]);
        return {
                TAG: /* RestProperty */1,
                _0: [
                  loc,
                  {
                    argument: argument
                  }
                ]
              };
      }
      var match = curry._1(Parse.object_key, env);
      var lit = match[1];
      var key;
      switch (lit.TAG | 0) {
        case /* Literal */0 :
            key = {
              TAG: /* Literal */0,
              _0: lit._0
            };
            break;
        case /* Identifier */1 :
            key = {
              TAG: /* Identifier */1,
              _0: lit._0
            };
            break;
        case /* Computed */2 :
            key = {
              TAG: /* Computed */2,
              _0: lit._0
            };
            break;
        
      }
      var match$1 = parser_env_bs.Peek.token(undefined, env);
      var prop;
      var exit = 0;
      if (typeof match$1 === "number" && match$1 === 80) {
        parser_env_bs.Expect.token(env, /* T_COLON */80);
        prop = [
          pattern(env, restricted_error),
          false
        ];
      } else {
        exit = 1;
      }
      if (exit === 1) {
        switch (key.TAG | 0) {
          case /* Identifier */1 :
              var name = key._0;
              var pattern_0 = name[0];
              var pattern_1 = {
                TAG: /* Identifier */3,
                _0: {
                  name: name,
                  typeAnnotation: undefined,
                  optional: false
                }
              };
              var pattern$1 = [
                pattern_0,
                pattern_1
              ];
              prop = [
                pattern$1,
                true
              ];
              break;
          case /* Literal */0 :
          case /* Computed */2 :
              parser_env_bs.error_unexpected(env);
              prop = undefined;
              break;
          
        }
      }
      if (prop === undefined) {
        return ;
      }
      var pattern$2 = prop[0];
      var match$2 = parser_env_bs.Peek.token(undefined, env);
      var pattern$3;
      if (typeof match$2 === "number" && match$2 === 78) {
        parser_env_bs.Expect.token(env, /* T_ASSIGN */78);
        var $$default = curry._1(Parse.assignment, env);
        var loc$1 = loc_bs.btwn(pattern$2[0], $$default[0]);
        pattern$3 = [
          loc$1,
          {
            TAG: /* Assignment */2,
            _0: {
              left: pattern$2,
              right: $$default
            }
          }
        ];
      } else {
        pattern$3 = pattern$2;
      }
      var loc$2 = loc_bs.btwn(start_loc, pattern$3[0]);
      return {
              TAG: /* Property */0,
              _0: [
                loc$2,
                {
                  key: key,
                  pattern: pattern$3,
                  shorthand: prop[1]
                }
              ]
            };
    };
    var properties = function (env, _acc) {
      while(true) {
        var acc = _acc;
        var match = parser_env_bs.Peek.token(undefined, env);
        if (typeof match === "number") {
          if (match === 2) {
            return list.rev(acc);
          }
          if (match === 108) {
            return list.rev(acc);
          }
          
        }
        var prop = property(env);
        if (prop !== undefined) {
          if (parser_env_bs.Peek.token(undefined, env) !== /* T_RCURLY */2) {
            parser_env_bs.Expect.token(env, /* T_COMMA */10);
          }
          _acc = {
            hd: prop,
            tl: acc
          };
          continue ;
        }
        continue ;
      }    };
    return function (env) {
      var start_loc = parser_env_bs.Peek.loc(undefined, env);
      parser_env_bs.Expect.token(env, /* T_LCURLY */1);
      var properties$1 = properties(env, /* [] */0);
      var end_loc = parser_env_bs.Peek.loc(undefined, env);
      parser_env_bs.Expect.token(env, /* T_RCURLY */2);
      var match;
      if (parser_env_bs.Peek.token(undefined, env) === /* T_COLON */80) {
        var typeAnnotation = curry._1(Type.annotation, env);
        match = [
          typeAnnotation[0],
          typeAnnotation
        ];
      } else {
        match = [
          end_loc,
          undefined
        ];
      }
      return [
              loc_bs.btwn(start_loc, match[0]),
              {
                TAG: /* Object */0,
                _0: {
                  properties: properties$1,
                  typeAnnotation: match[1]
                }
              }
            ];
    };
  };
  var _array = function (restricted_error) {
    var elements = function (env, _acc) {
      while(true) {
        var acc = _acc;
        var match = parser_env_bs.Peek.token(undefined, env);
        if (typeof match === "number") {
          if (match >= 14) {
            if (match === 108) {
              return list.rev(acc);
            }
            
          } else if (match >= 8) {
            switch (match - 8 | 0) {
              case /* T_IDENTIFIER */0 :
                  return list.rev(acc);
              case /* T_RCURLY */2 :
                  parser_env_bs.Expect.token(env, /* T_COMMA */10);
                  _acc = {
                    hd: undefined,
                    tl: acc
                  };
                  continue ;
              case /* T_LCURLY */1 :
              case /* T_LCURLYBAR */3 :
              case /* T_RCURLYBAR */4 :
                  break;
              case /* T_LPAREN */5 :
                  var start_loc = parser_env_bs.Peek.loc(undefined, env);
                  parser_env_bs.Expect.token(env, /* T_ELLIPSIS */13);
                  var argument = pattern(env, restricted_error);
                  var loc = loc_bs.btwn(start_loc, argument[0]);
                  var element = {
                    TAG: /* RestElement */1,
                    _0: [
                      loc,
                      {
                        argument: argument
                      }
                    ]
                  };
                  _acc = {
                    hd: element,
                    tl: acc
                  };
                  continue ;
              
            }
          }
          
        }
        var pattern$1 = pattern(env, restricted_error);
        var match$1 = parser_env_bs.Peek.token(undefined, env);
        var pattern$2;
        if (typeof match$1 === "number" && match$1 === 78) {
          parser_env_bs.Expect.token(env, /* T_ASSIGN */78);
          var $$default = curry._1(Parse.expression, env);
          var loc$1 = loc_bs.btwn(pattern$1[0], $$default[0]);
          pattern$2 = [
            loc$1,
            {
              TAG: /* Assignment */2,
              _0: {
                left: pattern$1,
                right: $$default
              }
            }
          ];
        } else {
          pattern$2 = pattern$1;
        }
        var element$1 = {
          TAG: /* Element */0,
          _0: pattern$2
        };
        if (parser_env_bs.Peek.token(undefined, env) !== /* T_RBRACKET */8) {
          parser_env_bs.Expect.token(env, /* T_COMMA */10);
        }
        _acc = {
          hd: element$1,
          tl: acc
        };
        continue ;
      }    };
    return function (env) {
      var start_loc = parser_env_bs.Peek.loc(undefined, env);
      parser_env_bs.Expect.token(env, /* T_LBRACKET */7);
      var elements$1 = elements(env, /* [] */0);
      var end_loc = parser_env_bs.Peek.loc(undefined, env);
      parser_env_bs.Expect.token(env, /* T_RBRACKET */8);
      var match;
      if (parser_env_bs.Peek.token(undefined, env) === /* T_COLON */80) {
        var typeAnnotation = curry._1(Type.annotation, env);
        match = [
          typeAnnotation[0],
          typeAnnotation
        ];
      } else {
        match = [
          end_loc,
          undefined
        ];
      }
      return [
              loc_bs.btwn(start_loc, match[0]),
              {
                TAG: /* Array */1,
                _0: {
                  elements: elements$1,
                  typeAnnotation: match[1]
                }
              }
            ];
    };
  };
  var pattern = function (env, restricted_error) {
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match === "number") {
      if (match === 1) {
        return _object(restricted_error)(env);
      }
      if (match === 7) {
        return _array(restricted_error)(env);
      }
      
    }
    var match$1 = curry._3(Parse.identifier_with_type, env, undefined, restricted_error);
    return [
            match$1[0],
            {
              TAG: /* Identifier */3,
              _0: match$1[1]
            }
          ];
  };
  return {
          object_from_expr: object_from_expr,
          array_from_expr: array_from_expr,
          from_expr: from_expr,
          _object: _object,
          _array: _array,
          pattern: pattern
        };
}

var Token$5;

var Ast$4;

var $$Error$6;

var Token_1$5 = Token$5;
var Ast_1$4 = Ast$4;
var $$Error_1$6 = $$Error$6;
var Pattern_1 = Pattern;
/* Loc Not a pure module */

var pattern_parser_bs = {
	Token: Token_1$5,
	Ast: Ast_1$4,
	$$Error: $$Error_1$6,
	Pattern: Pattern_1
};

var SSet$1 = set$2.Make({
      compare: string.compare
    });

function Statement(Parse, Type, Declaration, $$Object) {
  var supers = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var $$super = curry._1(Type.generic, env);
      var acc$1 = {
        hd: $$super,
        tl: acc
      };
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match !== "number") {
        return list.rev(acc$1);
      }
      if (match !== 10) {
        return list.rev(acc$1);
      }
      parser_env_bs.Expect.token(env, /* T_COMMA */10);
      _acc = acc$1;
      continue ;
    }  };
  var declare_class = function (env, start_loc) {
    var env$1 = parser_env_bs.with_strict(true, env);
    parser_env_bs.Expect.token(env$1, /* T_CLASS */40);
    var id = curry._2(Parse.identifier, undefined, env$1);
    var typeParameters = curry._1(Type.type_parameter_declaration_with_defaults, env$1);
    var $$extends = parser_env_bs.Peek.token(undefined, env$1) === /* T_EXTENDS */41 ? (parser_env_bs.Expect.token(env$1, /* T_EXTENDS */41), supers(env$1, /* [] */0)) : /* [] */0;
    var mixins = parser_env_bs.Peek.value(undefined, env$1) === "mixins" ? (parser_env_bs.Expect.contextual(env$1, "mixins"), supers(env$1, /* [] */0)) : /* [] */0;
    var body = curry._2(Type._object, true, env$1);
    var loc = loc_bs.btwn(start_loc, body[0]);
    return [
            loc,
            {
              id: id,
              typeParameters: typeParameters,
              body: body,
              extends: $$extends,
              mixins: mixins
            }
          ];
  };
  var type_alias_helper = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    if (!parser_env_bs.should_parse_types(env)) {
      parser_env_bs.error(env, /* UnexpectedTypeAlias */6);
    }
    parser_env_bs.Expect.token(env, /* T_TYPE */61);
    parser_env_bs.Eat.push_lex_mode(env, /* TYPE */1);
    var id = curry._2(Parse.identifier, undefined, env);
    var typeParameters = curry._1(Type.type_parameter_declaration_with_defaults, env);
    parser_env_bs.Expect.token(env, /* T_ASSIGN */78);
    var right = curry._1(Type._type, env);
    var end_loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc$1 = end_loc !== undefined ? end_loc : right[0];
    parser_env_bs.Eat.semicolon(env);
    parser_env_bs.Eat.pop_lex_mode(env);
    return [
            loc_bs.btwn(start_loc, end_loc$1),
            {
              id: id,
              typeParameters: typeParameters,
              right: right
            }
          ];
  };
  var declare_var = function (env, start_loc) {
    parser_env_bs.Expect.token(env, /* T_VAR */24);
    var match = curry._3(Parse.identifier_with_type, env, true, /* StrictVarName */28);
    var match$1 = match[1];
    var loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc = loc !== undefined ? loc : match[0];
    var loc$1 = loc_bs.btwn(start_loc, end_loc);
    parser_env_bs.Eat.semicolon(env);
    return [
            loc$1,
            {
              id: match$1.name,
              typeAnnotation: match$1.typeAnnotation
            }
          ];
  };
  var export_source = function (env) {
    parser_env_bs.Expect.contextual(env, "from");
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match !== "number" && match.TAG === /* T_STRING */1) {
      var match$1 = match._0;
      var octal = match$1[3];
      var raw = match$1[2];
      var value = match$1[1];
      var loc = match$1[0];
      if (octal) {
        parser_env_bs.strict_error(env, /* StrictOctalLiteral */32);
      }
      parser_env_bs.Expect.token(env, {
            TAG: /* T_STRING */1,
            _0: [
              loc,
              value,
              raw,
              octal
            ]
          });
      var value$1 = {
        TAG: /* String */0,
        _0: value
      };
      return [
              loc,
              {
                value: value$1,
                raw: raw
              }
            ];
    }
    var raw$1 = parser_env_bs.Peek.value(undefined, env);
    var value$2 = {
      TAG: /* String */0,
      _0: raw$1
    };
    var ret_0 = parser_env_bs.Peek.loc(undefined, env);
    var ret_1 = {
      value: value$2,
      raw: raw$1
    };
    var ret = [
      ret_0,
      ret_1
    ];
    parser_env_bs.error_unexpected(env);
    return ret;
  };
  var declare_function = function (env, start_loc) {
    parser_env_bs.Expect.token(env, /* T_FUNCTION */15);
    var id = curry._2(Parse.identifier, undefined, env);
    var start_sig_loc = parser_env_bs.Peek.loc(undefined, env);
    var typeParameters = curry._1(Type.type_parameter_declaration, env);
    var params = curry._1(Type.function_param_list, env);
    parser_env_bs.Expect.token(env, /* T_COLON */80);
    var returnType = curry._1(Type._type, env);
    var end_loc = returnType[0];
    var predicate = curry._1(Type.predicate_opt, env);
    var loc = loc_bs.btwn(start_sig_loc, end_loc);
    var typeAnnotation_1 = {
      TAG: /* Function */1,
      _0: {
        params: params,
        returnType: returnType,
        typeParameters: typeParameters
      }
    };
    var typeAnnotation = [
      loc,
      typeAnnotation_1
    ];
    var typeAnnotation$1 = [
      loc,
      typeAnnotation
    ];
    var id_0 = loc_bs.btwn(id[0], end_loc);
    var id_1 = id[1];
    var id$1 = [
      id_0,
      id_1
    ];
    var end_loc$1 = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc$2 = end_loc$1 !== undefined ? end_loc$1 : end_loc;
    parser_env_bs.Eat.semicolon(env);
    var loc$1 = loc_bs.btwn(start_loc, end_loc$2);
    return [
            loc$1,
            {
              id: id$1,
              typeAnnotation: typeAnnotation$1,
              predicate: predicate
            }
          ];
  };
  var supers$1 = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var $$super = curry._1(Type.generic, env);
      var acc$1 = {
        hd: $$super,
        tl: acc
      };
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match !== "number") {
        return list.rev(acc$1);
      }
      if (match !== 10) {
        return list.rev(acc$1);
      }
      parser_env_bs.Expect.token(env, /* T_COMMA */10);
      _acc = acc$1;
      continue ;
    }  };
  var interface_helper = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    if (!parser_env_bs.should_parse_types(env)) {
      parser_env_bs.error(env, /* UnexpectedTypeInterface */11);
    }
    parser_env_bs.Expect.token(env, /* T_INTERFACE */53);
    var id = curry._2(Parse.identifier, undefined, env);
    var typeParameters = curry._1(Type.type_parameter_declaration_with_defaults, env);
    var $$extends = parser_env_bs.Peek.token(undefined, env) === /* T_EXTENDS */41 ? (parser_env_bs.Expect.token(env, /* T_EXTENDS */41), supers$1(env, /* [] */0)) : /* [] */0;
    var body = curry._2(Type._object, true, env);
    var loc = loc_bs.btwn(start_loc, body[0]);
    return [
            loc,
            {
              id: id,
              typeParameters: typeParameters,
              body: body,
              extends: $$extends,
              mixins: /* [] */0
            }
          ];
  };
  var export_specifiers_and_errs = function (env, _specifiers, _errs) {
    while(true) {
      var errs = _errs;
      var specifiers = _specifiers;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        if (match === 2) {
          return [
                  list.rev(specifiers),
                  list.rev(errs)
                ];
        }
        if (match === 108) {
          return [
                  list.rev(specifiers),
                  list.rev(errs)
                ];
        }
        
      }
      var match$1 = curry._1(Parse.identifier_or_reserved_keyword, env);
      var local = match$1[0];
      var match$2;
      if (parser_env_bs.Peek.value(undefined, env) === "as") {
        parser_env_bs.Expect.contextual(env, "as");
        var match$3 = curry._1(Parse.identifier_or_reserved_keyword, env);
        var name = match$3[0];
        parser_env_bs.record_export(env, [
              name[0],
              extract_ident_name(name)
            ]);
        match$2 = [
          name,
          undefined,
          name[0]
        ];
      } else {
        var loc = local[0];
        parser_env_bs.record_export(env, [
              loc,
              extract_ident_name(local)
            ]);
        match$2 = [
          undefined,
          match$1[1],
          loc
        ];
      }
      var err = match$2[1];
      var loc$1 = loc_bs.btwn(local[0], match$2[2]);
      var specifier_1 = {
        local: local,
        exported: match$2[0]
      };
      var specifier = [
        loc$1,
        specifier_1
      ];
      if (parser_env_bs.Peek.token(undefined, env) === /* T_COMMA */10) {
        parser_env_bs.Expect.token(env, /* T_COMMA */10);
      }
      var errs$1 = err !== undefined ? ({
            hd: err,
            tl: errs
          }) : errs;
      _errs = errs$1;
      _specifiers = {
        hd: specifier,
        tl: specifiers
      };
      continue ;
    }  };
  var declare = function (in_moduleOpt, env) {
    var in_module = in_moduleOpt !== undefined ? in_moduleOpt : false;
    if (!parser_env_bs.should_parse_types(env)) {
      parser_env_bs.error(env, /* UnexpectedTypeDeclaration */8);
    }
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var match = parser_env_bs.Peek.token(1, env);
    var exit = 0;
    if (typeof match === "number") {
      if (match >= 24) {
        if (match >= 40) {
          if (match >= 64) {
            exit = 1;
          } else {
            switch (match - 40 | 0) {
              case /* T_IDENTIFIER */0 :
                  parser_env_bs.Expect.token(env, /* T_DECLARE */60);
                  var match$1 = declare_class(env, start_loc);
                  return [
                          match$1[0],
                          {
                            TAG: /* DeclareClass */23,
                            _0: match$1[1]
                          }
                        ];
              case /* T_RPAREN */6 :
                  if (parser_env_bs.Peek.token(undefined, env) === /* T_IMPORT */50) {
                    return curry._1(import_declaration, env);
                  }
                  exit = 1;
                  break;
              case /* T_SEMICOLON */9 :
                  if (in_module) {
                    return declare_export_declaration(in_module, env);
                  }
                  exit = 1;
                  break;
              case /* T_ELLIPSIS */13 :
                  parser_env_bs.Expect.token(env, /* T_DECLARE */60);
                  return $$interface(env);
              case /* T_THIS */21 :
                  var match$2 = parser_env_bs.Peek.token(undefined, env);
                  var exit$1 = 0;
                  if (typeof match$2 === "number" && match$2 === 50) {
                    if (in_module) {
                      return curry._1(import_declaration, env);
                    }
                    exit$1 = 2;
                  } else {
                    exit$1 = 2;
                  }
                  if (exit$1 === 2) {
                    parser_env_bs.Expect.token(env, /* T_DECLARE */60);
                    return type_alias(env);
                  }
                  break;
              case /* T_LCURLY */1 :
              case /* T_RCURLY */2 :
              case /* T_LCURLYBAR */3 :
              case /* T_RCURLYBAR */4 :
              case /* T_LPAREN */5 :
              case /* T_LBRACKET */7 :
              case /* T_RBRACKET */8 :
              case /* T_COMMA */10 :
              case /* T_PERIOD */11 :
              case /* T_ARROW */12 :
              case /* T_AT */14 :
              case /* T_FUNCTION */15 :
              case /* T_IF */16 :
              case /* T_IN */17 :
              case /* T_INSTANCEOF */18 :
              case /* T_RETURN */19 :
              case /* T_SWITCH */20 :
              case /* T_THROW */22 :
                  exit = 1;
                  break;
              case /* T_TRY */23 :
                  parser_env_bs.Expect.token(env, /* T_DECLARE */60);
                  parser_env_bs.error(env, /* DeclareAsync */49);
                  parser_env_bs.Expect.token(env, /* T_ASYNC */63);
                  return declare_function_statement(env, start_loc);
              
            }
          }
        } else if (match >= 25) {
          exit = 1;
        } else {
          parser_env_bs.Expect.token(env, /* T_DECLARE */60);
          return declare_var_statement(env, start_loc);
        }
      } else if (match !== 15) {
        if (match !== 0) {
          exit = 1;
        } else {
          if (parser_env_bs.Peek.value(1, env) === "module") {
            parser_env_bs.Expect.token(env, /* T_DECLARE */60);
            parser_env_bs.Expect.contextual(env, "module");
            if (in_module || parser_env_bs.Peek.token(undefined, env) === /* T_PERIOD */11) {
              parser_env_bs.Expect.token(env, /* T_PERIOD */11);
              parser_env_bs.Expect.contextual(env, "exports");
              var type_annot = curry._1(Type.annotation, env);
              var loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
              var end_loc = loc !== undefined ? loc : type_annot[0];
              parser_env_bs.Eat.semicolon(env);
              var loc$1 = loc_bs.btwn(start_loc, end_loc);
              return [
                      loc$1,
                      {
                        TAG: /* DeclareModuleExports */25,
                        _0: type_annot
                      }
                    ];
            } else {
              var match$3 = parser_env_bs.Peek.token(undefined, env);
              var id;
              if (typeof match$3 === "number" || match$3.TAG !== /* T_STRING */1) {
                id = {
                  TAG: /* Identifier */0,
                  _0: curry._2(Parse.identifier, undefined, env)
                };
              } else {
                var match$4 = match$3._0;
                var octal = match$4[3];
                var raw = match$4[2];
                var value = match$4[1];
                var loc$2 = match$4[0];
                if (octal) {
                  parser_env_bs.strict_error(env, /* StrictOctalLiteral */32);
                }
                parser_env_bs.Expect.token(env, {
                      TAG: /* T_STRING */1,
                      _0: [
                        loc$2,
                        value,
                        raw,
                        octal
                      ]
                    });
                var value$1 = {
                  TAG: /* String */0,
                  _0: value
                };
                id = {
                  TAG: /* Literal */1,
                  _0: [
                    loc$2,
                    {
                      value: value$1,
                      raw: raw
                    }
                  ]
                };
              }
              var body_start_loc = parser_env_bs.Peek.loc(undefined, env);
              parser_env_bs.Expect.token(env, /* T_LCURLY */1);
              var match$5 = module_items(env, undefined, /* [] */0);
              var module_kind = match$5[0];
              parser_env_bs.Expect.token(env, /* T_RCURLY */2);
              var body_end_loc = parser_env_bs.Peek.loc(undefined, env);
              var body_loc = loc_bs.btwn(body_start_loc, body_end_loc);
              var body_1 = {
                body: match$5[1]
              };
              var body = [
                body_loc,
                body_1
              ];
              var loc$3 = loc_bs.btwn(start_loc, body_loc);
              var kind = module_kind !== undefined ? module_kind : ({
                    TAG: /* CommonJS */0,
                    _0: loc$3
                  });
              return [
                      loc$3,
                      {
                        TAG: /* DeclareModule */24,
                        _0: {
                          id: id,
                          body: body,
                          kind: kind
                        }
                      }
                    ];
            }
          }
          exit = 1;
        }
      } else {
        parser_env_bs.Expect.token(env, /* T_DECLARE */60);
        return declare_function_statement(env, start_loc);
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (!in_module) {
        return curry._1(Parse.statement, env);
      }
      var match$6 = parser_env_bs.Peek.token(undefined, env);
      var exit$2 = 0;
      if (typeof match$6 === "number" && match$6 === 50) {
        parser_env_bs.error(env, /* InvalidNonTypeImportInDeclareModule */64);
        return curry._1(Parse.statement, env);
      }
      exit$2 = 2;
      if (exit$2 === 2) {
        parser_env_bs.Expect.token(env, /* T_DECLARE */60);
        return declare_var_statement(env, start_loc);
      }
      
    }
    
  };
  var expression = function (env) {
    var match = parser_common_bs.with_loc(Parse.expression, env);
    var expression$1 = match[1];
    var loc = match[0];
    var semicolon_loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var loc$1 = semicolon_loc !== undefined ? loc_bs.btwn(loc, semicolon_loc) : loc;
    parser_env_bs.Eat.semicolon(env);
    var directive;
    if (parser_env_bs.allow_directive(env)) {
      var match$1 = expression$1[1];
      if (typeof match$1 === "number" || match$1.TAG !== /* Literal */18) {
        directive = undefined;
      } else {
        var match$2 = match$1._0;
        var tmp = match$2.value;
        if (typeof tmp === "number" || tmp.TAG !== /* String */0) {
          directive = undefined;
        } else {
          var raw = match$2.raw;
          directive = string.sub(raw, 1, raw.length - 2 | 0);
        }
      }
    } else {
      directive = undefined;
    }
    return [
            loc$1,
            {
              TAG: /* Expression */1,
              _0: {
                expression: expression$1,
                directive: directive
              }
            }
          ];
  };
  var extract_ident_name = function (param) {
    return param[1];
  };
  var $$interface = function (env) {
    if (!parser_env_bs.Peek.is_identifier(1, env)) {
      return expression(env);
    }
    var match = interface_helper(env);
    return [
            match[0],
            {
              TAG: /* InterfaceDeclaration */20,
              _0: match[1]
            }
          ];
  };
  var declare_export_declaration = function (allow_export_typeOpt, env) {
    var allow_export_type = allow_export_typeOpt !== undefined ? allow_export_typeOpt : false;
    if (!parser_env_bs.should_parse_types(env)) {
      parser_env_bs.error(env, /* UnexpectedTypeDeclaration */8);
    }
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_DECLARE */60);
    var env$1 = parser_env_bs.with_in_export(true, parser_env_bs.with_strict(true, env));
    parser_env_bs.Expect.token(env$1, /* T_EXPORT */49);
    var match = parser_env_bs.Peek.token(undefined, env$1);
    var exit = 0;
    if (typeof match === "number") {
      if (match >= 54) {
        if (match !== 61) {
          if (match !== 100) {
            exit = 1;
          } else {
            var loc = parser_env_bs.Peek.loc(undefined, env$1);
            parser_env_bs.Expect.token(env$1, /* T_MULT */100);
            var parse_export_star_as = parser_env_bs.parse_options(env$1).esproposal_export_star_as;
            var local_name = parser_env_bs.Peek.value(undefined, env$1) === "as" ? (parser_env_bs.Expect.contextual(env$1, "as"), parse_export_star_as ? curry._2(Parse.identifier, undefined, env$1) : (parser_env_bs.error(env$1, /* UnexpectedTypeDeclaration */8), undefined)) : undefined;
            var specifiers = {
              TAG: /* ExportBatchSpecifier */1,
              _0: loc,
              _1: local_name
            };
            var source = export_source(env$1);
            var loc$1 = parser_env_bs.Peek.semicolon_loc(undefined, env$1);
            var end_loc = loc$1 !== undefined ? loc$1 : source[0];
            var source$1 = source;
            parser_env_bs.Eat.semicolon(env$1);
            return [
                    loc_bs.btwn(start_loc, end_loc),
                    {
                      TAG: /* DeclareExportDeclaration */26,
                      _0: {
                        default: false,
                        declaration: undefined,
                        specifiers: specifiers,
                        source: source$1
                      }
                    }
                  ];
          }
        } else {
          if (allow_export_type) {
            var match$1 = type_alias_helper(env$1);
            var alias_loc = match$1[0];
            var loc$2 = loc_bs.btwn(start_loc, alias_loc);
            return [
                    loc$2,
                    {
                      TAG: /* DeclareExportDeclaration */26,
                      _0: {
                        default: false,
                        declaration: {
                          TAG: /* NamedType */4,
                          _0: [
                            alias_loc,
                            match$1[1]
                          ]
                        },
                        specifiers: undefined,
                        source: undefined
                      }
                    }
                  ];
          }
          exit = 1;
        }
      } else if (match >= 41) {
        if (match >= 53) {
          if (allow_export_type) {
            var match$2 = interface_helper(env$1);
            var iface_loc = match$2[0];
            var loc$3 = loc_bs.btwn(start_loc, iface_loc);
            return [
                    loc$3,
                    {
                      TAG: /* DeclareExportDeclaration */26,
                      _0: {
                        default: false,
                        declaration: {
                          TAG: /* Interface */5,
                          _0: [
                            iface_loc,
                            match$2[1]
                          ]
                        },
                        specifiers: undefined,
                        source: undefined
                      }
                    }
                  ];
          }
          exit = 1;
        } else {
          exit = 1;
        }
      } else if (match >= 15) {
        switch (match - 15 | 0) {
          case /* T_THIS */21 :
              parser_env_bs.Expect.token(env$1, /* T_DEFAULT */36);
              var match$3 = parser_env_bs.Peek.token(undefined, env$1);
              var match$4;
              var exit$1 = 0;
              if (typeof match$3 === "number") {
                if (match$3 !== 15) {
                  if (match$3 !== 40) {
                    exit$1 = 3;
                  } else {
                    var _class = declare_class(env$1, start_loc);
                    match$4 = [
                      _class[0],
                      {
                        TAG: /* Class */2,
                        _0: _class
                      }
                    ];
                  }
                } else {
                  var fn = declare_function(env$1, start_loc);
                  match$4 = [
                    fn[0],
                    {
                      TAG: /* Function */1,
                      _0: fn
                    }
                  ];
                }
              } else {
                exit$1 = 3;
              }
              if (exit$1 === 3) {
                var _type = curry._1(Type._type, env$1);
                var loc$4 = parser_env_bs.Peek.semicolon_loc(undefined, env$1);
                var end_loc$1 = loc$4 !== undefined ? loc$4 : _type[0];
                parser_env_bs.Eat.semicolon(env$1);
                match$4 = [
                  end_loc$1,
                  {
                    TAG: /* DefaultType */3,
                    _0: _type
                  }
                ];
              }
              return [
                      loc_bs.btwn(start_loc, match$4[0]),
                      {
                        TAG: /* DeclareExportDeclaration */26,
                        _0: {
                          default: true,
                          declaration: match$4[1],
                          specifiers: undefined,
                          source: undefined
                        }
                      }
                    ];
          case /* T_LCURLY */1 :
          case /* T_RCURLY */2 :
          case /* T_LCURLYBAR */3 :
          case /* T_RCURLYBAR */4 :
          case /* T_LPAREN */5 :
          case /* T_RPAREN */6 :
          case /* T_LBRACKET */7 :
          case /* T_RBRACKET */8 :
          case /* T_COMMA */10 :
          case /* T_PERIOD */11 :
          case /* T_AT */14 :
          case /* T_FUNCTION */15 :
          case /* T_IF */16 :
          case /* T_IN */17 :
          case /* T_INSTANCEOF */18 :
          case /* T_RETURN */19 :
          case /* T_SWITCH */20 :
          case /* T_THROW */22 :
          case /* T_TRY */23 :
          case /* T_VAR */24 :
              exit = 1;
              break;
          case /* T_IDENTIFIER */0 :
          case /* T_SEMICOLON */9 :
          case /* T_ARROW */12 :
          case /* T_ELLIPSIS */13 :
          case /* T_WHILE */25 :
              exit = 2;
              break;
          
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 :
          var match$5 = parser_env_bs.Peek.token(undefined, env$1);
          if (typeof match$5 === "number") {
            if (match$5 !== 53) {
              if (match$5 !== 61) ; else {
                parser_env_bs.error(env$1, /* DeclareExportType */52);
              }
            } else {
              parser_env_bs.error(env$1, /* DeclareExportInterface */53);
            }
          }
          parser_env_bs.Expect.token(env$1, /* T_LCURLY */1);
          var match$6 = export_specifiers_and_errs(env$1, /* [] */0, /* [] */0);
          var specifiers$1 = {
            TAG: /* ExportSpecifiers */0,
            _0: match$6[0]
          };
          var end_loc$2 = parser_env_bs.Peek.loc(undefined, env$1);
          parser_env_bs.Expect.token(env$1, /* T_RCURLY */2);
          var source$2 = parser_env_bs.Peek.value(undefined, env$1) === "from" ? export_source(env$1) : (list.iter((function (param) {
                      return parser_env_bs.error_at(env$1, param);
                    }), match$6[1]), undefined);
          var loc$5 = parser_env_bs.Peek.semicolon_loc(undefined, env$1);
          var end_loc$3 = loc$5 !== undefined ? loc$5 : (
              source$2 !== undefined ? source$2[0] : end_loc$2
            );
          parser_env_bs.Eat.semicolon(env$1);
          return [
                  loc_bs.btwn(start_loc, end_loc$3),
                  {
                    TAG: /* DeclareExportDeclaration */26,
                    _0: {
                      default: false,
                      declaration: undefined,
                      specifiers: specifiers$1,
                      source: source$2
                    }
                  }
                ];
      case 2 :
          var token = parser_env_bs.Peek.token(undefined, env$1);
          var match$7;
          var exit$2 = 0;
          if (typeof token === "number") {
            if (token >= 25) {
              if (token >= 29) {
                if (token !== 40) {
                  exit$2 = 3;
                } else {
                  var _class$1 = declare_class(env$1, start_loc);
                  match$7 = [
                    _class$1[0],
                    {
                      TAG: /* Class */2,
                      _0: _class$1
                    }
                  ];
                }
              } else {
                exit$2 = token >= 27 ? 4 : 3;
              }
            } else if (token !== 15) {
              exit$2 = token >= 24 ? 4 : 3;
            } else {
              var fn$1 = declare_function(env$1, start_loc);
              match$7 = [
                fn$1[0],
                {
                  TAG: /* Function */1,
                  _0: fn$1
                }
              ];
            }
          } else {
            exit$2 = 3;
          }
          switch (exit$2) {
            case 3 :
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "statement_parser.ml",
                        1121,
                        15
                      ],
                      Error: new Error()
                    };
            case 4 :
                if (typeof token === "number") {
                  if (token !== 27) {
                    if (token !== 28) ; else {
                      parser_env_bs.error(env$1, /* DeclareExportLet */50);
                    }
                  } else {
                    parser_env_bs.error(env$1, /* DeclareExportConst */51);
                  }
                }
                var $$var = declare_var(env$1, start_loc);
                match$7 = [
                  $$var[0],
                  {
                    TAG: /* Variable */0,
                    _0: $$var
                  }
                ];
                break;
            
          }
          return [
                  loc_bs.btwn(start_loc, match$7[0]),
                  {
                    TAG: /* DeclareExportDeclaration */26,
                    _0: {
                      default: false,
                      declaration: match$7[1],
                      specifiers: undefined,
                      source: undefined
                    }
                  }
                ];
      
    }
  };
  var declare_var_statement = function (env, start_loc) {
    var match = declare_var(env, start_loc);
    return [
            match[0],
            {
              TAG: /* DeclareVariable */21,
              _0: match[1]
            }
          ];
  };
  var declare_function_statement = function (env, start_loc) {
    var match = declare_function(env, start_loc);
    return [
            match[0],
            {
              TAG: /* DeclareFunction */22,
              _0: match[1]
            }
          ];
  };
  var type_alias = function (env) {
    if (!parser_env_bs.Peek.is_identifier(1, env)) {
      return curry._1(Parse.statement, env);
    }
    var match = type_alias_helper(env);
    return [
            match[0],
            {
              TAG: /* TypeAlias */7,
              _0: match[1]
            }
          ];
  };
  var module_items = function (env, _module_kind, _acc) {
    while(true) {
      var acc = _acc;
      var module_kind = _module_kind;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        if (match === 2) {
          return [
                  module_kind,
                  list.rev(acc)
                ];
        }
        if (match === 108) {
          return [
                  module_kind,
                  list.rev(acc)
                ];
        }
        
      }
      var stmt = declare(true, env);
      var stmt$1 = stmt[1];
      var loc = stmt[0];
      var module_kind$1;
      if (module_kind !== undefined) {
        if (module_kind.TAG === /* CommonJS */0) {
          if (typeof stmt$1 === "number") {
            module_kind$1 = module_kind;
          } else {
            switch (stmt$1.TAG | 0) {
              case /* DeclareModuleExports */25 :
                  parser_env_bs.error(env, /* DuplicateDeclareModuleExports */60);
                  module_kind$1 = module_kind;
                  break;
              case /* DeclareExportDeclaration */26 :
                  var declaration = stmt$1._0.declaration;
                  if (declaration !== undefined) {
                    switch (declaration.TAG | 0) {
                      case /* NamedType */4 :
                      case /* Interface */5 :
                          break;
                      default:
                        parser_env_bs.error(env, /* AmbiguousDeclareModuleKind */61);
                    }
                  } else {
                    parser_env_bs.error(env, /* AmbiguousDeclareModuleKind */61);
                  }
                  module_kind$1 = module_kind;
                  break;
              default:
                module_kind$1 = module_kind;
            }
          }
        } else if (typeof stmt$1 === "number" || stmt$1.TAG !== /* DeclareModuleExports */25) {
          module_kind$1 = module_kind;
        } else {
          parser_env_bs.error(env, /* AmbiguousDeclareModuleKind */61);
          module_kind$1 = module_kind;
        }
      } else if (typeof stmt$1 === "number") {
        module_kind$1 = module_kind;
      } else {
        switch (stmt$1.TAG | 0) {
          case /* DeclareModuleExports */25 :
              module_kind$1 = {
                TAG: /* CommonJS */0,
                _0: loc
              };
              break;
          case /* DeclareExportDeclaration */26 :
              var declaration$1 = stmt$1._0.declaration;
              if (declaration$1 !== undefined) {
                switch (declaration$1.TAG | 0) {
                  case /* NamedType */4 :
                  case /* Interface */5 :
                      module_kind$1 = module_kind;
                      break;
                  default:
                    module_kind$1 = {
                      TAG: /* ES */1,
                      _0: loc
                    };
                }
              } else {
                module_kind$1 = {
                  TAG: /* ES */1,
                  _0: loc
                };
              }
              break;
          default:
            module_kind$1 = module_kind;
        }
      }
      _acc = {
        hd: stmt,
        tl: acc
      };
      _module_kind = module_kind$1;
      continue ;
    }  };
  var source = function (env) {
    parser_env_bs.Expect.contextual(env, "from");
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match !== "number" && match.TAG === /* T_STRING */1) {
      var match$1 = match._0;
      var octal = match$1[3];
      var raw = match$1[2];
      var value = match$1[1];
      var loc = match$1[0];
      if (octal) {
        parser_env_bs.strict_error(env, /* StrictOctalLiteral */32);
      }
      parser_env_bs.Expect.token(env, {
            TAG: /* T_STRING */1,
            _0: [
              loc,
              value,
              raw,
              octal
            ]
          });
      var value$1 = {
        TAG: /* String */0,
        _0: value
      };
      return [
              loc,
              {
                value: value$1,
                raw: raw
              }
            ];
    }
    var raw$1 = parser_env_bs.Peek.value(undefined, env);
    var value$2 = {
      TAG: /* String */0,
      _0: raw$1
    };
    var ret_0 = parser_env_bs.Peek.loc(undefined, env);
    var ret_1 = {
      value: value$2,
      raw: raw$1
    };
    var ret = [
      ret_0,
      ret_1
    ];
    parser_env_bs.error_unexpected(env);
    return ret;
  };
  var specifier_list = function (_preceding_commaOpt, env, is_type_import, _acc) {
    while(true) {
      var preceding_commaOpt = _preceding_commaOpt;
      var acc = _acc;
      var preceding_comma = preceding_commaOpt !== undefined ? preceding_commaOpt : true;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        if (match === 2) {
          return list.rev(acc);
        }
        if (match === 108) {
          return list.rev(acc);
        }
        
      }
      if (!preceding_comma) {
        parser_env_bs.error_at(env, [
              parser_env_bs.Peek.loc(undefined, env),
              /* ImportSpecifierMissingComma */66
            ]);
      }
      var match$1 = curry._1(Parse.identifier_or_reserved_keyword, env);
      var err = match$1[1];
      var remote = match$1[0];
      var v = remote[1];
      var match$2 = v === "type" ? [
          true,
          /* ImportType */0
        ] : (
          v === "typeof" ? [
              true,
              /* ImportTypeof */1
            ] : [
              false,
              undefined
            ]
        );
      var type_kind = match$2[1];
      var starts_w_type = match$2[0];
      var specifier;
      if (parser_env_bs.Peek.value(undefined, env) === "as") {
        var as_ident = curry._2(Parse.identifier, undefined, env);
        if (starts_w_type && !parser_env_bs.Peek.is_identifier(undefined, env)) {
          if (is_type_import) {
            parser_env_bs.error_at(env, [
                  remote[0],
                  /* ImportTypeShorthandOnlyInPureImport */65
                ]);
          }
          specifier = {
            TAG: /* ImportNamedSpecifier */0,
            _0: {
              kind: type_kind,
              local: undefined,
              remote: as_ident
            }
          };
        } else {
          var local = curry._2(Parse.identifier, undefined, env);
          specifier = {
            TAG: /* ImportNamedSpecifier */0,
            _0: {
              kind: undefined,
              local: local,
              remote: remote
            }
          };
        }
      } else if (starts_w_type && parser_env_bs.Peek.is_identifier(undefined, env)) {
        if (is_type_import) {
          parser_env_bs.error_at(env, [
                remote[0],
                /* ImportTypeShorthandOnlyInPureImport */65
              ]);
        }
        var match$3 = curry._1(Parse.identifier_or_reserved_keyword, env);
        var err$1 = match$3[1];
        if (err$1 !== undefined) {
          parser_env_bs.error_at(env, err$1);
        }
        var local$1 = parser_env_bs.Peek.value(undefined, env) === "as" ? (parser_env_bs.Expect.contextual(env, "as"), curry._2(Parse.identifier, undefined, env)) : undefined;
        specifier = {
          TAG: /* ImportNamedSpecifier */0,
          _0: {
            kind: type_kind,
            local: local$1,
            remote: match$3[0]
          }
        };
      } else {
        if (err !== undefined) {
          parser_env_bs.error_at(env, err);
        }
        specifier = {
          TAG: /* ImportNamedSpecifier */0,
          _0: {
            kind: undefined,
            local: undefined,
            remote: remote
          }
        };
      }
      var preceding_comma$1 = parser_env_bs.Expect.maybe(env, /* T_COMMA */10);
      _acc = {
        hd: specifier,
        tl: acc
      };
      _preceding_commaOpt = preceding_comma$1;
      continue ;
    }  };
  var named_or_namespace_specifier = function (env, is_type_import) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match === "number" && match === 100) {
      parser_env_bs.Expect.token(env, /* T_MULT */100);
      parser_env_bs.Expect.contextual(env, "as");
      var id = curry._2(Parse.identifier, undefined, env);
      return {
              hd: {
                TAG: /* ImportNamespaceSpecifier */2,
                _0: [
                  loc_bs.btwn(start_loc, id[0]),
                  id
                ]
              },
              tl: /* [] */0
            };
    }
    parser_env_bs.Expect.token(env, /* T_LCURLY */1);
    var specifiers = specifier_list(undefined, env, is_type_import, /* [] */0);
    parser_env_bs.Expect.token(env, /* T_RCURLY */2);
    return specifiers;
  };
  var import_declaration = function (env) {
    var env$1 = parser_env_bs.with_strict(true, env);
    var start_loc = parser_env_bs.Peek.loc(undefined, env$1);
    parser_env_bs.Expect.token(env$1, /* T_IMPORT */50);
    var match = parser_env_bs.Peek.token(undefined, env$1);
    var match$1 = typeof match === "number" ? (
        match !== 46 ? (
            match !== 61 ? [
                /* ImportValue */2,
                undefined
              ] : (!parser_env_bs.should_parse_types(env$1) ? parser_env_bs.error(env$1, /* UnexpectedTypeImport */9) : undefined, [
                  /* ImportType */0,
                  curry._2(Parse.identifier, undefined, env$1)
                ])
          ) : (!parser_env_bs.should_parse_types(env$1) ? parser_env_bs.error(env$1, /* UnexpectedTypeImport */9) : undefined, parser_env_bs.Expect.token(env$1, /* T_TYPEOF */46), [
              /* ImportTypeof */1,
              undefined
            ])
      ) : [
        /* ImportValue */2,
        undefined
      ];
    var type_ident = match$1[1];
    var importKind = match$1[0];
    var is_type_import = importKind !== /* ImportValue */2;
    var match$2 = parser_env_bs.Peek.token(undefined, env$1);
    var match$3 = parser_env_bs.Peek.is_identifier(undefined, env$1);
    var exit = 0;
    var exit$1 = 0;
    if (typeof match$2 === "number") {
      if (match$2 === /* T_COMMA */10) {
        exit = 1;
      } else {
        exit$1 = 2;
      }
    } else if (match$2.TAG === /* T_STRING */1) {
      if (importKind === /* ImportValue */2) {
        var match$4 = match$2._0;
        var octal = match$4[3];
        var raw = match$4[2];
        var value = match$4[1];
        var str_loc = match$4[0];
        if (octal) {
          parser_env_bs.strict_error(env$1, /* StrictOctalLiteral */32);
        }
        parser_env_bs.Expect.token(env$1, {
              TAG: /* T_STRING */1,
              _0: [
                str_loc,
                value,
                raw,
                octal
              ]
            });
        var value$1 = {
          TAG: /* String */0,
          _0: value
        };
        var source_1 = {
          value: value$1,
          raw: raw
        };
        var source$1 = [
          str_loc,
          source_1
        ];
        var loc = parser_env_bs.Peek.semicolon_loc(undefined, env$1);
        var end_loc = loc !== undefined ? loc : str_loc;
        parser_env_bs.Eat.semicolon(env$1);
        return [
                loc_bs.btwn(start_loc, end_loc),
                {
                  TAG: /* ImportDeclaration */29,
                  _0: {
                    importKind: importKind,
                    source: source$1,
                    specifiers: /* [] */0
                  }
                }
              ];
      }
      exit$1 = 2;
    } else {
      exit$1 = 2;
    }
    if (exit$1 === 2) {
      if (match$3) {
        exit = 1;
      } else {
        var specifiers = named_or_namespace_specifier(env$1, is_type_import);
        var source$2 = source(env$1);
        var loc$1 = parser_env_bs.Peek.semicolon_loc(undefined, env$1);
        var end_loc$1 = loc$1 !== undefined ? loc$1 : source$2[0];
        parser_env_bs.Eat.semicolon(env$1);
        return [
                loc_bs.btwn(start_loc, end_loc$1),
                {
                  TAG: /* ImportDeclaration */29,
                  _0: {
                    importKind: importKind,
                    source: source$2,
                    specifiers: specifiers
                  }
                }
              ];
      }
    }
    if (exit === 1) {
      var match$5 = parser_env_bs.Peek.token(undefined, env$1);
      var match$6 = parser_env_bs.Peek.value(undefined, env$1);
      var match$7;
      var exit$2 = 0;
      if (type_ident !== undefined && typeof match$5 === "number" && !(match$5 !== 10 && (match$5 !== 0 || match$6 !== "from"))) {
        match$7 = [
          /* ImportValue */2,
          {
            TAG: /* ImportDefaultSpecifier */1,
            _0: type_ident
          }
        ];
      } else {
        exit$2 = 2;
      }
      if (exit$2 === 2) {
        match$7 = [
          importKind,
          {
            TAG: /* ImportDefaultSpecifier */1,
            _0: curry._2(Parse.identifier, undefined, env$1)
          }
        ];
      }
      var match$8 = parser_env_bs.Peek.token(undefined, env$1);
      var additional_specifiers = typeof match$8 === "number" && match$8 === 10 ? (parser_env_bs.Expect.token(env$1, /* T_COMMA */10), named_or_namespace_specifier(env$1, is_type_import)) : /* [] */0;
      var source$3 = source(env$1);
      var loc$2 = parser_env_bs.Peek.semicolon_loc(undefined, env$1);
      var end_loc$2 = loc$2 !== undefined ? loc$2 : source$3[0];
      parser_env_bs.Eat.semicolon(env$1);
      return [
              loc_bs.btwn(start_loc, end_loc$2),
              {
                TAG: /* ImportDeclaration */29,
                _0: {
                  importKind: match$7[0],
                  source: source$3,
                  specifiers: {
                    hd: match$7[1],
                    tl: additional_specifiers
                  }
                }
              }
            ];
    }
    
  };
  var fold = function (acc, _param) {
    while(true) {
      var param = _param;
      var match = param[1];
      switch (match.TAG | 0) {
        case /* Object */0 :
            return list.fold_left((function (acc, prop) {
                          if (prop.TAG === /* Property */0) {
                            return fold(acc, prop._0[1].pattern);
                          } else {
                            return fold(acc, prop._0[1].argument);
                          }
                        }), acc, match._0.properties);
        case /* Array */1 :
            return list.fold_left((function (acc, elem) {
                          if (elem !== undefined) {
                            if (elem.TAG === /* Element */0) {
                              return fold(acc, elem._0);
                            } else {
                              return fold(acc, elem._0[1].argument);
                            }
                          } else {
                            return acc;
                          }
                        }), acc, match._0.elements);
        case /* Assignment */2 :
            _param = match._0.left;
            continue ;
        case /* Identifier */3 :
            return {
                    hd: match._0.name,
                    tl: acc
                  };
        case /* Expression */4 :
            return pervasives.failwith("Parser error: No such thing as an expression pattern!");
        
      }
    }  };
  var empty = function (env) {
    var loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_SEMICOLON */9);
    return [
            loc,
            /* Empty */0
          ];
  };
  var $$break = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_BREAK */32);
    var label;
    if (parser_env_bs.Peek.token(undefined, env) === /* T_SEMICOLON */9 || parser_env_bs.Peek.is_implicit_semicolon(env)) {
      label = undefined;
    } else {
      var label$1 = curry._2(Parse.identifier, undefined, env);
      var name = label$1[1];
      if (!curry._2(SSet$1.mem, name, parser_env_bs.labels(env))) {
        parser_env_bs.error(env, {
              TAG: /* UnknownLabel */4,
              _0: name
            });
      }
      label = label$1;
    }
    var loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc = loc !== undefined ? loc : (
        label !== undefined ? label[0] : start_loc
      );
    var loc$1 = loc_bs.btwn(start_loc, end_loc);
    if (label === undefined && !(parser_env_bs.in_loop(env) || parser_env_bs.in_switch(env))) {
      parser_env_bs.error_at(env, [
            loc$1,
            /* IllegalBreak */23
          ]);
    }
    parser_env_bs.Eat.semicolon(env);
    return [
            loc$1,
            {
              TAG: /* Break */4,
              _0: {
                label: label
              }
            }
          ];
  };
  var $$continue = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_CONTINUE */35);
    var label;
    if (parser_env_bs.Peek.token(undefined, env) === /* T_SEMICOLON */9 || parser_env_bs.Peek.is_implicit_semicolon(env)) {
      label = undefined;
    } else {
      var label$1 = curry._2(Parse.identifier, undefined, env);
      var name = label$1[1];
      if (!curry._2(SSet$1.mem, name, parser_env_bs.labels(env))) {
        parser_env_bs.error(env, {
              TAG: /* UnknownLabel */4,
              _0: name
            });
      }
      label = label$1;
    }
    var loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc = loc !== undefined ? loc : (
        label !== undefined ? label[0] : start_loc
      );
    var loc$1 = loc_bs.btwn(start_loc, end_loc);
    if (!parser_env_bs.in_loop(env)) {
      parser_env_bs.error_at(env, [
            loc$1,
            /* IllegalContinue */22
          ]);
    }
    parser_env_bs.Eat.semicolon(env);
    return [
            loc$1,
            {
              TAG: /* Continue */5,
              _0: {
                label: label
              }
            }
          ];
  };
  var $$debugger = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_DEBUGGER */59);
    var loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc = loc !== undefined ? loc : start_loc;
    parser_env_bs.Eat.semicolon(env);
    return [
            loc_bs.btwn(start_loc, end_loc),
            /* Debugger */1
          ];
  };
  var do_while = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_DO */37);
    var body = curry._1(Parse.statement, parser_env_bs.with_in_loop(true, env));
    parser_env_bs.Expect.token(env, /* T_WHILE */25);
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    var test = curry._1(Parse.expression, env);
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    var loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc$1 = loc !== undefined ? loc : end_loc;
    if (parser_env_bs.Peek.token(undefined, env) === /* T_SEMICOLON */9) {
      parser_env_bs.Eat.semicolon(env);
    }
    return [
            loc_bs.btwn(start_loc, end_loc$1),
            {
              TAG: /* DoWhile */13,
              _0: {
                body: body,
                test: test
              }
            }
          ];
  };
  var assert_can_be_forin_or_forof = function (env, err, param) {
    if (param === undefined) {
      return parser_env_bs.error(env, err);
    }
    if (param.TAG === /* InitDeclaration */0) {
      var match = param._0;
      var declarations = match[1].declarations;
      if (declarations && declarations.hd[1].init === undefined && !declarations.tl) {
        return ;
      }
      return parser_env_bs.error_at(env, [
                  match[0],
                  err
                ]);
    }
    var match$1 = param._0;
    var loc = match$1[0];
    if (!curry._1(Parse.is_assignable_lhs, [
            loc,
            match$1[1]
          ])) {
      return parser_env_bs.error_at(env, [
                  loc,
                  err
                ]);
    }
    
  };
  var _for = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_FOR */39);
    var async = parser_env_bs.allow_await(env) && parser_env_bs.Expect.maybe(env, /* T_AWAIT */64);
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    var match = parser_env_bs.Peek.token(undefined, env);
    var match$1;
    var exit = 0;
    if (typeof match === "number") {
      if (match >= 24) {
        if (match >= 29) {
          exit = 1;
        } else {
          switch (match - 24 | 0) {
            case /* T_IDENTIFIER */0 :
                var match$2 = curry._1(Declaration.$$var, parser_env_bs.with_no_in(true, env));
                match$1 = [
                  {
                    TAG: /* InitDeclaration */0,
                    _0: match$2[0]
                  },
                  match$2[1]
                ];
                break;
            case /* T_LCURLY */1 :
            case /* T_RCURLY */2 :
                exit = 1;
                break;
            case /* T_LCURLYBAR */3 :
                var match$3 = curry._1(Declaration.$$const, parser_env_bs.with_no_in(true, env));
                match$1 = [
                  {
                    TAG: /* InitDeclaration */0,
                    _0: match$3[0]
                  },
                  match$3[1]
                ];
                break;
            case /* T_RCURLYBAR */4 :
                var match$4 = curry._1(Declaration._let, parser_env_bs.with_no_in(true, env));
                match$1 = [
                  {
                    TAG: /* InitDeclaration */0,
                    _0: match$4[0]
                  },
                  match$4[1]
                ];
                break;
            
          }
        }
      } else if (match !== 9) {
        exit = 1;
      } else {
        match$1 = [
          undefined,
          /* [] */0
        ];
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var expr = curry._1(Parse.expression, parser_env_bs.with_no_let(true, parser_env_bs.with_no_in(true, env)));
      match$1 = [
        {
          TAG: /* InitExpression */1,
          _0: expr
        },
        /* [] */0
      ];
    }
    var init = match$1[0];
    var t = parser_env_bs.Peek.token(undefined, env);
    if (t === /* T_OF */62 || async) {
      assert_can_be_forin_or_forof(env, /* InvalidLHSInForOf */18, init);
      var left;
      if (init !== undefined) {
        left = init.TAG === /* InitDeclaration */0 ? ({
              TAG: /* LeftDeclaration */0,
              _0: init._0
            }) : ({
              TAG: /* LeftExpression */1,
              _0: init._0
            });
      } else {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "statement_parser.ml",
                199,
                20
              ],
              Error: new Error()
            };
      }
      parser_env_bs.Expect.token(env, /* T_OF */62);
      var right = curry._1(Parse.assignment, env);
      parser_env_bs.Expect.token(env, /* T_RPAREN */6);
      var body = curry._1(Parse.statement, parser_env_bs.with_in_loop(true, env));
      return [
              loc_bs.btwn(start_loc, body[0]),
              {
                TAG: /* ForOf */16,
                _0: {
                  left: left,
                  right: right,
                  body: body,
                  async: async
                }
              }
            ];
    }
    if (typeof t === "number" && t === 17) {
      assert_can_be_forin_or_forof(env, /* InvalidLHSInForIn */17, init);
      var left$1;
      if (init !== undefined) {
        left$1 = init.TAG === /* InitDeclaration */0 ? ({
              TAG: /* LeftDeclaration */0,
              _0: init._0
            }) : ({
              TAG: /* LeftExpression */1,
              _0: init._0
            });
      } else {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "statement_parser.ml",
                216,
                20
              ],
              Error: new Error()
            };
      }
      parser_env_bs.Expect.token(env, /* T_IN */17);
      var right$1 = curry._1(Parse.expression, env);
      parser_env_bs.Expect.token(env, /* T_RPAREN */6);
      var body$1 = curry._1(Parse.statement, parser_env_bs.with_in_loop(true, env));
      return [
              loc_bs.btwn(start_loc, body$1[0]),
              {
                TAG: /* ForIn */15,
                _0: {
                  left: left$1,
                  right: right$1,
                  body: body$1,
                  each: false
                }
              }
            ];
    }
    list.iter((function (param) {
            return parser_env_bs.error_at(env, param);
          }), match$1[1]);
    parser_env_bs.Expect.token(env, /* T_SEMICOLON */9);
    var match$5 = parser_env_bs.Peek.token(undefined, env);
    var test = typeof match$5 === "number" && match$5 === 9 ? undefined : curry._1(Parse.expression, env);
    parser_env_bs.Expect.token(env, /* T_SEMICOLON */9);
    var match$6 = parser_env_bs.Peek.token(undefined, env);
    var update = typeof match$6 === "number" && match$6 === 6 ? undefined : curry._1(Parse.expression, env);
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    var body$2 = curry._1(Parse.statement, parser_env_bs.with_in_loop(true, env));
    return [
            loc_bs.btwn(start_loc, body$2[0]),
            {
              TAG: /* For */14,
              _0: {
                init: init,
                test: test,
                update: update,
                body: body$2
              }
            }
          ];
  };
  var _if = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_IF */16);
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    var test = curry._1(Parse.expression, env);
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    parser_env_bs.Peek.token(undefined, env);
    var consequent = parser_env_bs.Peek.is_function(undefined, env) ? (parser_env_bs.strict_error(env, /* StrictFunctionStatement */46), curry._1(Declaration._function, env)) : curry._1(Parse.statement, env);
    var alternate = parser_env_bs.Peek.token(undefined, env) === /* T_ELSE */43 ? (parser_env_bs.Expect.token(env, /* T_ELSE */43), curry._1(Parse.statement, env)) : undefined;
    var end_loc = alternate !== undefined ? alternate[0] : consequent[0];
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              TAG: /* If */2,
              _0: {
                test: test,
                consequent: consequent,
                alternate: alternate
              }
            }
          ];
  };
  var $$return = function (env) {
    if (!parser_env_bs.in_function(env)) {
      parser_env_bs.error(env, /* IllegalReturn */24);
    }
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RETURN */19);
    var argument = parser_env_bs.Peek.token(undefined, env) === /* T_SEMICOLON */9 || parser_env_bs.Peek.is_implicit_semicolon(env) ? undefined : curry._1(Parse.expression, env);
    var loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc = loc !== undefined ? loc : (
        argument !== undefined ? argument[0] : start_loc
      );
    parser_env_bs.Eat.semicolon(env);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              TAG: /* Return */9,
              _0: {
                argument: argument
              }
            }
          ];
  };
  var case_list = function (env, _param) {
    while(true) {
      var param = _param;
      var acc = param[1];
      var seen_default = param[0];
      var match = parser_env_bs.Peek.token(undefined, env);
      var exit = 0;
      if (typeof match === "number") {
        if (match === 2) {
          return list.rev(acc);
        }
        if (match === 108) {
          return list.rev(acc);
        }
        exit = 1;
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var start_loc = parser_env_bs.Peek.loc(undefined, env);
        var match$1 = parser_env_bs.Peek.token(undefined, env);
        var test;
        var exit$1 = 0;
        if (typeof match$1 === "number" && match$1 === 36) {
          if (seen_default) {
            parser_env_bs.error(env, /* MultipleDefaultsInSwitch */20);
          }
          parser_env_bs.Expect.token(env, /* T_DEFAULT */36);
          test = undefined;
        } else {
          exit$1 = 2;
        }
        if (exit$1 === 2) {
          parser_env_bs.Expect.token(env, /* T_CASE */33);
          test = curry._1(Parse.expression, env);
        }
        var seen_default$1 = seen_default || test === undefined;
        var end_loc = parser_env_bs.Peek.loc(undefined, env);
        parser_env_bs.Expect.token(env, /* T_COLON */80);
        var term_fn = function (param) {
          if (typeof param !== "number") {
            return false;
          }
          var switcher = param - 2 | 0;
          if (switcher > 31 || switcher < 0) {
            return switcher === 34;
          } else {
            return switcher > 30 || switcher < 1;
          }
        };
        var consequent = curry._2(Parse.statement_list, term_fn, parser_env_bs.with_in_switch(true, env));
        var match$2 = list.rev(consequent);
        var end_loc$1 = match$2 ? match$2.hd[0] : end_loc;
        var acc_0 = [
          loc_bs.btwn(start_loc, end_loc$1),
          {
            test: test,
            consequent: consequent
          }
        ];
        var acc$1 = {
          hd: acc_0,
          tl: acc
        };
        _param = [
          seen_default$1,
          acc$1
        ];
        continue ;
      }
      
    }  };
  var $$switch = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_SWITCH */20);
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    var discriminant = curry._1(Parse.expression, env);
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    parser_env_bs.Expect.token(env, /* T_LCURLY */1);
    var cases = case_list(env, [
          false,
          /* [] */0
        ]);
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RCURLY */2);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              TAG: /* Switch */8,
              _0: {
                discriminant: discriminant,
                cases: cases
              }
            }
          ];
  };
  var $$throw = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_THROW */22);
    if (parser_env_bs.Peek.is_line_terminator(env)) {
      parser_env_bs.error_at(env, [
            start_loc,
            /* NewlineAfterThrow */12
          ]);
    }
    var argument = curry._1(Parse.expression, env);
    var loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc = loc !== undefined ? loc : argument[0];
    parser_env_bs.Eat.semicolon(env);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              TAG: /* Throw */10,
              _0: {
                argument: argument
              }
            }
          ];
  };
  var _try = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_TRY */23);
    var block = curry._1(Parse.block_body, env);
    var match = parser_env_bs.Peek.token(undefined, env);
    var handler;
    if (typeof match === "number" && match === 34) {
      var start_loc$1 = parser_env_bs.Peek.loc(undefined, env);
      parser_env_bs.Expect.token(env, /* T_CATCH */34);
      parser_env_bs.Expect.token(env, /* T_LPAREN */5);
      var id = curry._2(Parse.identifier, /* StrictCatchVariable */27, env);
      var param_0 = id[0];
      var param_1 = {
        TAG: /* Identifier */3,
        _0: {
          name: id,
          typeAnnotation: undefined,
          optional: false
        }
      };
      var param = [
        param_0,
        param_1
      ];
      parser_env_bs.Expect.token(env, /* T_RPAREN */6);
      var body = curry._1(Parse.block_body, env);
      var loc = loc_bs.btwn(start_loc$1, body[0]);
      handler = [
        loc,
        {
          param: param,
          body: body
        }
      ];
    } else {
      handler = undefined;
    }
    var match$1 = parser_env_bs.Peek.token(undefined, env);
    var finalizer = typeof match$1 === "number" && match$1 === 38 ? (parser_env_bs.Expect.token(env, /* T_FINALLY */38), curry._1(Parse.block_body, env)) : undefined;
    var end_loc = finalizer !== undefined ? finalizer[0] : (
        handler !== undefined ? handler[0] : (parser_env_bs.error_at(env, [
                  block[0],
                  /* NoCatchOrFinally */21
                ]), block[0])
      );
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              TAG: /* Try */11,
              _0: {
                block: block,
                handler: handler,
                finalizer: finalizer
              }
            }
          ];
  };
  var var_or_const = function (env) {
    var match = curry._1(Declaration.variable, env);
    var match$1 = match[0];
    var start_loc = match$1[0];
    var end_loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc$1 = end_loc !== undefined ? end_loc : start_loc;
    parser_env_bs.Eat.semicolon(env);
    list.iter((function (param) {
            return parser_env_bs.error_at(env, param);
          }), match[1]);
    return [
            loc_bs.btwn(start_loc, end_loc$1),
            match$1[1]
          ];
  };
  var _let = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_LET */28);
    var match = curry._1(Declaration.variable_declaration_list, parser_env_bs.with_no_let(true, env));
    var declaration = {
      TAG: /* VariableDeclaration */18,
      _0: {
        declarations: match[1],
        kind: /* Let */1
      }
    };
    var end_loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc$1 = end_loc !== undefined ? end_loc : match[0];
    parser_env_bs.Eat.semicolon(env);
    list.iter((function (param) {
            return parser_env_bs.error_at(env, param);
          }), match[2]);
    return [
            loc_bs.btwn(start_loc, end_loc$1),
            declaration
          ];
  };
  var _while = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_WHILE */25);
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    var test = curry._1(Parse.expression, env);
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    var body = curry._1(Parse.statement, parser_env_bs.with_in_loop(true, env));
    return [
            loc_bs.btwn(start_loc, body[0]),
            {
              TAG: /* While */12,
              _0: {
                test: test,
                body: body
              }
            }
          ];
  };
  var _with = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_WITH */26);
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    var _object = curry._1(Parse.expression, env);
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    var body = curry._1(Parse.statement, env);
    var loc = loc_bs.btwn(start_loc, body[0]);
    parser_env_bs.strict_error_at(env, [
          loc,
          /* StrictModeWith */26
        ]);
    return [
            loc,
            {
              TAG: /* With */6,
              _0: {
                _object: _object,
                body: body
              }
            }
          ];
  };
  var block = function (env) {
    var match = curry._1(Parse.block_body, env);
    return [
            match[0],
            {
              TAG: /* Block */0,
              _0: match[1]
            }
          ];
  };
  var maybe_labeled = function (env) {
    var expr = curry._1(Parse.expression, env);
    var match = parser_env_bs.Peek.token(undefined, env);
    var label = expr[1];
    var loc = expr[0];
    if (typeof label !== "number" && label.TAG === /* Identifier */17 && typeof match === "number" && match === 80) {
      var label$1 = label._0;
      var name = label$1[1];
      parser_env_bs.Expect.token(env, /* T_COLON */80);
      if (curry._2(SSet$1.mem, name, parser_env_bs.labels(env))) {
        parser_env_bs.error_at(env, [
              loc,
              {
                TAG: /* Redeclaration */5,
                _0: "Label",
                _1: name
              }
            ]);
      }
      var env$1 = parser_env_bs.add_label(env, name);
      var labeled_stmt = curry._1(Parse.statement, env$1);
      return [
              loc_bs.btwn(loc, labeled_stmt[0]),
              {
                TAG: /* Labeled */3,
                _0: {
                  label: label$1,
                  body: labeled_stmt
                }
              }
            ];
    }
    var loc$1 = parser_env_bs.Peek.semicolon_loc(undefined, env);
    var end_loc = loc$1 !== undefined ? loc$1 : expr[0];
    parser_env_bs.Eat.semicolon(env);
    return [
            loc_bs.btwn(expr[0], end_loc),
            {
              TAG: /* Expression */1,
              _0: {
                expression: expr,
                directive: undefined
              }
            }
          ];
  };
  var export_declaration = function (env, decorators) {
    var env$1 = parser_env_bs.with_in_export(true, parser_env_bs.with_strict(true, env));
    var start_loc = parser_env_bs.Peek.loc(undefined, env$1);
    parser_env_bs.Expect.token(env$1, /* T_EXPORT */49);
    var match = parser_env_bs.Peek.token(undefined, env$1);
    var exit = 0;
    if (typeof match === "number") {
      if (match >= 53) {
        if (match !== 100) {
          if (match >= 64) {
            exit = 1;
          } else {
            switch (match - 53 | 0) {
              case /* T_IDENTIFIER */0 :
                  if (!parser_env_bs.should_parse_types(env$1)) {
                    parser_env_bs.error(env$1, /* UnexpectedTypeExport */10);
                  }
                  var $$interface$1 = $$interface(env$1);
                  var match$1 = $$interface$1[1];
                  if (typeof match$1 === "number" || match$1.TAG !== /* InterfaceDeclaration */20) {
                    pervasives.failwith("Internal Flow Error! Parsed `export interface` into something other than an interface declaration!");
                  } else {
                    parser_env_bs.record_export(env$1, [
                          $$interface$1[0],
                          extract_ident_name(match$1._0.id)
                        ]);
                  }
                  var end_loc = $$interface$1[0];
                  return [
                          loc_bs.btwn(start_loc, end_loc),
                          {
                            TAG: /* ExportNamedDeclaration */27,
                            _0: {
                              declaration: $$interface$1,
                              specifiers: undefined,
                              source: undefined,
                              exportKind: /* ExportType */0
                            }
                          }
                        ];
              case /* T_RBRACKET */8 :
                  if (parser_env_bs.Peek.token(1, env$1) !== /* T_LCURLY */1) {
                    if (!parser_env_bs.should_parse_types(env$1)) {
                      parser_env_bs.error(env$1, /* UnexpectedTypeExport */10);
                    }
                    var type_alias$1 = type_alias(env$1);
                    var match$2 = type_alias$1[1];
                    if (typeof match$2 === "number" || match$2.TAG !== /* TypeAlias */7) {
                      pervasives.failwith("Internal Flow Error! Parsed `export type` into something other than a type alias!");
                    } else {
                      parser_env_bs.record_export(env$1, [
                            type_alias$1[0],
                            extract_ident_name(match$2._0.id)
                          ]);
                    }
                    var end_loc$1 = type_alias$1[0];
                    return [
                            loc_bs.btwn(start_loc, end_loc$1),
                            {
                              TAG: /* ExportNamedDeclaration */27,
                              _0: {
                                declaration: type_alias$1,
                                specifiers: undefined,
                                source: undefined,
                                exportKind: /* ExportType */0
                              }
                            }
                          ];
                  }
                  exit = 1;
                  break;
              case /* T_LCURLY */1 :
              case /* T_RCURLY */2 :
              case /* T_LCURLYBAR */3 :
              case /* T_RCURLYBAR */4 :
              case /* T_LPAREN */5 :
              case /* T_RPAREN */6 :
              case /* T_LBRACKET */7 :
              case /* T_SEMICOLON */9 :
                  exit = 1;
                  break;
              case /* T_COMMA */10 :
                  exit = 2;
                  break;
              
            }
          }
        } else {
          var loc = parser_env_bs.Peek.loc(undefined, env$1);
          parser_env_bs.Expect.token(env$1, /* T_MULT */100);
          var parse_export_star_as = parser_env_bs.parse_options(env$1).esproposal_export_star_as;
          var local_name = parser_env_bs.Peek.value(undefined, env$1) === "as" ? (parser_env_bs.Expect.contextual(env$1, "as"), parse_export_star_as ? curry._2(Parse.identifier, undefined, env$1) : (parser_env_bs.error(env$1, /* UnexpectedTypeDeclaration */8), undefined)) : undefined;
          var specifiers = {
            TAG: /* ExportBatchSpecifier */1,
            _0: loc,
            _1: local_name
          };
          var source = export_source(env$1);
          var loc$1 = parser_env_bs.Peek.semicolon_loc(undefined, env$1);
          var end_loc$2 = loc$1 !== undefined ? loc$1 : source[0];
          var source$1 = source;
          parser_env_bs.Eat.semicolon(env$1);
          return [
                  loc_bs.btwn(start_loc, end_loc$2),
                  {
                    TAG: /* ExportNamedDeclaration */27,
                    _0: {
                      declaration: undefined,
                      specifiers: specifiers,
                      source: source$1,
                      exportKind: /* ExportValue */1
                    }
                  }
                ];
        }
      } else {
        switch (match) {
          case /* T_DEFAULT */36 :
              parser_env_bs.Expect.token(env$1, /* T_DEFAULT */36);
              parser_env_bs.record_export(env$1, [
                    loc_bs.btwn(start_loc, parser_env_bs.Peek.loc(undefined, env$1)),
                    "default"
                  ]);
              var match$3 = parser_env_bs.Peek.token(undefined, env$1);
              var match$4;
              var exit$1 = 0;
              if (typeof match$3 === "number" && match$3 === 15) {
                var fn = curry._1(Declaration._function, env$1);
                match$4 = [
                  fn[0],
                  {
                    TAG: /* Declaration */0,
                    _0: fn
                  }
                ];
              } else {
                exit$1 = 3;
              }
              if (exit$1 === 3) {
                if (parser_env_bs.Peek.is_class(undefined, env$1)) {
                  var _class = curry._2($$Object.class_declaration, env$1, decorators);
                  match$4 = [
                    _class[0],
                    {
                      TAG: /* Declaration */0,
                      _0: _class
                    }
                  ];
                } else {
                  var expr = curry._1(Parse.assignment, env$1);
                  var loc$2 = parser_env_bs.Peek.semicolon_loc(undefined, env$1);
                  var end_loc$3 = loc$2 !== undefined ? loc$2 : expr[0];
                  parser_env_bs.Eat.semicolon(env$1);
                  match$4 = [
                    end_loc$3,
                    {
                      TAG: /* Expression */1,
                      _0: expr
                    }
                  ];
                }
              }
              return [
                      loc_bs.btwn(start_loc, match$4[0]),
                      {
                        TAG: /* ExportDefaultDeclaration */28,
                        _0: {
                          declaration: match$4[1],
                          exportKind: /* ExportValue */1
                        }
                      }
                    ];
          case /* T_IF */16 :
          case /* T_IN */17 :
          case /* T_INSTANCEOF */18 :
          case /* T_RETURN */19 :
          case /* T_SWITCH */20 :
          case /* T_THIS */21 :
          case /* T_THROW */22 :
          case /* T_TRY */23 :
          case /* T_WHILE */25 :
          case /* T_WITH */26 :
          case /* T_NULL */29 :
          case /* T_FALSE */30 :
          case /* T_TRUE */31 :
          case /* T_BREAK */32 :
          case /* T_CASE */33 :
          case /* T_CATCH */34 :
          case /* T_CONTINUE */35 :
          case /* T_DO */37 :
          case /* T_FINALLY */38 :
          case /* T_FOR */39 :
              exit = 1;
              break;
          case /* T_AT */14 :
          case /* T_FUNCTION */15 :
          case /* T_VAR */24 :
          case /* T_CONST */27 :
          case /* T_LET */28 :
          case /* T_CLASS */40 :
              exit = 2;
              break;
          default:
            exit = 1;
        }
      }
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 :
          var match$5 = parser_env_bs.Peek.token(undefined, env$1);
          var exportKind = typeof match$5 === "number" && match$5 === 61 ? (parser_env_bs.Eat.token(env$1), /* ExportType */0) : /* ExportValue */1;
          parser_env_bs.Expect.token(env$1, /* T_LCURLY */1);
          var match$6 = export_specifiers_and_errs(env$1, /* [] */0, /* [] */0);
          var specifiers$1 = {
            TAG: /* ExportSpecifiers */0,
            _0: match$6[0]
          };
          var end_loc$4 = parser_env_bs.Peek.loc(undefined, env$1);
          parser_env_bs.Expect.token(env$1, /* T_RCURLY */2);
          var source$2 = parser_env_bs.Peek.value(undefined, env$1) === "from" ? export_source(env$1) : (list.iter((function (param) {
                      return parser_env_bs.error_at(env$1, param);
                    }), match$6[1]), undefined);
          var loc$3 = parser_env_bs.Peek.semicolon_loc(undefined, env$1);
          var end_loc$5 = loc$3 !== undefined ? loc$3 : (
              source$2 !== undefined ? source$2[0] : end_loc$4
            );
          parser_env_bs.Eat.semicolon(env$1);
          return [
                  loc_bs.btwn(start_loc, end_loc$5),
                  {
                    TAG: /* ExportNamedDeclaration */27,
                    _0: {
                      declaration: undefined,
                      specifiers: specifiers$1,
                      source: source$2,
                      exportKind: exportKind
                    }
                  }
                ];
      case 2 :
          var stmt = curry._2(Parse.statement_list_item, decorators, env$1);
          var match$7 = stmt[1];
          var loc$4 = stmt[0];
          var names;
          if (typeof match$7 === "number") {
            names = pervasives.failwith("Internal Flow Error! Unexpected export statement declaration!");
          } else {
            switch (match$7.TAG | 0) {
              case /* FunctionDeclaration */17 :
                  var id = match$7._0.id;
                  if (id !== undefined) {
                    names = {
                      hd: [
                        loc$4,
                        extract_ident_name(id)
                      ],
                      tl: /* [] */0
                    };
                  } else {
                    parser_env_bs.error_at(env$1, [
                          loc$4,
                          /* ExportNamelessFunction */56
                        ]);
                    names = /* [] */0;
                  }
                  break;
              case /* VariableDeclaration */18 :
                  names = list.fold_left((function (names, param) {
                          var id = param[1].id;
                          var param$1 = {
                            hd: id,
                            tl: /* [] */0
                          };
                          return list.fold_left(fold, names, param$1);
                        }), /* [] */0, match$7._0.declarations);
                  break;
              case /* ClassDeclaration */19 :
                  var id$1 = match$7._0.id;
                  if (id$1 !== undefined) {
                    names = {
                      hd: [
                        loc$4,
                        extract_ident_name(id$1)
                      ],
                      tl: /* [] */0
                    };
                  } else {
                    parser_env_bs.error_at(env$1, [
                          loc$4,
                          /* ExportNamelessClass */55
                        ]);
                    names = /* [] */0;
                  }
                  break;
              default:
                names = pervasives.failwith("Internal Flow Error! Unexpected export statement declaration!");
            }
          }
          list.iter((function (param) {
                  return parser_env_bs.record_export(env$1, param);
                }), names);
          return [
                  loc_bs.btwn(start_loc, stmt[0]),
                  {
                    TAG: /* ExportNamedDeclaration */27,
                    _0: {
                      declaration: stmt,
                      specifiers: undefined,
                      source: undefined,
                      exportKind: /* ExportValue */1
                    }
                  }
                ];
      
    }
  };
  return {
          _for: _for,
          _if: _if,
          _let: _let,
          _try: _try,
          _while: _while,
          _with: _with,
          block: block,
          $$break: $$break,
          $$continue: $$continue,
          $$debugger: $$debugger,
          declare: declare,
          declare_export_declaration: declare_export_declaration,
          do_while: do_while,
          empty: empty,
          export_declaration: export_declaration,
          expression: expression,
          import_declaration: import_declaration,
          $$interface: $$interface,
          maybe_labeled: maybe_labeled,
          $$return: $$return,
          $$switch: $$switch,
          $$throw: $$throw,
          type_alias: type_alias,
          var_or_const: var_or_const
        };
}

var Token$6;

var Ast$5;

var $$Error$7;

var Token_1$6 = Token$6;
var Ast_1$5 = Ast$5;
var $$Error_1$7 = $$Error$7;
var SSet_1$1 = SSet$1;
var Statement_1 = Statement;
/* SSet Not a pure module */

var statement_parser_bs = {
	Token: Token_1$6,
	Ast: Ast_1$5,
	$$Error: $$Error_1$7,
	SSet: SSet_1$1,
	Statement: Statement_1
};

function Expression(Parse, Type, Declaration) {
  var is_tighter = function (a, b) {
    var a_prec;
    a_prec = a.TAG === /* Left_assoc */0 ? a._0 : a._0 - 1 | 0;
    return a_prec >= b._0;
  };
  var is_lhs = function (param) {
    var tmp = param[1];
    if (typeof tmp === "number") {
      return false;
    }
    switch (tmp.TAG | 0) {
      case /* Member */13 :
      case /* Identifier */17 :
      case /* MetaProperty */24 :
          return true;
      default:
        return false;
    }
  };
  var is_assignable_lhs = function (param) {
    var tmp = param[1];
    if (typeof tmp === "number") {
      return false;
    }
    switch (tmp.TAG | 0) {
      case /* Array */0 :
      case /* Object */1 :
      case /* Member */13 :
      case /* Identifier */17 :
      case /* MetaProperty */24 :
          return true;
      default:
        return false;
    }
  };
  var assignment_op = function (env) {
    var match = parser_env_bs.Peek.token(undefined, env);
    var op;
    if (typeof match === "number") {
      switch (match) {
        case /* T_RSHIFT3_ASSIGN */66 :
            op = /* RShift3Assign */9;
            break;
        case /* T_RSHIFT_ASSIGN */67 :
            op = /* RShiftAssign */8;
            break;
        case /* T_LSHIFT_ASSIGN */68 :
            op = /* LShiftAssign */7;
            break;
        case /* T_BIT_XOR_ASSIGN */69 :
            op = /* BitXorAssign */11;
            break;
        case /* T_BIT_OR_ASSIGN */70 :
            op = /* BitOrAssign */10;
            break;
        case /* T_BIT_AND_ASSIGN */71 :
            op = /* BitAndAssign */12;
            break;
        case /* T_MOD_ASSIGN */72 :
            op = /* ModAssign */6;
            break;
        case /* T_DIV_ASSIGN */73 :
            op = /* DivAssign */5;
            break;
        case /* T_MULT_ASSIGN */74 :
            op = /* MultAssign */3;
            break;
        case /* T_EXP_ASSIGN */75 :
            op = /* ExpAssign */4;
            break;
        case /* T_MINUS_ASSIGN */76 :
            op = /* MinusAssign */2;
            break;
        case /* T_PLUS_ASSIGN */77 :
            op = /* PlusAssign */1;
            break;
        case /* T_ASSIGN */78 :
            op = /* Assign */0;
            break;
        default:
          op = undefined;
      }
    } else {
      op = undefined;
    }
    if (op !== undefined) {
      parser_env_bs.Eat.token(env);
    }
    return op;
  };
  var conditional = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var expr = curry._1(logical, env);
    if (parser_env_bs.Peek.token(undefined, env) !== /* T_PLING */79) {
      return expr;
    }
    parser_env_bs.Expect.token(env, /* T_PLING */79);
    var env$prime = parser_env_bs.with_no_in(false, env);
    var consequent = curry._1(assignment, env$prime);
    parser_env_bs.Expect.token(env, /* T_COLON */80);
    var match = parser_common_bs.with_loc(assignment, env);
    var loc = loc_bs.btwn(start_loc, match[0]);
    return [
            loc,
            {
              TAG: /* Conditional */10,
              _0: {
                test: expr,
                consequent: consequent,
                alternate: match[1]
              }
            }
          ];
  };
  var peek_unary_op = function (env) {
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match !== "number") {
      return ;
    }
    if (match >= 48) {
      if (match < 97) {
        if (match !== 64 || !parser_env_bs.allow_await(env)) {
          return ;
        } else {
          return /* Await */7;
        }
      }
      if (match >= 105) {
        return ;
      }
      switch (match - 97 | 0) {
        case /* T_IDENTIFIER */0 :
            return /* Plus */1;
        case /* T_LCURLY */1 :
            return /* Minus */0;
        case /* T_RCURLY */2 :
        case /* T_LCURLYBAR */3 :
        case /* T_RCURLYBAR */4 :
        case /* T_LPAREN */5 :
            return ;
        case /* T_RPAREN */6 :
            return /* Not */2;
        case /* T_LBRACKET */7 :
            return /* BitNot */3;
        
      }
    } else {
      if (match < 45) {
        return ;
      }
      switch (match - 45 | 0) {
        case /* T_IDENTIFIER */0 :
            return /* Delete */6;
        case /* T_LCURLY */1 :
            return /* Typeof */4;
        case /* T_RCURLY */2 :
            return /* Void */5;
        
      }
    }
  };
  var unary = function (env) {
    var begin_loc = parser_env_bs.Peek.loc(undefined, env);
    var op = peek_unary_op(env);
    if (op !== undefined) {
      parser_env_bs.Eat.token(env);
      var argument = unary(env);
      var loc = loc_bs.btwn(begin_loc, argument[0]);
      if (op === 6) {
        var tmp = argument[1];
        if (typeof tmp !== "number" && tmp.TAG === /* Identifier */17) {
          parser_env_bs.strict_error_at(env, [
                loc,
                /* StrictDelete */33
              ]);
        }
        
      }
      return [
              loc,
              {
                TAG: /* Unary */5,
                _0: {
                  operator: op,
                  prefix: true,
                  argument: argument
                }
              }
            ];
    }
    var match = parser_env_bs.Peek.token(undefined, env);
    var op$1 = typeof match === "number" ? (
        match !== 105 ? (
            match !== 106 ? undefined : /* Decrement */1
          ) : /* Increment */0
      ) : undefined;
    if (op$1 === undefined) {
      var argument$1 = left_hand_side(env);
      if (parser_env_bs.Peek.is_line_terminator(env)) {
        return argument$1;
      }
      var match$1 = parser_env_bs.Peek.token(undefined, env);
      var op$2 = typeof match$1 === "number" ? (
          match$1 !== 105 ? (
              match$1 !== 106 ? undefined : /* Decrement */1
            ) : /* Increment */0
        ) : undefined;
      if (op$2 === undefined) {
        return argument$1;
      }
      if (!is_lhs(argument$1)) {
        parser_env_bs.error_at(env, [
              argument$1[0],
              /* InvalidLHSInAssignment */15
            ]);
      }
      var match$2 = argument$1[1];
      if (typeof match$2 !== "number" && match$2.TAG === /* Identifier */17) {
        if (parser_env_bs.is_restricted(match$2._0[1])) {
          parser_env_bs.strict_error(env, /* StrictLHSPostfix */38);
        }
        
      }
      var end_loc = parser_env_bs.Peek.loc(undefined, env);
      parser_env_bs.Eat.token(env);
      return [
              loc_bs.btwn(argument$1[0], end_loc),
              {
                TAG: /* Update */8,
                _0: {
                  operator: op$2,
                  argument: argument$1,
                  prefix: false
                }
              }
            ];
    }
    parser_env_bs.Eat.token(env);
    var argument$2 = unary(env);
    if (!is_lhs(argument$2)) {
      parser_env_bs.error_at(env, [
            argument$2[0],
            /* InvalidLHSInAssignment */15
          ]);
    }
    var match$3 = argument$2[1];
    if (typeof match$3 !== "number" && match$3.TAG === /* Identifier */17) {
      if (parser_env_bs.is_restricted(match$3._0[1])) {
        parser_env_bs.strict_error(env, /* StrictLHSPrefix */39);
      }
      
    }
    return [
            loc_bs.btwn(begin_loc, argument$2[0]),
            {
              TAG: /* Update */8,
              _0: {
                operator: op$1,
                argument: argument$2,
                prefix: true
              }
            }
          ];
  };
  var left_hand_side = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var allow_new = !parser_env_bs.no_new(env);
    var env$1 = parser_env_bs.with_no_new(false, env);
    var match = parser_env_bs.Peek.token(undefined, env$1);
    var expr;
    var exit = 0;
    if (typeof match === "number" && !(match !== 44 || !allow_new)) {
      expr = new_expression(env$1);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      expr = parser_env_bs.Peek.is_function(undefined, env$1) ? _function(env$1) : primary(env$1);
    }
    var expr$1 = member(env$1, start_loc, expr);
    var part = parser_env_bs.Peek.token(undefined, env$1);
    if (typeof part === "number") {
      if (part === /* T_LPAREN */5) {
        return call(env$1, start_loc, expr$1);
      } else {
        return expr$1;
      }
    } else if (part.TAG === /* T_TEMPLATE_PART */2) {
      return member(env$1, start_loc, tagged_template(env$1, start_loc, expr$1, part._0));
    } else {
      return expr$1;
    }
  };
  var call = function (env, start_loc, _left) {
    while(true) {
      var left = _left;
      var part = parser_env_bs.Peek.token(undefined, env);
      if (typeof part !== "number") {
        if (part.TAG === /* T_TEMPLATE_PART */2) {
          return tagged_template(env, start_loc, left, part._0);
        } else {
          return left;
        }
      }
      switch (part) {
        case /* T_LPAREN */5 :
            if (parser_env_bs.no_call(env)) {
              return left;
            }
            var match = curry._1($$arguments, env);
            var loc = loc_bs.btwn(start_loc, match[0]);
            _left = [
              loc,
              {
                TAG: /* Call */12,
                _0: {
                  callee: left,
                  arguments: match[1]
                }
              }
            ];
            continue ;
        case /* T_LBRACKET */7 :
            parser_env_bs.Expect.token(env, /* T_LBRACKET */7);
            var expr = curry._1(Parse.expression, env);
            var last_loc = parser_env_bs.Peek.loc(undefined, env);
            var loc$1 = loc_bs.btwn(start_loc, last_loc);
            parser_env_bs.Expect.token(env, /* T_RBRACKET */8);
            _left = [
              loc$1,
              {
                TAG: /* Member */13,
                _0: {
                  _object: left,
                  property: {
                    TAG: /* PropertyExpression */1,
                    _0: expr
                  },
                  computed: true
                }
              }
            ];
            continue ;
        case /* T_PERIOD */11 :
            parser_env_bs.Expect.token(env, /* T_PERIOD */11);
            var match$1 = identifier_or_reserved_keyword(env);
            var id = match$1[0];
            var loc$2 = loc_bs.btwn(start_loc, id[0]);
            _left = [
              loc$2,
              {
                TAG: /* Member */13,
                _0: {
                  _object: left,
                  property: {
                    TAG: /* PropertyIdentifier */0,
                    _0: id
                  },
                  computed: false
                }
              }
            ];
            continue ;
        default:
          return left;
      }
    }  };
  var new_expression = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_NEW */44);
    if (parser_env_bs.in_function(env) && parser_env_bs.Peek.token(undefined, env) === /* T_PERIOD */11) {
      parser_env_bs.Expect.token(env, /* T_PERIOD */11);
      var meta = [
        start_loc,
        "new"
      ];
      if (parser_env_bs.Peek.value(undefined, env) === "target") {
        var property = curry._2(Parse.identifier, undefined, env);
        var end_loc = property[0];
        return [
                loc_bs.btwn(start_loc, end_loc),
                {
                  TAG: /* MetaProperty */24,
                  _0: {
                    meta: meta,
                    property: property
                  }
                }
              ];
      }
      parser_env_bs.error_unexpected(env);
      parser_env_bs.Eat.token(env);
      return [
              start_loc,
              {
                TAG: /* Identifier */17,
                _0: meta
              }
            ];
    }
    var callee_loc = parser_env_bs.Peek.loc(undefined, env);
    var match = parser_env_bs.Peek.token(undefined, env);
    var expr;
    var exit = 0;
    if (typeof match === "number" && match === 44) {
      expr = new_expression(env);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      expr = parser_env_bs.Peek.is_function(undefined, env) ? _function(env) : primary(env);
    }
    var callee = member(parser_env_bs.with_no_call(true, env), callee_loc, expr);
    var part = parser_env_bs.Peek.token(undefined, env);
    var callee$1;
    callee$1 = typeof part === "number" || part.TAG !== /* T_TEMPLATE_PART */2 ? callee : tagged_template(env, callee_loc, callee, part._0);
    var match$1 = parser_env_bs.Peek.token(undefined, env);
    var match$2 = typeof match$1 === "number" && match$1 === 5 ? curry._1($$arguments, env) : [
        callee$1[0],
        /* [] */0
      ];
    return [
            loc_bs.btwn(start_loc, match$2[0]),
            {
              TAG: /* New */11,
              _0: {
                callee: callee$1,
                arguments: match$2[1]
              }
            }
          ];
  };
  var member = function (env, start_loc, left) {
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match !== "number") {
      return left;
    }
    if (match !== 7) {
      if (match !== 11) {
        return left;
      }
      parser_env_bs.Expect.token(env, /* T_PERIOD */11);
      var match$1 = identifier_or_reserved_keyword(env);
      var id = match$1[0];
      var loc = loc_bs.btwn(start_loc, id[0]);
      return call(env, start_loc, [
                  loc,
                  {
                    TAG: /* Member */13,
                    _0: {
                      _object: left,
                      property: {
                        TAG: /* PropertyIdentifier */0,
                        _0: id
                      },
                      computed: false
                    }
                  }
                ]);
    }
    parser_env_bs.Expect.token(env, /* T_LBRACKET */7);
    var expr = curry._1(Parse.expression, parser_env_bs.with_no_call(false, env));
    var last_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RBRACKET */8);
    var loc$1 = loc_bs.btwn(start_loc, last_loc);
    return call(env, start_loc, [
                loc$1,
                {
                  TAG: /* Member */13,
                  _0: {
                    _object: left,
                    property: {
                      TAG: /* PropertyExpression */1,
                      _0: expr
                    },
                    computed: true
                  }
                }
              ]);
  };
  var _function = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var async = curry._1(Declaration.async, env);
    parser_env_bs.Expect.token(env, /* T_FUNCTION */15);
    var generator = curry._1(Declaration.generator, env);
    var match;
    if (parser_env_bs.Peek.token(undefined, env) === /* T_LPAREN */5) {
      match = [
        undefined,
        undefined
      ];
    } else {
      var match$1 = parser_env_bs.Peek.token(undefined, env);
      var id = typeof match$1 === "number" && match$1 === 92 ? undefined : curry._2(Parse.identifier, /* StrictFunctionName */31, env);
      match = [
        id,
        curry._1(Type.type_parameter_declaration, env)
      ];
    }
    var id$1 = match[0];
    var params = curry._1(Declaration.function_params, env);
    var match$2 = curry._1(Type.annotation_and_predicate_opt, env);
    var match$3 = curry._3(Declaration.function_body, env, async, generator);
    var body = match$3[1];
    var simple = curry._1(Declaration.is_simple_function_params, params);
    curry._5(Declaration.strict_post_check, env, match$3[2], simple, id$1, params);
    var expression;
    expression = body.TAG === /* BodyBlock */0 ? false : true;
    return [
            loc_bs.btwn(start_loc, match$3[0]),
            {
              TAG: /* Function */2,
              _0: {
                id: id$1,
                params: params,
                body: body,
                async: async,
                generator: generator,
                predicate: match$2[1],
                expression: expression,
                returnType: match$2[0],
                typeParameters: match[1]
              }
            }
          ];
  };
  var number = function (env, number_type) {
    var value = parser_env_bs.Peek.value(undefined, env);
    var value$1;
    if (number_type !== 0) {
      switch (number_type - 1 | 0) {
        case /* BINARY */0 :
            parser_env_bs.strict_error(env, /* StrictOctalLiteral */32);
            value$1 = caml_int64.to_float(caml_format.caml_int64_of_string("0o" + value));
            break;
        case /* LEGACY_OCTAL */1 :
            value$1 = caml_int64.to_float(caml_format.caml_int64_of_string(value));
            break;
        case /* OCTAL */2 :
            try {
              value$1 = lexer_flow_bs.FloatOfString.float_of_string(value);
            }
            catch (exn){
              if (sys.win32) {
                parser_env_bs.error(env, /* WindowsFloatOfString */59);
                value$1 = 789.0;
              } else {
                throw exn;
              }
            }
            break;
        
      }
    } else {
      value$1 = caml_int64.to_float(caml_format.caml_int64_of_string(value));
    }
    parser_env_bs.Expect.token(env, {
          TAG: /* T_NUMBER */0,
          _0: number_type
        });
    return value$1;
  };
  var primary = function (env) {
    var loc = parser_env_bs.Peek.loc(undefined, env);
    var number_type = parser_env_bs.Peek.token(undefined, env);
    var exit = 0;
    if (typeof number_type === "number") {
      switch (number_type) {
        case /* T_LCURLY */1 :
            var match = curry._1(Parse.object_initializer, env);
            return [
                    match[0],
                    {
                      TAG: /* Object */1,
                      _0: match[1]
                    }
                  ];
        case /* T_LPAREN */5 :
            parser_env_bs.Expect.token(env, /* T_LPAREN */5);
            var expression = curry._1(assignment, env);
            var match$1 = parser_env_bs.Peek.token(undefined, env);
            var ret;
            if (typeof match$1 === "number") {
              if (match$1 !== 10) {
                if (match$1 !== 80) {
                  ret = expression;
                } else {
                  var typeAnnotation = curry._1(Type.annotation, env);
                  ret = [
                    loc_bs.btwn(expression[0], typeAnnotation[0]),
                    {
                      TAG: /* TypeCast */23,
                      _0: {
                        expression: expression,
                        typeAnnotation: typeAnnotation
                      }
                    }
                  ];
                }
              } else {
                ret = sequence(env, {
                      hd: expression,
                      tl: /* [] */0
                    });
              }
            } else {
              ret = expression;
            }
            parser_env_bs.Expect.token(env, /* T_RPAREN */6);
            return ret;
        case /* T_LBRACKET */7 :
            var match$2 = curry._1(array_initializer, env);
            return [
                    match$2[0],
                    {
                      TAG: /* Array */0,
                      _0: match$2[1]
                    }
                  ];
        case /* T_THIS */21 :
            parser_env_bs.Expect.token(env, /* T_THIS */21);
            return [
                    loc,
                    /* This */0
                  ];
        case /* T_NULL */29 :
            var raw = parser_env_bs.Peek.value(undefined, env);
            parser_env_bs.Expect.token(env, /* T_NULL */29);
            return [
                    loc,
                    {
                      TAG: /* Literal */18,
                      _0: {
                        value: /* Null */0,
                        raw: raw
                      }
                    }
                  ];
        case /* T_FALSE */30 :
        case /* T_TRUE */31 :
            exit = 2;
            break;
        case /* T_CLASS */40 :
            return curry._1(Parse.class_expression, env);
        case /* T_SUPER */51 :
            var loc$1 = parser_env_bs.Peek.loc(undefined, env);
            parser_env_bs.Expect.token(env, /* T_SUPER */51);
            return [
                    loc$1,
                    /* Super */1
                  ];
        case /* T_LESS_THAN */92 :
            var match$3 = curry._1(Parse.jsx_element, env);
            return [
                    match$3[0],
                    {
                      TAG: /* JSXElement */21,
                      _0: match$3[1]
                    }
                  ];
        case /* T_DIV_ASSIGN */73 :
        case /* T_DIV */99 :
            parser_env_bs.Eat.push_lex_mode(env, /* REGEXP */5);
            var loc$2 = parser_env_bs.Peek.loc(undefined, env);
            var match$4 = parser_env_bs.Peek.token(undefined, env);
            var match$5;
            if (typeof match$4 === "number") {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "expression_parser.ml",
                      810,
                      13
                    ],
                    Error: new Error()
                  };
            }
            if (match$4.TAG === /* T_REGEXP */3) {
              var match$6 = match$4._0;
              var raw$1 = parser_env_bs.Peek.value(undefined, env);
              parser_env_bs.Eat.token(env);
              match$5 = [
                raw$1,
                match$6[1],
                match$6[2]
              ];
            } else {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "expression_parser.ml",
                      810,
                      13
                    ],
                    Error: new Error()
                  };
            }
            var raw_flags = match$5[2];
            parser_env_bs.Eat.pop_lex_mode(env);
            var filtered_flags = buffer.create(raw_flags.length);
            string.iter((function (c) {
                    switch (c) {
                      case 104 :
                      case 106 :
                      case 107 :
                      case 108 :
                      case 110 :
                      case 111 :
                      case 112 :
                      case 113 :
                      case 114 :
                      case 115 :
                      case 116 :
                      case 118 :
                      case 119 :
                      case 120 :
                          return ;
                      case 103 :
                      case 105 :
                      case 109 :
                      case 117 :
                      case 121 :
                          return buffer.add_char(filtered_flags, c);
                      default:
                        return ;
                    }
                  }), raw_flags);
            var flags = buffer.contents(filtered_flags);
            if (flags !== raw_flags) {
              parser_env_bs.error(env, {
                    TAG: /* InvalidRegExpFlags */3,
                    _0: raw_flags
                  });
            }
            var value = {
              TAG: /* RegExp */3,
              _0: {
                pattern: match$5[1],
                flags: flags
              }
            };
            return [
                    loc$2,
                    {
                      TAG: /* Literal */18,
                      _0: {
                        value: value,
                        raw: match$5[0]
                      }
                    }
                  ];
        default:
          exit = 1;
      }
    } else {
      switch (number_type.TAG | 0) {
        case /* T_NUMBER */0 :
            var raw$2 = parser_env_bs.Peek.value(undefined, env);
            var value$1 = {
              TAG: /* Number */2,
              _0: number(env, number_type._0)
            };
            return [
                    loc,
                    {
                      TAG: /* Literal */18,
                      _0: {
                        value: value$1,
                        raw: raw$2
                      }
                    }
                  ];
        case /* T_STRING */1 :
            var match$7 = number_type._0;
            var octal = match$7[3];
            var raw$3 = match$7[2];
            var value$2 = match$7[1];
            var loc$3 = match$7[0];
            if (octal) {
              parser_env_bs.strict_error(env, /* StrictOctalLiteral */32);
            }
            parser_env_bs.Expect.token(env, {
                  TAG: /* T_STRING */1,
                  _0: [
                    loc$3,
                    value$2,
                    raw$3,
                    octal
                  ]
                });
            var value$3 = {
              TAG: /* String */0,
              _0: value$2
            };
            return [
                    loc$3,
                    {
                      TAG: /* Literal */18,
                      _0: {
                        value: value$3,
                        raw: raw$3
                      }
                    }
                  ];
        case /* T_TEMPLATE_PART */2 :
            var match$8 = curry._2(template_literal, env, number_type._0);
            return [
                    match$8[0],
                    {
                      TAG: /* TemplateLiteral */19,
                      _0: match$8[1]
                    }
                  ];
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          if (parser_env_bs.Peek.is_identifier(undefined, env)) {
            var id = curry._2(Parse.identifier, undefined, env);
            return [
                    id[0],
                    {
                      TAG: /* Identifier */17,
                      _0: id
                    }
                  ];
          }
          parser_env_bs.error_unexpected(env);
          if (number_type === /* T_ERROR */107) {
            parser_env_bs.Eat.token(env);
          }
          return [
                  loc,
                  {
                    TAG: /* Literal */18,
                    _0: {
                      value: /* Null */0,
                      raw: "null"
                    }
                  }
                ];
      case 2 :
          var raw$4 = parser_env_bs.Peek.value(undefined, env);
          parser_env_bs.Expect.token(env, number_type);
          var value$4 = {
            TAG: /* Boolean */1,
            _0: number_type === /* T_TRUE */31
          };
          return [
                  loc,
                  {
                    TAG: /* Literal */18,
                    _0: {
                      value: value$4,
                      raw: raw$4
                    }
                  }
                ];
      
    }
  };
  var tagged_template = function (env, start_loc, tag, part) {
    var quasi = curry._2(template_literal, env, part);
    return [
            loc_bs.btwn(start_loc, quasi[0]),
            {
              TAG: /* TaggedTemplate */20,
              _0: {
                tag: tag,
                quasi: quasi
              }
            }
          ];
  };
  var sequence = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number" && match === 10) {
        parser_env_bs.Expect.token(env, /* T_COMMA */10);
        var expr = curry._1(assignment, env);
        _acc = {
          hd: expr,
          tl: acc
        };
        continue ;
      }
      var match$1 = list.hd(acc);
      var expressions = list.rev(acc);
      var match$2 = list.hd(expressions);
      return [
              loc_bs.btwn(match$2[0], match$1[0]),
              {
                TAG: /* Sequence */4,
                _0: {
                  expressions: expressions
                }
              }
            ];
    }  };
  var identifier_or_reserved_keyword = function (env) {
    var lex_token = parser_env_bs.Peek.token(undefined, env);
    var lex_value = parser_env_bs.Peek.value(undefined, env);
    var lex_loc = parser_env_bs.Peek.loc(undefined, env);
    var exit = 0;
    if (typeof lex_token === "number") {
      if (lex_token >= 60) {
        if (lex_token < 64) {
          return [
                  curry._2(Parse.identifier, undefined, env),
                  undefined
                ];
        }
        exit = 1;
      } else {
        if (lex_token === 0) {
          return [
                  curry._2(Parse.identifier, undefined, env),
                  undefined
                ];
        }
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var err;
      var exit$1 = 0;
      if (typeof lex_token === "number") {
        if (lex_token >= 65) {
          if (lex_token !== 110 && lex_token < 113) {
            parser_env_bs.error_unexpected(env);
            err = undefined;
          } else {
            exit$1 = 2;
          }
        } else if (lex_token >= 60) {
          if (lex_token >= 64) {
            exit$1 = 2;
          } else {
            parser_env_bs.error_unexpected(env);
            err = undefined;
          }
        } else if (lex_token >= 15) {
          exit$1 = 2;
        } else {
          parser_env_bs.error_unexpected(env);
          err = undefined;
        }
      } else {
        parser_env_bs.error_unexpected(env);
        err = undefined;
      }
      if (exit$1 === 2) {
        err = [
          lex_loc,
          parser_env_bs.get_unexpected_error([
                lex_token,
                lex_value
              ])
        ];
      }
      parser_env_bs.Eat.token(env);
      return [
              [
                lex_loc,
                lex_value
              ],
              err
            ];
    }
    
  };
  var assignment_but_not_arrow_function = function (env) {
    var expr = conditional(env);
    var operator = assignment_op(env);
    if (operator === undefined) {
      return expr;
    }
    if (!is_assignable_lhs(expr)) {
      parser_env_bs.error_at(env, [
            expr[0],
            /* InvalidLHSInAssignment */15
          ]);
    }
    var match = expr[1];
    if (typeof match !== "number" && match.TAG === /* Identifier */17) {
      if (parser_env_bs.is_restricted(match._0[1])) {
        parser_env_bs.strict_error_at(env, [
              expr[0],
              /* StrictLHSAssignment */37
            ]);
      }
      
    }
    var left = curry._2(Parse.pattern_from_expr, env, expr);
    var right = curry._1(assignment, env);
    var loc = loc_bs.btwn(left[0], right[0]);
    return [
            loc,
            {
              TAG: /* Assignment */7,
              _0: {
                operator: operator,
                left: left,
                right: right
              }
            }
          ];
  };
  var error_callback = function (param, param$1) {
    throw {
          RE_EXN_ID: parser_env_bs.Try.Rollback,
          Error: new Error()
        };
  };
  var try_assignment_but_not_arrow_function = function (env) {
    var env$1 = parser_env_bs.with_error_callback(error_callback, env);
    var ret = assignment_but_not_arrow_function(env$1);
    var match = parser_env_bs.Peek.token(undefined, env$1);
    if (typeof match === "number") {
      if (match !== 12) {
        if (match === 80) {
          throw {
                RE_EXN_ID: parser_env_bs.Try.Rollback,
                Error: new Error()
              };
        }
        
      } else {
        throw {
              RE_EXN_ID: parser_env_bs.Try.Rollback,
              Error: new Error()
            };
      }
    }
    if (!parser_env_bs.Peek.is_identifier(undefined, env$1)) {
      return ret;
    }
    var match$1 = ret[1];
    if (typeof match$1 === "number") {
      return ret;
    }
    if (match$1.TAG !== /* Identifier */17) {
      return ret;
    }
    if (match$1._0[1] !== "async") {
      return ret;
    }
    if (!parser_env_bs.Peek.is_line_terminator(env$1)) {
      throw {
            RE_EXN_ID: parser_env_bs.Try.Rollback,
            Error: new Error()
          };
    }
    return ret;
  };
  var assignment = function (env) {
    var match = parser_env_bs.Peek.token(undefined, env);
    var match$1 = parser_env_bs.Peek.is_identifier(undefined, env);
    var exit = 0;
    if (typeof match === "number") {
      var switcher = match - 6 | 0;
      if (switcher > 85 || switcher < 0) {
        if ((switcher + 1 >>> 0) > 87) {
          exit = 2;
        }
        
      } else if (switcher !== 52) {
        exit = 2;
      } else {
        if (parser_env_bs.allow_yield(env)) {
          var start_loc = parser_env_bs.Peek.loc(undefined, env);
          parser_env_bs.Expect.token(env, /* T_YIELD */58);
          if (!parser_env_bs.allow_yield(env)) {
            parser_env_bs.error(env, /* IllegalYield */25);
          }
          var delegate = parser_env_bs.Expect.maybe(env, /* T_MULT */100);
          var has_argument = !(parser_env_bs.Peek.token(undefined, env) === /* T_SEMICOLON */9 || parser_env_bs.Peek.is_implicit_semicolon(env));
          var argument = delegate || has_argument ? curry._1(assignment, env) : undefined;
          var end_loc;
          if (argument !== undefined) {
            end_loc = argument[0];
          } else {
            var loc = parser_env_bs.Peek.semicolon_loc(undefined, env);
            var end_loc$1 = loc !== undefined ? loc : start_loc;
            parser_env_bs.Eat.semicolon(env);
            end_loc = end_loc$1;
          }
          return [
                  loc_bs.btwn(start_loc, end_loc),
                  {
                    TAG: /* Yield */14,
                    _0: {
                      argument: argument,
                      delegate: delegate
                    }
                  }
                ];
        }
        exit = 2;
      }
    } else {
      exit = 2;
    }
    if (exit === 2 && !match$1) {
      return assignment_but_not_arrow_function(env);
    }
    var expr = parser_env_bs.Try.to_parse(env, try_assignment_but_not_arrow_function);
    if (expr) {
      return expr._0;
    }
    var expr$1 = parser_env_bs.Try.to_parse(env, try_arrow_function);
    if (expr$1) {
      return expr$1._0;
    } else {
      return assignment_but_not_arrow_function(env);
    }
  };
  var make_logical = function (left, right, operator, loc) {
    return [
            loc,
            {
              TAG: /* Logical */9,
              _0: {
                operator: operator,
                left: left,
                right: right
              }
            }
          ];
  };
  var logical_and = function (env, _left, _lloc) {
    while(true) {
      var lloc = _lloc;
      var left = _left;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match !== "number") {
        return [
                lloc,
                left
              ];
      }
      if (match !== 82) {
        return [
                lloc,
                left
              ];
      }
      parser_env_bs.Expect.token(env, /* T_AND */82);
      var match$1 = parser_common_bs.with_loc(binary, env);
      var loc = loc_bs.btwn(lloc, match$1[0]);
      _lloc = loc;
      _left = make_logical(left, match$1[1], /* And */1, loc);
      continue ;
    }  };
  var logical_or = function (env, _left, _lloc) {
    while(true) {
      var lloc = _lloc;
      var left = _left;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match !== "number") {
        return [
                lloc,
                left
              ];
      }
      if (match !== 81) {
        return [
                lloc,
                left
              ];
      }
      parser_env_bs.Expect.token(env, /* T_OR */81);
      var match$1 = parser_common_bs.with_loc(binary, env);
      var match$2 = logical_and(env, match$1[1], match$1[0]);
      var loc = loc_bs.btwn(lloc, match$2[0]);
      _lloc = loc;
      _left = make_logical(left, match$2[1], /* Or */0, loc);
      continue ;
    }  };
  var logical = function (env) {
    var match = parser_common_bs.with_loc(binary, env);
    var match$1 = logical_and(env, match[1], match[0]);
    return logical_or(env, match$1[1], match$1[0])[1];
  };
  var binary_op = function (env) {
    var match = parser_env_bs.Peek.token(undefined, env);
    var ret;
    if (typeof match === "number") {
      var switcher = match - 17 | 0;
      if (switcher === 0 || switcher === 1) {
        ret = switcher !== 0 ? [
            /* Instanceof */21,
            {
              TAG: /* Left_assoc */0,
              _0: 6
            }
          ] : (
            parser_env_bs.no_in(env) ? undefined : [
                /* In */20,
                {
                  TAG: /* Left_assoc */0,
                  _0: 6
                }
              ]
          );
      } else if (switcher >= 66) {
        switch (switcher - 66 | 0) {
          case /* T_IDENTIFIER */0 :
              ret = [
                /* BitOr */17,
                {
                  TAG: /* Left_assoc */0,
                  _0: 2
                }
              ];
              break;
          case /* T_LCURLY */1 :
              ret = [
                /* Xor */18,
                {
                  TAG: /* Left_assoc */0,
                  _0: 3
                }
              ];
              break;
          case /* T_RCURLY */2 :
              ret = [
                /* BitAnd */19,
                {
                  TAG: /* Left_assoc */0,
                  _0: 4
                }
              ];
              break;
          case /* T_LCURLYBAR */3 :
              ret = [
                /* Equal */0,
                {
                  TAG: /* Left_assoc */0,
                  _0: 5
                }
              ];
              break;
          case /* T_RCURLYBAR */4 :
              ret = [
                /* NotEqual */1,
                {
                  TAG: /* Left_assoc */0,
                  _0: 5
                }
              ];
              break;
          case /* T_LPAREN */5 :
              ret = [
                /* StrictEqual */2,
                {
                  TAG: /* Left_assoc */0,
                  _0: 5
                }
              ];
              break;
          case /* T_RPAREN */6 :
              ret = [
                /* StrictNotEqual */3,
                {
                  TAG: /* Left_assoc */0,
                  _0: 5
                }
              ];
              break;
          case /* T_LBRACKET */7 :
              ret = [
                /* LessThanEqual */5,
                {
                  TAG: /* Left_assoc */0,
                  _0: 6
                }
              ];
              break;
          case /* T_RBRACKET */8 :
              ret = [
                /* GreaterThanEqual */7,
                {
                  TAG: /* Left_assoc */0,
                  _0: 6
                }
              ];
              break;
          case /* T_SEMICOLON */9 :
              ret = [
                /* LessThan */4,
                {
                  TAG: /* Left_assoc */0,
                  _0: 6
                }
              ];
              break;
          case /* T_COMMA */10 :
              ret = [
                /* GreaterThan */6,
                {
                  TAG: /* Left_assoc */0,
                  _0: 6
                }
              ];
              break;
          case /* T_PERIOD */11 :
              ret = [
                /* LShift */8,
                {
                  TAG: /* Left_assoc */0,
                  _0: 7
                }
              ];
              break;
          case /* T_ARROW */12 :
              ret = [
                /* RShift */9,
                {
                  TAG: /* Left_assoc */0,
                  _0: 7
                }
              ];
              break;
          case /* T_ELLIPSIS */13 :
              ret = [
                /* RShift3 */10,
                {
                  TAG: /* Left_assoc */0,
                  _0: 7
                }
              ];
              break;
          case /* T_AT */14 :
              ret = [
                /* Plus */11,
                {
                  TAG: /* Left_assoc */0,
                  _0: 8
                }
              ];
              break;
          case /* T_FUNCTION */15 :
              ret = [
                /* Minus */12,
                {
                  TAG: /* Left_assoc */0,
                  _0: 8
                }
              ];
              break;
          case /* T_IF */16 :
              ret = [
                /* Div */15,
                {
                  TAG: /* Left_assoc */0,
                  _0: 9
                }
              ];
              break;
          case /* T_IN */17 :
              ret = [
                /* Mult */13,
                {
                  TAG: /* Left_assoc */0,
                  _0: 9
                }
              ];
              break;
          case /* T_INSTANCEOF */18 :
              ret = [
                /* Exp */14,
                {
                  TAG: /* Right_assoc */1,
                  _0: 10
                }
              ];
              break;
          case /* T_RETURN */19 :
              ret = [
                /* Mod */16,
                {
                  TAG: /* Left_assoc */0,
                  _0: 9
                }
              ];
              break;
          case /* T_SWITCH */20 :
          case /* T_THIS */21 :
          case /* T_THROW */22 :
          case /* T_TRY */23 :
          case /* T_VAR */24 :
          case /* T_WHILE */25 :
          case /* T_WITH */26 :
          case /* T_CONST */27 :
          case /* T_LET */28 :
          case /* T_NULL */29 :
          case /* T_FALSE */30 :
          case /* T_TRUE */31 :
          case /* T_BREAK */32 :
          case /* T_CASE */33 :
              ret = undefined;
              break;
          
        }
      } else {
        ret = undefined;
      }
    } else {
      ret = undefined;
    }
    if (ret !== undefined) {
      parser_env_bs.Eat.token(env);
    }
    return ret;
  };
  var make_binary = function (left, right, operator, loc) {
    return [
            loc,
            {
              TAG: /* Binary */6,
              _0: {
                operator: operator,
                left: left,
                right: right
              }
            }
          ];
  };
  var add_to_stack = function (_right, _param, _rloc, _stack) {
    while(true) {
      var param = _param;
      var stack = _stack;
      var rloc = _rloc;
      var right = _right;
      var rpri = param[1];
      var rop = param[0];
      if (stack) {
        var match = stack.hd;
        var match$1 = match[1];
        if (is_tighter(match$1[1], rpri)) {
          var loc = loc_bs.btwn(match[2], rloc);
          var right$1 = make_binary(match[0], right, match$1[0], loc);
          _stack = stack.tl;
          _rloc = loc;
          _param = [
            rop,
            rpri
          ];
          _right = right$1;
          continue ;
        }
        
      }
      return {
              hd: [
                right,
                [
                  rop,
                  rpri
                ],
                rloc
              ],
              tl: stack
            };
    }  };
  var binary = function (env) {
    var _stack = /* [] */0;
    while(true) {
      var stack = _stack;
      var start_loc = parser_env_bs.Peek.loc(undefined, env);
      var is_unary = peek_unary_op(env) !== undefined;
      var right = unary(parser_env_bs.with_no_in(false, env));
      var loc = parser_env_bs.last_loc(env);
      var end_loc = loc !== undefined ? loc : right[0];
      var right_loc = loc_bs.btwn(start_loc, end_loc);
      if (parser_env_bs.Peek.token(undefined, env) === /* T_LESS_THAN */92) {
        var tmp = right[1];
        if (typeof tmp !== "number" && tmp.TAG === /* JSXElement */21) {
          parser_env_bs.error(env, /* AdjacentJSXElements */47);
        }
        
      }
      var match = binary_op(env);
      if (match === undefined) {
        var _right = right;
        var _rloc = right_loc;
        var _param = stack;
        while(true) {
          var param = _param;
          var rloc = _rloc;
          var right$1 = _right;
          if (!param) {
            return right$1;
          }
          var match$1 = param.hd;
          var loc$1 = loc_bs.btwn(match$1[2], rloc);
          _param = param.tl;
          _rloc = loc$1;
          _right = make_binary(match$1[0], right$1, match$1[1][0], loc$1);
          continue ;
        }      }
      var rop = match[0];
      if (is_unary && rop === /* Exp */14) {
        parser_env_bs.error_at(env, [
              right_loc,
              /* InvalidLHSInExponentiation */16
            ]);
      }
      _stack = add_to_stack(right, [
            rop,
            match[1]
          ], right_loc, stack);
      continue ;
    }  };
  var argument = function (env) {
    var match = parser_env_bs.Peek.token(undefined, env);
    if (typeof match !== "number") {
      return {
              TAG: /* Expression */0,
              _0: curry._1(assignment, env)
            };
    }
    if (match !== 13) {
      return {
              TAG: /* Expression */0,
              _0: curry._1(assignment, env)
            };
    }
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_ELLIPSIS */13);
    var argument$1 = curry._1(assignment, env);
    var loc = loc_bs.btwn(start_loc, argument$1[0]);
    return {
            TAG: /* Spread */1,
            _0: [
              loc,
              {
                argument: argument$1
              }
            ]
          };
  };
  var arguments$prime = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        if (match === 6) {
          return list.rev(acc);
        }
        if (match === 108) {
          return list.rev(acc);
        }
        
      }
      var acc_0 = argument(env);
      var acc$1 = {
        hd: acc_0,
        tl: acc
      };
      if (parser_env_bs.Peek.token(undefined, env) !== /* T_RPAREN */6) {
        parser_env_bs.Expect.token(env, /* T_COMMA */10);
      }
      _acc = acc$1;
      continue ;
    }  };
  var $$arguments = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    var args = arguments$prime(env, /* [] */0);
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    return [
            loc_bs.btwn(start_loc, end_loc),
            args
          ];
  };
  var template_parts = function (env, _quasis, _expressions) {
    while(true) {
      var expressions = _expressions;
      var quasis = _quasis;
      var expr = curry._1(Parse.expression, env);
      var expressions$1 = {
        hd: expr,
        tl: expressions
      };
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number" && match === 2) {
        parser_env_bs.Eat.push_lex_mode(env, /* TEMPLATE */4);
        var match$1 = parser_env_bs.Peek.token(undefined, env);
        var match$2;
        if (typeof match$1 === "number") {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "expression_parser.ml",
                  712,
                  17
                ],
                Error: new Error()
              };
        }
        if (match$1.TAG === /* T_TEMPLATE_PART */2) {
          var match$3 = match$1._0;
          var tail = match$3[2];
          var match$4 = match$3[1];
          parser_env_bs.Eat.token(env);
          match$2 = [
            match$3[0],
            {
              value: {
                raw: match$4.raw,
                cooked: match$4.cooked
              },
              tail: tail
            },
            tail
          ];
        } else {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "expression_parser.ml",
                  712,
                  17
                ],
                Error: new Error()
              };
        }
        var loc = match$2[0];
        parser_env_bs.Eat.pop_lex_mode(env);
        var quasis_0 = [
          loc,
          match$2[1]
        ];
        var quasis$1 = {
          hd: quasis_0,
          tl: quasis
        };
        if (match$2[2]) {
          return [
                  loc,
                  list.rev(quasis$1),
                  list.rev(expressions$1)
                ];
        }
        _expressions = expressions$1;
        _quasis = quasis$1;
        continue ;
      }
      parser_env_bs.error_unexpected(env);
      var imaginary_quasi_0 = expr[0];
      var imaginary_quasi_1 = {
        value: {
          raw: "",
          cooked: ""
        },
        tail: true
      };
      var imaginary_quasi = [
        imaginary_quasi_0,
        imaginary_quasi_1
      ];
      return [
              expr[0],
              list.rev({
                    hd: imaginary_quasi,
                    tl: quasis
                  }),
              list.rev(expressions$1)
            ];
    }  };
  var template_literal = function (env, part) {
    var is_tail = part[2];
    var match = part[1];
    var start_loc = part[0];
    parser_env_bs.Expect.token(env, {
          TAG: /* T_TEMPLATE_PART */2,
          _0: part
        });
    var head_1 = {
      value: {
        raw: match.raw,
        cooked: match.cooked
      },
      tail: is_tail
    };
    var head = [
      start_loc,
      head_1
    ];
    var match$1 = is_tail ? [
        start_loc,
        {
          hd: head,
          tl: /* [] */0
        },
        /* [] */0
      ] : template_parts(env, {
            hd: head,
            tl: /* [] */0
          }, /* [] */0);
    var loc = loc_bs.btwn(start_loc, match$1[0]);
    return [
            loc,
            {
              quasis: match$1[1],
              expressions: match$1[2]
            }
          ];
  };
  var elements = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = parser_env_bs.Peek.token(undefined, env);
      if (typeof match === "number") {
        if (match >= 14) {
          if (match === 108) {
            return list.rev(acc);
          }
          
        } else if (match >= 8) {
          switch (match - 8 | 0) {
            case /* T_IDENTIFIER */0 :
                return list.rev(acc);
            case /* T_RCURLY */2 :
                parser_env_bs.Expect.token(env, /* T_COMMA */10);
                _acc = {
                  hd: undefined,
                  tl: acc
                };
                continue ;
            case /* T_LCURLY */1 :
            case /* T_LCURLYBAR */3 :
            case /* T_RCURLYBAR */4 :
                break;
            case /* T_LPAREN */5 :
                var start_loc = parser_env_bs.Peek.loc(undefined, env);
                parser_env_bs.Expect.token(env, /* T_ELLIPSIS */13);
                var argument = curry._1(assignment, env);
                var loc = loc_bs.btwn(start_loc, argument[0]);
                var elem = {
                  TAG: /* Spread */1,
                  _0: [
                    loc,
                    {
                      argument: argument
                    }
                  ]
                };
                if (parser_env_bs.Peek.token(undefined, env) !== /* T_RBRACKET */8) {
                  parser_env_bs.Expect.token(env, /* T_COMMA */10);
                }
                _acc = {
                  hd: elem,
                  tl: acc
                };
                continue ;
            
          }
        }
        
      }
      var elem$1 = {
        TAG: /* Expression */0,
        _0: curry._1(assignment, env)
      };
      if (parser_env_bs.Peek.token(undefined, env) !== /* T_RBRACKET */8) {
        parser_env_bs.Expect.token(env, /* T_COMMA */10);
      }
      _acc = {
        hd: elem$1,
        tl: acc
      };
      continue ;
    }  };
  var array_initializer = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_LBRACKET */7);
    var elements$1 = elements(env, /* [] */0);
    var end_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, /* T_RBRACKET */8);
    return [
            loc_bs.btwn(start_loc, end_loc),
            {
              elements: elements$1
            }
          ];
  };
  var error_callback$1 = function (param, param$1) {
    if (typeof param$1 === "number") {
      var switcher = param$1 - 29 | 0;
      if (switcher > 16 || switcher < 0) {
        if (switcher === 19) {
          return ;
        }
        throw {
              RE_EXN_ID: parser_env_bs.Try.Rollback,
              Error: new Error()
            };
      }
      if (switcher > 15 || switcher < 1) {
        return ;
      }
      throw {
            RE_EXN_ID: parser_env_bs.Try.Rollback,
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: parser_env_bs.Try.Rollback,
          Error: new Error()
        };
  };
  var try_arrow_function = function (env) {
    var env$1 = parser_env_bs.with_error_callback(error_callback$1, env);
    var start_loc = parser_env_bs.Peek.loc(undefined, env$1);
    var async = parser_env_bs.Peek.token(1, env$1) !== /* T_ARROW */12 && curry._1(Declaration.async, env$1);
    var typeParameters = curry._1(Type.type_parameter_declaration, env$1);
    var match;
    if (parser_env_bs.Peek.is_identifier(undefined, env$1) && typeParameters === undefined) {
      var match$1 = curry._2(Parse.identifier, /* StrictParamName */29, env$1);
      var loc = match$1[0];
      var param_1 = {
        TAG: /* Identifier */3,
        _0: {
          name: [
            loc,
            match$1[1]
          ],
          typeAnnotation: undefined,
          optional: false
        }
      };
      var param = [
        loc,
        param_1
      ];
      match = [
        [
          {
            hd: param,
            tl: /* [] */0
          },
          undefined
        ],
        undefined,
        undefined
      ];
    } else {
      var params = curry._1(Declaration.function_params, env$1);
      var match$2 = curry._1(Type.annotation_and_predicate_opt, parser_env_bs.with_no_anon_function_type(true, env$1));
      match = [
        params,
        match$2[0],
        match$2[1]
      ];
    }
    var params$1 = match[0];
    var env$2 = params$1[1] !== undefined || !params$1[0] ? parser_env_bs.without_error_callback(env$1) : env$1;
    if (parser_env_bs.Peek.is_line_terminator(env$2) && parser_env_bs.Peek.token(undefined, env$2) === /* T_ARROW */12) {
      parser_env_bs.error(env$2, /* NewlineBeforeArrow */45);
    }
    parser_env_bs.Expect.token(env$2, /* T_ARROW */12);
    var env$3 = parser_env_bs.without_error_callback(env$2);
    var func = Declaration.concise_function_body;
    var match$3 = parser_common_bs.with_loc((function (param) {
            return curry._3(func, param, async, false);
          }), env$3);
    var match$4 = match$3[1];
    var body = match$4[0];
    var simple = curry._1(Declaration.is_simple_function_params, params$1);
    curry._5(Declaration.strict_post_check, env$3, match$4[1], simple, undefined, params$1);
    var expression;
    expression = body.TAG === /* BodyBlock */0 ? false : true;
    var loc$1 = loc_bs.btwn(start_loc, match$3[0]);
    return [
            loc$1,
            {
              TAG: /* ArrowFunction */3,
              _0: {
                id: undefined,
                params: params$1,
                body: body,
                async: async,
                generator: false,
                predicate: match[2],
                expression: expression,
                returnType: match[1],
                typeParameters: typeParameters
              }
            }
          ];
  };
  return {
          array_initializer: array_initializer,
          assignment: assignment,
          conditional: conditional,
          identifier_or_reserved_keyword: identifier_or_reserved_keyword,
          is_assignable_lhs: is_assignable_lhs,
          left_hand_side: left_hand_side,
          number: number,
          sequence: sequence
        };
}

var Token$7;

var Ast$6;

var $$Error$8;

var Token_1$7 = Token$7;
var Ast_1$6 = Ast$6;
var $$Error_1$8 = $$Error$8;
var Expression_1 = Expression;
/* Loc Not a pure module */

var expression_parser_bs = {
	Token: Token_1$7,
	Ast: Ast_1$6,
	$$Error: $$Error_1$8,
	Expression: Expression_1
};

var SSet$2 = set$2.Make({
      compare: string.compare
    });

function Declaration(Parse, Type) {
  var pattern = function (check_env, _param) {
    while(true) {
      var param = _param;
      var p = param[1];
      switch (p.TAG | 0) {
        case /* Object */0 :
            var o = p._0;
            return list.fold_left(object_property, check_env, o.properties);
        case /* Array */1 :
            var arr = p._0;
            return list.fold_left(array_element, check_env, arr.elements);
        case /* Assignment */2 :
            _param = p._0.left;
            continue ;
        case /* Identifier */3 :
            var param$1 = p._0;
            var id = param$1.name;
            var name = id[1];
            var param_names = check_env[1];
            var env = check_env[0];
            if (curry._2(SSet$2.mem, name, param_names)) {
              parser_env_bs.error_at(env, [
                    id[0],
                    /* StrictParamDupe */30
                  ]);
            }
            var match = identifier_no_dupe_check([
                  env,
                  param_names
                ], id);
            return [
                    match[0],
                    curry._2(SSet$2.add, name, match[1])
                  ];
        case /* Expression */4 :
            parser_env_bs.error_at(check_env[0], [
                  param[0],
                  /* ExpectedPatternFoundExpression */19
                ]);
            return check_env;
        
      }
    }  };
  var object_property = function (check_env, param) {
    if (param.TAG !== /* Property */0) {
      return pattern(check_env, param._0[1].argument);
    }
    var property = param._0[1];
    var id = property.key;
    var check_env$1;
    switch (id.TAG | 0) {
      case /* Identifier */1 :
          check_env$1 = identifier_no_dupe_check(check_env, id._0);
          break;
      case /* Literal */0 :
      case /* Computed */2 :
          check_env$1 = check_env;
          break;
      
    }
    return pattern(check_env$1, property.pattern);
  };
  var array_element = function (check_env, param) {
    if (param !== undefined) {
      if (param.TAG === /* Element */0) {
        return pattern(check_env, param._0);
      } else {
        return pattern(check_env, param._0[1].argument);
      }
    } else {
      return check_env;
    }
  };
  var identifier_no_dupe_check = function (param, param$1) {
    var name = param$1[1];
    var loc = param$1[0];
    var env = param[0];
    if (parser_env_bs.is_restricted(name)) {
      parser_env_bs.strict_error_at(env, [
            loc,
            /* StrictParamName */29
          ]);
    }
    if (parser_env_bs.is_future_reserved(name) || parser_env_bs.is_strict_reserved(name)) {
      parser_env_bs.strict_error_at(env, [
            loc,
            /* StrictReservedWord */40
          ]);
    }
    return [
            env,
            param[1]
          ];
  };
  var strict_post_check = function (env, strict, simple, id, param) {
    if (!(strict || !simple)) {
      return ;
    }
    var rest = param[1];
    var env$1 = strict ? parser_env_bs.with_strict(!parser_env_bs.in_strict_mode(env), env) : env;
    if (id !== undefined) {
      var name = id[1];
      var loc = id[0];
      if (parser_env_bs.is_restricted(name)) {
        parser_env_bs.strict_error_at(env$1, [
              loc,
              /* StrictFunctionName */31
            ]);
      }
      if (parser_env_bs.is_future_reserved(name) || parser_env_bs.is_strict_reserved(name)) {
        parser_env_bs.strict_error_at(env$1, [
              loc,
              /* StrictReservedWord */40
            ]);
      }
      
    }
    var acc = list.fold_left(pattern, [
          env$1,
          SSet$2.empty
        ], param[0]);
    if (rest !== undefined) {
      pattern(acc, rest[1].argument);
      return ;
    }
    
  };
  var param = function (env) {
    var left = curry._2(Parse.pattern, env, /* StrictParamName */29);
    if (parser_env_bs.Peek.token(undefined, env) !== /* T_ASSIGN */78) {
      return left;
    }
    parser_env_bs.Expect.token(env, /* T_ASSIGN */78);
    var right = curry._1(Parse.assignment, env);
    var loc = loc_bs.btwn(left[0], right[0]);
    return [
            loc,
            {
              TAG: /* Assignment */2,
              _0: {
                left: left,
                right: right
              }
            }
          ];
  };
  var param_list = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var t = parser_env_bs.Peek.token(undefined, env);
      var exit = 0;
      if (typeof t === "number") {
        var switcher = t - 6 | 0;
        exit = switcher > 7 || switcher < 0 ? (
            switcher !== 102 ? 1 : 2
          ) : (
            switcher > 6 || switcher < 1 ? 2 : 1
          );
      } else {
        exit = 1;
      }
      switch (exit) {
        case 1 :
            var the_param = param(env);
            if (parser_env_bs.Peek.token(undefined, env) !== /* T_RPAREN */6) {
              parser_env_bs.Expect.token(env, /* T_COMMA */10);
            }
            _acc = {
              hd: the_param,
              tl: acc
            };
            continue ;
        case 2 :
            var rest;
            if (t === /* T_ELLIPSIS */13) {
              var start_loc = parser_env_bs.Peek.loc(undefined, env);
              parser_env_bs.Expect.token(env, /* T_ELLIPSIS */13);
              var id = curry._2(Parse.pattern, env, /* StrictParamName */29);
              var loc = loc_bs.btwn(start_loc, id[0]);
              rest = [
                loc,
                {
                  argument: id
                }
              ];
            } else {
              rest = undefined;
            }
            if (parser_env_bs.Peek.token(undefined, env) !== /* T_RPAREN */6) {
              parser_env_bs.error(env, /* ParameterAfterRestParameter */48);
            }
            return [
                    list.rev(acc),
                    rest
                  ];
        
      }
    }  };
  var function_params = function (env) {
    parser_env_bs.Expect.token(env, /* T_LPAREN */5);
    var params = param_list(env, /* [] */0);
    parser_env_bs.Expect.token(env, /* T_RPAREN */6);
    return params;
  };
  var function_body = function (env, async, generator) {
    var env$1 = parser_env_bs.enter_function(env, async, generator);
    var match = curry._1(Parse.function_block_body, env$1);
    var loc = match[0];
    return [
            loc,
            {
              TAG: /* BodyBlock */0,
              _0: [
                loc,
                match[1]
              ]
            },
            match[2]
          ];
  };
  var concise_function_body = function (env, async, generator) {
    var env$1 = parser_env_bs.with_in_function(true, env);
    var match = parser_env_bs.Peek.token(undefined, env$1);
    if (typeof match === "number" && match === 1) {
      var match$1 = function_body(env$1, async, generator);
      return [
              match$1[1],
              match$1[2]
            ];
    }
    var env$2 = parser_env_bs.enter_function(env$1, async, generator);
    var expr = curry._1(Parse.assignment, env$2);
    return [
            {
              TAG: /* BodyExpression */1,
              _0: expr
            },
            parser_env_bs.in_strict_mode(env$2)
          ];
  };
  var variance = function (env, is_async, is_generator) {
    var loc = parser_env_bs.Peek.loc(undefined, env);
    var match = parser_env_bs.Peek.token(undefined, env);
    var variance$1 = typeof match === "number" ? (
        match !== 97 ? (
            match !== 98 ? undefined : (parser_env_bs.Eat.token(env), [
                  loc,
                  /* Minus */1
                ])
          ) : (parser_env_bs.Eat.token(env), [
              loc,
              /* Plus */0
            ])
      ) : undefined;
    if (variance$1 !== undefined && (is_async || is_generator)) {
      parser_env_bs.error_at(env, [
            variance$1[0],
            /* UnexpectedVariance */5
          ]);
      return ;
    } else {
      return variance$1;
    }
  };
  var generator = function (env) {
    return parser_env_bs.Expect.maybe(env, /* T_MULT */100);
  };
  var async = function (env) {
    return parser_env_bs.Expect.maybe(env, /* T_ASYNC */63);
  };
  var is_simple_param = function (param) {
    if (param[1].TAG === /* Identifier */3) {
      return true;
    } else {
      return false;
    }
  };
  var is_simple_function_params = function (param) {
    if (param[1] === undefined) {
      return list.for_all(is_simple_param, param[0]);
    } else {
      return false;
    }
  };
  var _function = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var async = parser_env_bs.Expect.maybe(env, /* T_ASYNC */63);
    parser_env_bs.Expect.token(env, /* T_FUNCTION */15);
    var generator = parser_env_bs.Expect.maybe(env, /* T_MULT */100);
    var match = parser_env_bs.in_export(env);
    var match$1 = parser_env_bs.Peek.token(undefined, env);
    var match$2;
    var exit = 0;
    if (match && typeof match$1 === "number") {
      if (match$1 !== 5) {
        if (match$1 !== 92) {
          exit = 1;
        } else {
          var typeParams = curry._1(Type.type_parameter_declaration, env);
          var id = parser_env_bs.Peek.token(undefined, env) === /* T_LPAREN */5 ? undefined : curry._2(Parse.identifier, /* StrictFunctionName */31, env);
          match$2 = [
            typeParams,
            id
          ];
        }
      } else {
        match$2 = [
          undefined,
          undefined
        ];
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var id$1 = curry._2(Parse.identifier, /* StrictFunctionName */31, env);
      match$2 = [
        curry._1(Type.type_parameter_declaration, env),
        id$1
      ];
    }
    var id$2 = match$2[1];
    var params = function_params(env);
    var match$3 = curry._1(Type.annotation_and_predicate_opt, env);
    var match$4 = function_body(env, async, generator);
    var body = match$4[1];
    var simple = is_simple_function_params(params);
    strict_post_check(env, match$4[2], simple, id$2, params);
    var match$5;
    match$5 = body.TAG === /* BodyBlock */0 ? [
        body._0[0],
        false
      ] : [
        body._0[0],
        true
      ];
    return [
            loc_bs.btwn(start_loc, match$5[0]),
            {
              TAG: /* FunctionDeclaration */17,
              _0: {
                id: id$2,
                params: params,
                body: body,
                async: async,
                generator: generator,
                predicate: match$3[1],
                expression: match$5[1],
                returnType: match$3[0],
                typeParameters: match$2[0]
              }
            }
          ];
  };
  var variable_declaration = function (env) {
    var id = curry._2(Parse.pattern, env, /* StrictVarName */28);
    var match;
    if (parser_env_bs.Peek.token(undefined, env) === /* T_ASSIGN */78) {
      parser_env_bs.Expect.token(env, /* T_ASSIGN */78);
      match = [
        curry._1(Parse.assignment, env),
        /* [] */0
      ];
    } else {
      match = id[1].TAG === /* Identifier */3 ? [
          undefined,
          /* [] */0
        ] : [
          undefined,
          {
            hd: [
              id[0],
              /* NoUninitializedDestructuring */44
            ],
            tl: /* [] */0
          }
        ];
    }
    var init = match[0];
    var end_loc = init !== undefined ? init[0] : id[0];
    return [
            [
              loc_bs.btwn(id[0], end_loc),
              {
                id: id,
                init: init
              }
            ],
            match[1]
          ];
  };
  var helper = function (env, _decls, _errs) {
    while(true) {
      var errs = _errs;
      var decls = _decls;
      var match = variable_declaration(env);
      var decls_0 = match[0];
      var decls$1 = {
        hd: decls_0,
        tl: decls
      };
      var errs$1 = pervasives.$at(match[1], errs);
      if (parser_env_bs.Peek.token(undefined, env) === /* T_COMMA */10) {
        parser_env_bs.Expect.token(env, /* T_COMMA */10);
        _errs = errs$1;
        _decls = decls$1;
        continue ;
      }
      var match$1 = list.hd(decls$1);
      var declarations = list.rev(decls$1);
      var match$2 = list.hd(decls$1);
      return [
              loc_bs.btwn(match$2[0], match$1[0]),
              declarations,
              list.rev(errs$1)
            ];
    }  };
  var variable_declaration_list = function (env) {
    return helper(env, /* [] */0, /* [] */0);
  };
  var declarations = function (token, kind, env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    parser_env_bs.Expect.token(env, token);
    var match = helper(env, /* [] */0, /* [] */0);
    return [
            [
              loc_bs.btwn(start_loc, match[0]),
              {
                declarations: match[1],
                kind: kind
              }
            ],
            match[2]
          ];
  };
  var $$var = function (param) {
    return declarations(/* T_VAR */24, /* Var */0, param);
  };
  var $$const = function (env) {
    var env$1 = parser_env_bs.with_no_let(true, env);
    var match = declarations(/* T_CONST */27, /* Const */2, env$1);
    var match$1 = match[0];
    var variable = match$1[1];
    var errs = list.fold_left((function (errs, decl) {
            if (decl[1].init !== undefined) {
              return errs;
            } else {
              return {
                      hd: [
                        decl[0],
                        /* NoUninitializedConst */43
                      ],
                      tl: errs
                    };
            }
          }), match[1], variable.declarations);
    return [
            [
              match$1[0],
              variable
            ],
            list.rev(errs)
          ];
  };
  var _let = function (env) {
    var env$1 = parser_env_bs.with_no_let(true, env);
    return declarations(/* T_LET */28, /* Let */1, env$1);
  };
  var variable = function (env) {
    var start_loc = parser_env_bs.Peek.loc(undefined, env);
    var match = parser_env_bs.Peek.token(undefined, env);
    var match$1;
    if (typeof match === "number") {
      switch (match) {
        case /* T_VAR */24 :
            match$1 = declarations(/* T_VAR */24, /* Var */0, env);
            break;
        case /* T_WHILE */25 :
        case /* T_WITH */26 :
            parser_env_bs.error_unexpected(env);
            match$1 = declarations(/* T_VAR */24, /* Var */0, env);
            break;
        case /* T_CONST */27 :
            match$1 = $$const(env);
            break;
        case /* T_LET */28 :
            match$1 = _let(env);
            break;
        default:
          parser_env_bs.error_unexpected(env);
          match$1 = declarations(/* T_VAR */24, /* Var */0, env);
      }
    } else {
      parser_env_bs.error_unexpected(env);
      match$1 = declarations(/* T_VAR */24, /* Var */0, env);
    }
    var match$2 = match$1[0];
    return [
            [
              loc_bs.btwn(start_loc, match$2[0]),
              {
                TAG: /* VariableDeclaration */18,
                _0: match$2[1]
              }
            ],
            match$1[1]
          ];
  };
  return {
          async: async,
          generator: generator,
          variance: variance,
          function_params: function_params,
          function_body: function_body,
          is_simple_function_params: is_simple_function_params,
          strict_post_check: strict_post_check,
          concise_function_body: concise_function_body,
          variable: variable,
          variable_declaration_list: variable_declaration_list,
          _let: _let,
          $$const: $$const,
          $$var: $$var,
          _function: _function
        };
}

var Token$8;

var Ast$7;

var $$Error$9;

var Token_1$8 = Token$8;
var Ast_1$7 = Ast$7;
var $$Error_1$9 = $$Error$9;
var SSet_1$2 = SSet$2;
var Declaration_1 = Declaration;
/* SSet Not a pure module */

var declaration_parser_bs = {
	Token: Token_1$8,
	Ast: Ast_1$7,
	$$Error: $$Error_1$9,
	SSet: SSet_1$2,
	Declaration: Declaration_1
};

function compare$8(param, param$1) {
  var loc = loc_bs.compare(param[0], param$1[0]);
  if (loc === 0) {
    return caml_obj.caml_compare(param[1], param$1[1]);
  } else {
    return loc;
  }
}

var ErrorSet = set$2.Make({
      compare: compare$8
    });

function filter_duplicate_errors(errs) {
  var errs$1 = list.rev(errs);
  var match = list.fold_left((function (param, err) {
          var deduped = param[1];
          var set = param[0];
          if (curry._2(ErrorSet.mem, err, set)) {
            return [
                    set,
                    deduped
                  ];
          } else {
            return [
                    curry._2(ErrorSet.add, err, set),
                    {
                      hd: err,
                      tl: deduped
                    }
                  ];
          }
        }), [
        ErrorSet.empty,
        /* [] */0
      ], errs$1);
  return list.rev(match[1]);
}

var Parse = caml_module.init_mod([
      "parser_flow.ml",
      39,
      28
    ], {
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "program"
        ],
        [
          /* Function */0,
          "statement"
        ],
        [
          /* Function */0,
          "statement_list_item"
        ],
        [
          /* Function */0,
          "statement_list"
        ],
        [
          /* Function */0,
          "statement_list_with_directives"
        ],
        [
          /* Function */0,
          "module_body"
        ],
        [
          /* Function */0,
          "expression"
        ],
        [
          /* Function */0,
          "conditional"
        ],
        [
          /* Function */0,
          "assignment"
        ],
        [
          /* Function */0,
          "left_hand_side"
        ],
        [
          /* Function */0,
          "object_initializer"
        ],
        [
          /* Function */0,
          "array_initializer"
        ],
        [
          /* Function */0,
          "identifier"
        ],
        [
          /* Function */0,
          "identifier_or_reserved_keyword"
        ],
        [
          /* Function */0,
          "identifier_with_type"
        ],
        [
          /* Function */0,
          "block_body"
        ],
        [
          /* Function */0,
          "function_block_body"
        ],
        [
          /* Function */0,
          "jsx_element"
        ],
        [
          /* Function */0,
          "pattern"
        ],
        [
          /* Function */0,
          "pattern_from_expr"
        ],
        [
          /* Function */0,
          "object_key"
        ],
        [
          /* Function */0,
          "class_declaration"
        ],
        [
          /* Function */0,
          "class_expression"
        ],
        [
          /* Function */0,
          "is_assignable_lhs"
        ]
      ]
    });

var Type$1 = type_parser_bs.Type(Parse);

var Declaration$1 = declaration_parser_bs.Declaration(Parse, Type$1);

var Expression$1 = expression_parser_bs.Expression(Parse, Type$1, Declaration$1);

var $$Object$1 = object_parser_bs.$$Object(Parse, Type$1, Declaration$1, Expression$1);

var Statement$1 = statement_parser_bs.Statement(Parse, Type$1, Declaration$1, $$Object$1);

var Pattern$1 = pattern_parser_bs.Pattern(Parse, Type$1);

var JSX$1 = jsx_parser_bs.JSX(Parse);

function statement(env) {
  while(true) {
    var match = parser_env_bs.Peek.token(undefined, env);
    var exit = 0;
    if (typeof match === "number") {
      if (match !== 108) {
        if (match >= 60) {
          exit = 2;
        } else {
          switch (match) {
            case /* T_LCURLY */1 :
                return curry._1(Statement$1.block, env);
            case /* T_SEMICOLON */9 :
                return curry._1(Statement$1.empty, env);
            case /* T_IF */16 :
                return curry._1(Statement$1._if, env);
            case /* T_RETURN */19 :
                return curry._1(Statement$1.$$return, env);
            case /* T_SWITCH */20 :
                return curry._1(Statement$1.$$switch, env);
            case /* T_THROW */22 :
                return curry._1(Statement$1.$$throw, env);
            case /* T_TRY */23 :
                return curry._1(Statement$1._try, env);
            case /* T_VAR */24 :
                return curry._1(Statement$1.var_or_const, env);
            case /* T_WHILE */25 :
                return curry._1(Statement$1._while, env);
            case /* T_WITH */26 :
                return curry._1(Statement$1._with, env);
            case /* T_BREAK */32 :
                return curry._1(Statement$1.$$break, env);
            case /* T_CONTINUE */35 :
                return curry._1(Statement$1.$$continue, env);
            case /* T_DO */37 :
                return curry._1(Statement$1.do_while, env);
            case /* T_FOR */39 :
                return curry._1(Statement$1._for, env);
            case /* T_IDENTIFIER */0 :
            case /* T_RCURLY */2 :
            case /* T_LCURLYBAR */3 :
            case /* T_RCURLYBAR */4 :
            case /* T_LPAREN */5 :
            case /* T_RPAREN */6 :
            case /* T_LBRACKET */7 :
            case /* T_RBRACKET */8 :
            case /* T_COMMA */10 :
            case /* T_PERIOD */11 :
            case /* T_ARROW */12 :
            case /* T_ELLIPSIS */13 :
            case /* T_AT */14 :
            case /* T_FUNCTION */15 :
            case /* T_IN */17 :
            case /* T_INSTANCEOF */18 :
            case /* T_THIS */21 :
            case /* T_CONST */27 :
            case /* T_LET */28 :
            case /* T_NULL */29 :
            case /* T_FALSE */30 :
            case /* T_TRUE */31 :
            case /* T_CASE */33 :
            case /* T_CATCH */34 :
            case /* T_DEFAULT */36 :
            case /* T_FINALLY */38 :
            case /* T_CLASS */40 :
            case /* T_EXTENDS */41 :
            case /* T_STATIC */42 :
            case /* T_ELSE */43 :
            case /* T_NEW */44 :
            case /* T_DELETE */45 :
            case /* T_TYPEOF */46 :
            case /* T_VOID */47 :
            case /* T_ENUM */48 :
            case /* T_EXPORT */49 :
            case /* T_IMPORT */50 :
            case /* T_SUPER */51 :
            case /* T_IMPLEMENTS */52 :
            case /* T_INTERFACE */53 :
            case /* T_PACKAGE */54 :
            case /* T_PRIVATE */55 :
            case /* T_PROTECTED */56 :
            case /* T_PUBLIC */57 :
            case /* T_YIELD */58 :
                exit = 2;
                break;
            case /* T_DEBUGGER */59 :
                return curry._1(Statement$1.$$debugger, env);
            
          }
        }
      } else {
        parser_env_bs.error_unexpected(env);
        return [
                parser_env_bs.Peek.loc(undefined, env),
                /* Empty */0
              ];
      }
    } else {
      exit = 2;
    }
    if (exit === 2) {
      if (parser_env_bs.Peek.is_identifier(undefined, env)) {
        return curry._1(Statement$1.maybe_labeled, env);
      }
      if (typeof match !== "number") {
        return curry._1(Statement$1.expression, env);
      }
      if (match !== 80) {
        if (match >= 51) {
          return curry._1(Statement$1.expression, env);
        }
        switch (match) {
          case /* T_ELSE */43 :
              return curry._1(Statement$1._if, env);
          case /* T_IDENTIFIER */0 :
          case /* T_LCURLY */1 :
          case /* T_LCURLYBAR */3 :
          case /* T_RCURLYBAR */4 :
          case /* T_LPAREN */5 :
          case /* T_LBRACKET */7 :
          case /* T_SEMICOLON */9 :
          case /* T_AT */14 :
          case /* T_FUNCTION */15 :
          case /* T_IF */16 :
          case /* T_RETURN */19 :
          case /* T_SWITCH */20 :
          case /* T_THIS */21 :
          case /* T_THROW */22 :
          case /* T_TRY */23 :
          case /* T_VAR */24 :
          case /* T_WHILE */25 :
          case /* T_WITH */26 :
          case /* T_CONST */27 :
          case /* T_LET */28 :
          case /* T_NULL */29 :
          case /* T_FALSE */30 :
          case /* T_TRUE */31 :
          case /* T_BREAK */32 :
          case /* T_CONTINUE */35 :
          case /* T_DO */37 :
          case /* T_FOR */39 :
          case /* T_CLASS */40 :
          case /* T_NEW */44 :
          case /* T_DELETE */45 :
          case /* T_TYPEOF */46 :
          case /* T_VOID */47 :
          case /* T_ENUM */48 :
              return curry._1(Statement$1.expression, env);
          
        }
      }
      
    }
    parser_env_bs.error_unexpected(env);
    parser_env_bs.Eat.token(env);
    continue ;
  }}

function statement_list_item(decoratorsOpt, env) {
  var decorators = decoratorsOpt !== undefined ? decoratorsOpt : /* [] */0;
  if (!parser_env_bs.Peek.is_class(undefined, env)) {
    parser_env_bs.error_on_decorators(env)(decorators);
  }
  var match = parser_env_bs.Peek.token(undefined, env);
  if (typeof match === "number") {
    if (match === 27) {
      return curry._1(Statement$1.var_or_const, env);
    }
    if (match === 28) {
      return curry._1(Statement$1._let, env);
    }
    
  }
  if (parser_env_bs.Peek.is_function(undefined, env)) {
    return curry._1(Declaration$1._function, env);
  }
  if (parser_env_bs.Peek.is_class(undefined, env)) {
    return curry._2(class_declaration, env, decorators);
  }
  if (typeof match !== "number") {
    return statement(env);
  }
  switch (match) {
    case /* T_INTERFACE */53 :
        return curry._1(Statement$1.$$interface, env);
    case /* T_PACKAGE */54 :
    case /* T_PRIVATE */55 :
    case /* T_PROTECTED */56 :
    case /* T_PUBLIC */57 :
    case /* T_YIELD */58 :
    case /* T_DEBUGGER */59 :
        return statement(env);
    case /* T_DECLARE */60 :
        return curry._2(Statement$1.declare, undefined, env);
    case /* T_TYPE */61 :
        return curry._1(Statement$1.type_alias, env);
    default:
      return statement(env);
  }
}

function module_item(env) {
  var decorators = curry._1($$Object$1.decorator_list, env);
  var match = parser_env_bs.Peek.token(undefined, env);
  if (typeof match !== "number") {
    return statement_list_item(decorators, env);
  }
  switch (match) {
    case /* T_EXPORT */49 :
        return curry._2(Statement$1.export_declaration, env, decorators);
    case /* T_IMPORT */50 :
        parser_env_bs.error_on_decorators(env)(decorators);
        return curry._1(Statement$1.import_declaration, env);
    case /* T_SUPER */51 :
    case /* T_IMPLEMENTS */52 :
    case /* T_INTERFACE */53 :
    case /* T_PACKAGE */54 :
    case /* T_PRIVATE */55 :
    case /* T_PROTECTED */56 :
    case /* T_PUBLIC */57 :
    case /* T_YIELD */58 :
    case /* T_DEBUGGER */59 :
        return statement_list_item(decorators, env);
    case /* T_DECLARE */60 :
        if (parser_env_bs.Peek.token(1, env) === /* T_EXPORT */49) {
          parser_env_bs.error_on_decorators(env)(decorators);
          return curry._2(Statement$1.declare_export_declaration, undefined, env);
        } else {
          return statement_list_item(decorators, env);
        }
    default:
      return statement_list_item(decorators, env);
  }
}

function statement_list(term_fn, env) {
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var t = parser_env_bs.Peek.token(undefined, env);
    if (typeof t === "number" && t === 108) {
      return list.rev(acc);
    }
    if (curry._1(term_fn, t)) {
      return list.rev(acc);
    }
    _acc = {
      hd: statement_list_item(undefined, env),
      tl: acc
    };
    continue ;
  }}

function statement_list$1(_env, term_fn, item_fn, _param) {
  while(true) {
    var param = _param;
    var env = _env;
    var stmts = param[1];
    var string_tokens = param[0];
    var t = parser_env_bs.Peek.token(undefined, env);
    if (typeof t === "number" && t === 108) {
      return [
              env,
              string_tokens,
              stmts
            ];
    }
    if (curry._1(term_fn, t)) {
      return [
              env,
              string_tokens,
              stmts
            ];
    }
    if (typeof t === "number") {
      return [
              env,
              string_tokens,
              stmts
            ];
    }
    if (t.TAG !== /* T_STRING */1) {
      return [
              env,
              string_tokens,
              stmts
            ];
    }
    var possible_directive = curry._1(item_fn, env);
    var stmts$1 = {
      hd: possible_directive,
      tl: stmts
    };
    var match = possible_directive[1];
    if (typeof match === "number") {
      return [
              env,
              string_tokens,
              stmts$1
            ];
    }
    if (match.TAG !== /* Expression */1) {
      return [
              env,
              string_tokens,
              stmts$1
            ];
    }
    var raw = match._0.directive;
    if (raw === undefined) {
      return [
              env,
              string_tokens,
              stmts$1
            ];
    }
    var strict = parser_env_bs.in_strict_mode(env) || raw === "use strict";
    var string_tokens$1 = {
      hd: t,
      tl: string_tokens
    };
    _param = [
      string_tokens$1,
      stmts$1
    ];
    _env = parser_env_bs.with_strict(strict, env);
    continue ;
  }}

function directives(env, term_fn, item_fn) {
  var env$1 = parser_env_bs.with_allow_directive(true, env);
  var match = statement_list$1(env$1, term_fn, item_fn, [
        /* [] */0,
        /* [] */0
      ]);
  var env$2 = parser_env_bs.with_allow_directive(false, match[0]);
  list.iter((function (param) {
          if (typeof param !== "number" && param.TAG === /* T_STRING */1) {
            var match = param._0;
            if (match[3]) {
              return parser_env_bs.strict_error_at(env$2, [
                          match[0],
                          /* StrictOctalLiteral */32
                        ]);
            } else {
              return ;
            }
          }
          return pervasives.failwith("Nooo: " + (lexer_flow_bs.Token.token_to_string(param) + "\n"));
        }), list.rev(match[1]));
  return [
          env$2,
          match[2]
        ];
}

var class_declaration = $$Object$1.class_declaration;

function module_body(term_fn, env) {
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var t = parser_env_bs.Peek.token(undefined, env);
    if (typeof t === "number" && t === 108) {
      return list.rev(acc);
    }
    if (curry._1(term_fn, t)) {
      return list.rev(acc);
    }
    _acc = {
      hd: module_item(env),
      tl: acc
    };
    continue ;
  }}

function module_body_with_directives(env, term_fn) {
  var match = curry._3(directives, env, term_fn, module_item);
  var stmts = curry._2(module_body, term_fn, match[0]);
  return list.fold_left((function (acc, stmt) {
                return {
                        hd: stmt,
                        tl: acc
                      };
              }), stmts, match[1]);
}

function identifier(restricted_error, env) {
  var loc = parser_env_bs.Peek.loc(undefined, env);
  var name = parser_env_bs.Peek.value(undefined, env);
  var t = parser_env_bs.Peek.token(undefined, env);
  var exit = 0;
  if (typeof t === "number" && t === 28) {
    if (parser_env_bs.in_strict_mode(env)) {
      parser_env_bs.strict_error(env, /* StrictReservedWord */40);
    } else if (parser_env_bs.no_let(env)) {
      parser_env_bs.error(env, {
            TAG: /* UnexpectedToken */1,
            _0: name
          });
    }
    parser_env_bs.Eat.token(env);
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (parser_env_bs.is_strict_reserved(name)) {
      parser_env_bs.strict_error(env, /* StrictReservedWord */40);
      parser_env_bs.Eat.token(env);
    } else if (typeof t === "number" && !(t > 64 || t < 60)) {
      parser_env_bs.Expect.token(env, t);
    } else {
      parser_env_bs.Expect.token(env, /* T_IDENTIFIER */0);
    }
  }
  if (restricted_error !== undefined && parser_env_bs.is_restricted(name)) {
    parser_env_bs.strict_error_at(env, [
          loc,
          restricted_error
        ]);
  }
  return [
          loc,
          name
        ];
}

function statement_list_with_directives(term_fn, env) {
  var match = curry._3(directives, env, term_fn, (function (eta) {
          return statement_list_item(undefined, eta);
        }));
  var env$1 = match[0];
  var stmts = curry._2(statement_list, term_fn, env$1);
  var stmts$1 = list.fold_left((function (acc, stmt) {
          return {
                  hd: stmt,
                  tl: acc
                };
        }), stmts, match[1]);
  return [
          stmts$1,
          parser_env_bs.in_strict_mode(env$1)
        ];
}

function program(env) {
  var stmts = module_body_with_directives(env, (function (param) {
          return false;
        }));
  var end_loc = parser_env_bs.Peek.loc(undefined, env);
  parser_env_bs.Expect.token(env, /* T_EOF */108);
  var loc = stmts ? loc_bs.btwn(list.hd(stmts)[0], list.hd(list.rev(stmts))[0]) : end_loc;
  var comments = list.rev(parser_env_bs.comments(env));
  return [
          loc,
          stmts,
          comments
        ];
}

function expression(env) {
  var expr = curry._1(Expression$1.assignment, env);
  var match = parser_env_bs.Peek.token(undefined, env);
  if (typeof match === "number" && match === 10) {
    return curry._2(Expression$1.sequence, env, {
                hd: expr,
                tl: /* [] */0
              });
  } else {
    return expr;
  }
}

function identifier_with_type(env, no_optionalOpt, restricted_error) {
  var no_optional = no_optionalOpt !== undefined ? no_optionalOpt : false;
  return parser_common_bs.with_loc((function (param) {
                var name = identifier(restricted_error, param);
                var optional = !no_optional && parser_env_bs.Peek.token(undefined, param) === /* T_PLING */79;
                if (optional) {
                  if (!parser_env_bs.should_parse_types(param)) {
                    parser_env_bs.error(param, /* UnexpectedTypeAnnotation */7);
                  }
                  parser_env_bs.Expect.token(param, /* T_PLING */79);
                }
                var typeAnnotation = parser_env_bs.Peek.token(undefined, param) === /* T_COLON */80 ? curry._1(Type$1.annotation, param) : undefined;
                return {
                        name: name,
                        typeAnnotation: typeAnnotation,
                        optional: optional
                      };
              }), env);
}

function block_body(env) {
  var start_loc = parser_env_bs.Peek.loc(undefined, env);
  parser_env_bs.Expect.token(env, /* T_LCURLY */1);
  var term_fn = function (t) {
    return t === /* T_RCURLY */2;
  };
  var body = curry._2(statement_list, term_fn, env);
  var end_loc = parser_env_bs.Peek.loc(undefined, env);
  parser_env_bs.Expect.token(env, /* T_RCURLY */2);
  return [
          loc_bs.btwn(start_loc, end_loc),
          {
            body: body
          }
        ];
}

function function_block_body(env) {
  var start_loc = parser_env_bs.Peek.loc(undefined, env);
  parser_env_bs.Expect.token(env, /* T_LCURLY */1);
  var term_fn = function (t) {
    return t === /* T_RCURLY */2;
  };
  var match = statement_list_with_directives(term_fn, env);
  var end_loc = parser_env_bs.Peek.loc(undefined, env);
  parser_env_bs.Expect.token(env, /* T_RCURLY */2);
  return [
          loc_bs.btwn(start_loc, end_loc),
          {
            body: match[0]
          },
          match[1]
        ];
}

caml_module.update_mod({
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "program"
        ],
        [
          /* Function */0,
          "statement"
        ],
        [
          /* Function */0,
          "statement_list_item"
        ],
        [
          /* Function */0,
          "statement_list"
        ],
        [
          /* Function */0,
          "statement_list_with_directives"
        ],
        [
          /* Function */0,
          "module_body"
        ],
        [
          /* Function */0,
          "expression"
        ],
        [
          /* Function */0,
          "conditional"
        ],
        [
          /* Function */0,
          "assignment"
        ],
        [
          /* Function */0,
          "left_hand_side"
        ],
        [
          /* Function */0,
          "object_initializer"
        ],
        [
          /* Function */0,
          "array_initializer"
        ],
        [
          /* Function */0,
          "identifier"
        ],
        [
          /* Function */0,
          "identifier_or_reserved_keyword"
        ],
        [
          /* Function */0,
          "identifier_with_type"
        ],
        [
          /* Function */0,
          "block_body"
        ],
        [
          /* Function */0,
          "function_block_body"
        ],
        [
          /* Function */0,
          "jsx_element"
        ],
        [
          /* Function */0,
          "pattern"
        ],
        [
          /* Function */0,
          "pattern_from_expr"
        ],
        [
          /* Function */0,
          "object_key"
        ],
        [
          /* Function */0,
          "class_declaration"
        ],
        [
          /* Function */0,
          "class_expression"
        ],
        [
          /* Function */0,
          "is_assignable_lhs"
        ]
      ]
    }, Parse, {
      program: program,
      statement: statement,
      statement_list_item: statement_list_item,
      statement_list: statement_list,
      statement_list_with_directives: statement_list_with_directives,
      module_body: module_body,
      expression: expression,
      conditional: Expression$1.conditional,
      assignment: Expression$1.assignment,
      left_hand_side: Expression$1.left_hand_side,
      object_initializer: $$Object$1._initializer,
      array_initializer: Expression$1.array_initializer,
      identifier: identifier,
      identifier_or_reserved_keyword: Expression$1.identifier_or_reserved_keyword,
      identifier_with_type: identifier_with_type,
      block_body: block_body,
      function_block_body: function_block_body,
      jsx_element: JSX$1.element,
      pattern: Pattern$1.pattern,
      pattern_from_expr: Pattern$1.from_expr,
      object_key: $$Object$1.key,
      class_declaration: class_declaration,
      class_expression: $$Object$1.class_expression,
      is_assignable_lhs: Expression$1.is_assignable_lhs
    });

function do_parse(env, parser, fail) {
  var ast = curry._1(parser, env);
  var error_list = filter_duplicate_errors(parser_env_bs.errors(env));
  if (fail && error_list !== /* [] */0) {
    throw {
          RE_EXN_ID: parse_error_bs.$$Error,
          _1: error_list,
          Error: new Error()
        };
  }
  return [
          ast,
          error_list
        ];
}

function parse_program(fail, token_sinkOpt, parse_optionsOpt, filename, content) {
  var token_sink = token_sinkOpt !== undefined ? caml_option.valFromOption(token_sinkOpt) : undefined;
  var parse_options = parse_optionsOpt !== undefined ? caml_option.valFromOption(parse_optionsOpt) : undefined;
  var env = parser_env_bs.init_env(caml_option.some(token_sink), caml_option.some(parse_options), filename, content);
  return do_parse(env, Parse.program, fail);
}

function program$1(failOpt, token_sinkOpt, parse_optionsOpt, content) {
  var fail = failOpt !== undefined ? failOpt : true;
  var token_sink = token_sinkOpt !== undefined ? caml_option.valFromOption(token_sinkOpt) : undefined;
  var parse_options = parse_optionsOpt !== undefined ? caml_option.valFromOption(parse_optionsOpt) : undefined;
  return parse_program(fail, caml_option.some(token_sink), caml_option.some(parse_options), undefined, content);
}

function program_file(failOpt, token_sinkOpt, parse_optionsOpt, content, filename) {
  var fail = failOpt !== undefined ? failOpt : true;
  var token_sink = token_sinkOpt !== undefined ? caml_option.valFromOption(token_sinkOpt) : undefined;
  var parse_options = parse_optionsOpt !== undefined ? caml_option.valFromOption(parse_optionsOpt) : undefined;
  return parse_program(fail, caml_option.some(token_sink), caml_option.some(parse_options), filename, content);
}

function json_file(failOpt, token_sinkOpt, parse_optionsOpt, content, filename) {
  var fail = failOpt !== undefined ? failOpt : true;
  var token_sink = token_sinkOpt !== undefined ? caml_option.valFromOption(token_sinkOpt) : undefined;
  var parse_options = parse_optionsOpt !== undefined ? caml_option.valFromOption(parse_optionsOpt) : undefined;
  var env = parser_env_bs.init_env(caml_option.some(token_sink), caml_option.some(parse_options), filename, content);
  var match = parser_env_bs.Peek.token(undefined, env);
  if (typeof match === "number") {
    switch (match) {
      case /* T_LCURLY */1 :
      case /* T_LBRACKET */7 :
      case /* T_NULL */29 :
      case /* T_FALSE */30 :
      case /* T_TRUE */31 :
          return do_parse(env, Parse.expression, fail);
      case /* T_MINUS */98 :
          var match$1 = parser_env_bs.Peek.token(1, env);
          if (typeof match$1 === "number") {
            parser_env_bs.error_unexpected(env);
            throw {
                  RE_EXN_ID: parse_error_bs.$$Error,
                  _1: parser_env_bs.errors(env),
                  Error: new Error()
                };
          }
          if (match$1.TAG === /* T_NUMBER */0) {
            return do_parse(env, Parse.expression, fail);
          }
          parser_env_bs.error_unexpected(env);
          throw {
                RE_EXN_ID: parse_error_bs.$$Error,
                _1: parser_env_bs.errors(env),
                Error: new Error()
              };
      default:
        parser_env_bs.error_unexpected(env);
        throw {
              RE_EXN_ID: parse_error_bs.$$Error,
              _1: parser_env_bs.errors(env),
              Error: new Error()
            };
    }
  } else {
    switch (match.TAG | 0) {
      case /* T_NUMBER */0 :
      case /* T_STRING */1 :
          return do_parse(env, Parse.expression, fail);
      default:
        parser_env_bs.error_unexpected(env);
        throw {
              RE_EXN_ID: parse_error_bs.$$Error,
              _1: parser_env_bs.errors(env),
              Error: new Error()
            };
    }
  }
}

function left_hand_side(env) {
  var ast = curry._1(Parse.left_hand_side, parser_env_bs.with_no_new(true, env));
  parser_env_bs.Expect.token(env, /* T_EOF */108);
  return ast;
}

function jsx_pragma_expression(content, filename) {
  var env = parser_env_bs.init_env(caml_option.some(undefined), caml_option.some(undefined), filename, content);
  return do_parse(env, left_hand_side, true);
}

var Token$9;

var Ast$8;

var $$Error$a;

var Token_1$9 = Token$9;
var Ast_1$8 = Ast$8;
var $$Error_1$a = $$Error$a;
var filter_duplicate_errors_1 = filter_duplicate_errors;
var Parse_1 = Parse;
var do_parse_1 = do_parse;
var parse_program_1 = parse_program;
var program_1 = program$1;
var program_file_1 = program_file;
var json_file_1 = json_file;
var jsx_pragma_expression_1 = jsx_pragma_expression;
/* ErrorSet Not a pure module */

var parser_flow_bs = {
	Token: Token_1$9,
	Ast: Ast_1$8,
	$$Error: $$Error_1$a,
	filter_duplicate_errors: filter_duplicate_errors_1,
	Parse: Parse_1,
	do_parse: do_parse_1,
	parse_program: parse_program_1,
	program: program_1,
	program_file: program_file_1,
	json_file: json_file_1,
	jsx_pragma_expression: jsx_pragma_expression_1
};

function get$3(dict, k) {
  if ((k in dict)) {
    return caml_option.some(dict[k]);
  }
  
}

var unsafeDeleteKey = (function (dict,key){
      delete dict[key];
     });

function entries(dict) {
  var keys = Object.keys(dict);
  var l = keys.length;
  var values = new Array(l);
  for(var i = 0; i < l; ++i){
    var key = keys[i];
    values[i] = [
      key,
      dict[key]
    ];
  }
  return values;
}

function values(dict) {
  var keys = Object.keys(dict);
  var l = keys.length;
  var values$1 = new Array(l);
  for(var i = 0; i < l; ++i){
    values$1[i] = dict[keys[i]];
  }
  return values$1;
}

function fromList(entries) {
  var dict = {};
  var _param = entries;
  while(true) {
    var param = _param;
    if (!param) {
      return dict;
    }
    var match = param.hd;
    dict[match[0]] = match[1];
    _param = param.tl;
    continue ;
  }}

function fromArray(entries) {
  var dict = {};
  var l = entries.length;
  for(var i = 0; i < l; ++i){
    var match = entries[i];
    dict[match[0]] = match[1];
  }
  return dict;
}

function map$4(f, source) {
  var target = {};
  var keys = Object.keys(source);
  var l = keys.length;
  for(var i = 0; i < l; ++i){
    var key = keys[i];
    target[key] = f(source[key]);
  }
  return target;
}

var get_1$3 = get$3;
var unsafeDeleteKey_1 = unsafeDeleteKey;
var entries_1 = entries;
var values_1 = values;
var fromList_1 = fromList;
var fromArray_1 = fromArray;
var map_1$4 = map$4;
/* No side effect */

var js_dict = {
	get: get_1$3,
	unsafeDeleteKey: unsafeDeleteKey_1,
	entries: entries_1,
	values: values_1,
	fromList: fromList_1,
	fromArray: fromArray_1,
	map: map_1$4
};

function _isInteger(value) {
  if (isFinite(value)) {
    return Math.floor(value) === value;
  } else {
    return false;
  }
}

var DecodeError = caml_exceptions.create("Json_decode.DecodeError");

function id$1(json) {
  return json;
}

function bool$2(json) {
  if (typeof json === "boolean") {
    return json;
  }
  throw {
        RE_EXN_ID: DecodeError,
        _1: "Expected boolean, got " + JSON.stringify(json),
        Error: new Error()
      };
}

function $$float$2(json) {
  if (typeof json === "number") {
    return json;
  }
  throw {
        RE_EXN_ID: DecodeError,
        _1: "Expected number, got " + JSON.stringify(json),
        Error: new Error()
      };
}

function $$int$2(json) {
  var f = $$float$2(json);
  if (_isInteger(f)) {
    return f;
  }
  throw {
        RE_EXN_ID: DecodeError,
        _1: "Expected integer, got " + JSON.stringify(json),
        Error: new Error()
      };
}

function string$2(json) {
  if (typeof json === "string") {
    return json;
  }
  throw {
        RE_EXN_ID: DecodeError,
        _1: "Expected string, got " + JSON.stringify(json),
        Error: new Error()
      };
}

function $$char(json) {
  var s = string$2(json);
  if (s.length === 1) {
    return caml_string.get(s, 0);
  }
  throw {
        RE_EXN_ID: DecodeError,
        _1: "Expected single-character string, got " + JSON.stringify(json),
        Error: new Error()
      };
}

function date(json) {
  return new Date(string$2(json));
}

function nullable(decode, json) {
  if (json === null) {
    return null;
  } else {
    return curry._1(decode, json);
  }
}

function nullAs(value, json) {
  if (json === null) {
    return value;
  }
  throw {
        RE_EXN_ID: DecodeError,
        _1: "Expected null, got " + JSON.stringify(json),
        Error: new Error()
      };
}

function array$1(decode, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    var target = new Array(length);
    for(var i = 0; i < length; ++i){
      var value;
      try {
        value = curry._1(decode, json[i]);
      }
      catch (raw_msg){
        var msg = caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.RE_EXN_ID === DecodeError) {
          throw {
                RE_EXN_ID: DecodeError,
                _1: msg._1 + ("\n\tin array at index " + String(i)),
                Error: new Error()
              };
        }
        throw msg;
      }
      target[i] = value;
    }
    return target;
  }
  throw {
        RE_EXN_ID: DecodeError,
        _1: "Expected array, got " + JSON.stringify(json),
        Error: new Error()
      };
}

function list$1(decode, json) {
  return array.to_list(array$1(decode, json));
}

function pair(decodeA, decodeB, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    if (length === 2) {
      try {
        return [
                curry._1(decodeA, json[0]),
                curry._1(decodeB, json[1])
              ];
      }
      catch (raw_msg){
        var msg = caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.RE_EXN_ID === DecodeError) {
          throw {
                RE_EXN_ID: DecodeError,
                _1: msg._1 + "\n\tin pair/tuple2",
                Error: new Error()
              };
        }
        throw msg;
      }
    } else {
      throw {
            RE_EXN_ID: DecodeError,
            _1: "Expected array of length 2, got array of length " + length,
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: DecodeError,
          _1: "Expected array, got " + JSON.stringify(json),
          Error: new Error()
        };
  }
}

function tuple3(decodeA, decodeB, decodeC, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    if (length === 3) {
      try {
        return [
                curry._1(decodeA, json[0]),
                curry._1(decodeB, json[1]),
                curry._1(decodeC, json[2])
              ];
      }
      catch (raw_msg){
        var msg = caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.RE_EXN_ID === DecodeError) {
          throw {
                RE_EXN_ID: DecodeError,
                _1: msg._1 + "\n\tin tuple3",
                Error: new Error()
              };
        }
        throw msg;
      }
    } else {
      throw {
            RE_EXN_ID: DecodeError,
            _1: "Expected array of length 3, got array of length " + length,
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: DecodeError,
          _1: "Expected array, got " + JSON.stringify(json),
          Error: new Error()
        };
  }
}

function tuple4(decodeA, decodeB, decodeC, decodeD, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    if (length === 4) {
      try {
        return [
                curry._1(decodeA, json[0]),
                curry._1(decodeB, json[1]),
                curry._1(decodeC, json[2]),
                curry._1(decodeD, json[3])
              ];
      }
      catch (raw_msg){
        var msg = caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.RE_EXN_ID === DecodeError) {
          throw {
                RE_EXN_ID: DecodeError,
                _1: msg._1 + "\n\tin tuple4",
                Error: new Error()
              };
        }
        throw msg;
      }
    } else {
      throw {
            RE_EXN_ID: DecodeError,
            _1: "Expected array of length 4, got array of length " + length,
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: DecodeError,
          _1: "Expected array, got " + JSON.stringify(json),
          Error: new Error()
        };
  }
}

function dict(decode, json) {
  if (typeof json === "object" && !Array.isArray(json) && json !== null) {
    var keys = Object.keys(json);
    var l = keys.length;
    var target = {};
    for(var i = 0; i < l; ++i){
      var key = keys[i];
      var value;
      try {
        value = curry._1(decode, json[key]);
      }
      catch (raw_msg){
        var msg = caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.RE_EXN_ID === DecodeError) {
          throw {
                RE_EXN_ID: DecodeError,
                _1: msg._1 + "\n\tin dict",
                Error: new Error()
              };
        }
        throw msg;
      }
      target[key] = value;
    }
    return target;
  }
  throw {
        RE_EXN_ID: DecodeError,
        _1: "Expected object, got " + JSON.stringify(json),
        Error: new Error()
      };
}

function field(key, decode, json) {
  if (typeof json === "object" && !Array.isArray(json) && json !== null) {
    var value = js_dict.get(json, key);
    if (value !== undefined) {
      try {
        return curry._1(decode, caml_option.valFromOption(value));
      }
      catch (raw_msg){
        var msg = caml_js_exceptions.internalToOCamlException(raw_msg);
        if (msg.RE_EXN_ID === DecodeError) {
          throw {
                RE_EXN_ID: DecodeError,
                _1: msg._1 + ("\n\tat field '" + (key + "'")),
                Error: new Error()
              };
        }
        throw msg;
      }
    } else {
      throw {
            RE_EXN_ID: DecodeError,
            _1: "Expected field \'" + key + "\'",
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: DecodeError,
          _1: "Expected object, got " + JSON.stringify(json),
          Error: new Error()
        };
  }
}

function at(key_path, decoder) {
  if (key_path) {
    var rest = key_path.tl;
    var key = key_path.hd;
    if (!rest) {
      return function (param) {
        return field(key, decoder, param);
      };
    }
    var partial_arg = at(rest, decoder);
    return function (param) {
      return field(key, partial_arg, param);
    };
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "Expected key_path to contain at least one element",
        Error: new Error()
      };
}

function optional(decode, json) {
  try {
    return caml_option.some(curry._1(decode, json));
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === DecodeError) {
      return ;
    }
    throw exn;
  }
}

function oneOf(decoders, json) {
  var _decoders = decoders;
  var _errors = /* [] */0;
  while(true) {
    var errors = _errors;
    var decoders$1 = _decoders;
    if (decoders$1) {
      try {
        return curry._1(decoders$1.hd, json);
      }
      catch (raw_e){
        var e = caml_js_exceptions.internalToOCamlException(raw_e);
        if (e.RE_EXN_ID === DecodeError) {
          _errors = {
            hd: e._1,
            tl: errors
          };
          _decoders = decoders$1.tl;
          continue ;
        }
        throw e;
      }
    } else {
      var revErrors = list.rev(errors);
      throw {
            RE_EXN_ID: DecodeError,
            _1: "All decoders given to oneOf failed. Here are all the errors: " + revErrors + ". And the JSON being decoded: " + JSON.stringify(json),
            Error: new Error()
          };
    }
  }}

function either(a, b) {
  var partial_arg_1 = {
    hd: b,
    tl: /* [] */0
  };
  var partial_arg = {
    hd: a,
    tl: partial_arg_1
  };
  return function (param) {
    return oneOf(partial_arg, param);
  };
}

function withDefault($$default, decode, json) {
  try {
    return curry._1(decode, json);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === DecodeError) {
      return $$default;
    }
    throw exn;
  }
}

function map$5(f, decode, json) {
  return curry._1(f, curry._1(decode, json));
}

function andThen(b, a, json) {
  return curry._2(b, curry._1(a, json), json);
}

var tuple2 = pair;

var DecodeError_1 = DecodeError;
var id_1$1 = id$1;
var bool_1$1 = bool$2;
var $$float_1$1 = $$float$2;
var $$int_1$1 = $$int$2;
var string_1$1 = string$2;
var $$char_1 = $$char;
var date_1 = date;
var nullable_1 = nullable;
var nullAs_1 = nullAs;
var array_1 = array$1;
var list_1 = list$1;
var pair_1 = pair;
var tuple2_1 = tuple2;
var tuple3_1 = tuple3;
var tuple4_1 = tuple4;
var dict_1 = dict;
var field_1 = field;
var at_1 = at;
var optional_1 = optional;
var oneOf_1 = oneOf;
var either_1 = either;
var withDefault_1 = withDefault;
var map_1$5 = map$5;
var andThen_1 = andThen;
/* No side effect */

var Json_decode_bs = {
	DecodeError: DecodeError_1,
	id: id_1$1,
	bool: bool_1$1,
	$$float: $$float_1$1,
	$$int: $$int_1$1,
	string: string_1$1,
	$$char: $$char_1,
	date: date_1,
	nullable: nullable_1,
	nullAs: nullAs_1,
	array: array_1,
	list: list_1,
	pair: pair_1,
	tuple2: tuple2_1,
	tuple3: tuple3_1,
	tuple4: tuple4_1,
	dict: dict_1,
	field: field_1,
	at: at_1,
	optional: optional_1,
	oneOf: oneOf_1,
	either: either_1,
	withDefault: withDefault_1,
	map: map_1$5,
	andThen: andThen_1
};

var classSelector = "ClassSelector";

var rule = "Rule";

var selector = "Selector";

var selectorList = "SelectorList";

var styleSheet = "StyleSheet";

var Type$2 = {
  anPlusB: "AnPlusB",
  atrule: "Atrule",
  atrulePrelude: "AtrulePrelude",
  attributeSelector: "AttributeSelector",
  block: "Block",
  brackets: "Brackets",
  cdc: "CDC",
  cdo: "CDO",
  classSelector: classSelector,
  combinator: "Combinator",
  comment: "Comment",
  declaration: "Declaration",
  declarationList: "DeclarationList",
  dimension: "Dimension",
  function_: "Function",
  hexColor: "HexColor",
  identifier: "Identifier",
  idSelector: "IdSelector",
  mediaFeature: "MediaFeature",
  mediaQuery: "MediaQuery",
  mediaQueryList: "MediaQueryList",
  nth: "Nth",
  number: "Number",
  operator: "Operator",
  parentheses: "Parentheses",
  percentage: "Percentage",
  pseudoClassSelector: "PseudoClassSelector",
  pseudoElementSelector: "PseudoElementSelector",
  ratio: "Ratio",
  raw: "Raw",
  rule: rule,
  selector: selector,
  selectorList: selectorList,
  string: "String",
  styleSheet: styleSheet,
  typeSelector: "TypeSelector",
  unicodeRange: "UnicodeRange",
  url: "Url",
  value: "Value",
  whiteSpace: "WhiteSpace"
};

var Internal = {
  Type: Type$2
};

function point(json) {
  return {
          offset: Json_decode_bs.field("offset", Json_decode_bs.$$int, json),
          line: Json_decode_bs.field("line", Json_decode_bs.$$int, json),
          column: Json_decode_bs.field("column", Json_decode_bs.$$int, json)
        };
}

function loc$2(json) {
  return {
          source: Json_decode_bs.field("source", Json_decode_bs.string, json),
          start: Json_decode_bs.field("start", point, json),
          end_: Json_decode_bs.field("end", point, json)
        };
}

var decoders = {};

function node(json) {
  var kind = Json_decode_bs.field("type", Json_decode_bs.string, json);
  var decoder;
  try {
    decoder = list.assoc(kind, decoders);
  }
  catch (exn){
    decoder = unknown;
  }
  return curry._1(decoder, json);
}

function styleSheet$1(json) {
  return {
          TAG: /* StyleSheet */0,
          _0: {
            loc: Json_decode_bs.optional((function (param) {
                    return Json_decode_bs.field("loc", loc$2, param);
                  }), json),
            children: Json_decode_bs.field("children", (function (param) {
                    return Json_decode_bs.array(node, param);
                  }), json)
          }
        };
}

function rule$1(json) {
  return {
          TAG: /* Rule */1,
          _0: {
            loc: Json_decode_bs.optional((function (param) {
                    return Json_decode_bs.field("loc", loc$2, param);
                  }), json),
            prelude: Json_decode_bs.field("prelude", node, json),
            block: Json_decode_bs.field("block", node, json)
          }
        };
}

function selectorList$1(json) {
  return {
          TAG: /* SelectorList */2,
          _0: {
            loc: Json_decode_bs.optional((function (param) {
                    return Json_decode_bs.field("loc", loc$2, param);
                  }), json),
            children: Json_decode_bs.field("children", (function (param) {
                    return Json_decode_bs.array(node, param);
                  }), json)
          }
        };
}

function selector$1(json) {
  return {
          TAG: /* Selector */3,
          _0: {
            loc: Json_decode_bs.optional((function (param) {
                    return Json_decode_bs.field("loc", loc$2, param);
                  }), json),
            children: Json_decode_bs.field("children", (function (param) {
                    return Json_decode_bs.array(node, param);
                  }), json)
          }
        };
}

function classSelector$1(json) {
  return {
          TAG: /* ClassSelector */4,
          _0: {
            loc: Json_decode_bs.optional((function (param) {
                    return Json_decode_bs.field("loc", loc$2, param);
                  }), json),
            name: Json_decode_bs.field("name", Json_decode_bs.string, json)
          }
        };
}

function unknown(json) {
  var kind = Json_decode_bs.field("type", Json_decode_bs.string, json);
  return {
          TAG: /* Unknown */5,
          _0: kind
        };
}

caml_obj.update_dummy(decoders, {
      hd: [
        styleSheet,
        styleSheet$1
      ],
      tl: {
        hd: [
          rule,
          rule$1
        ],
        tl: {
          hd: [
            selectorList,
            selectorList$1
          ],
          tl: {
            hd: [
              selector,
              selector$1
            ],
            tl: {
              hd: [
                classSelector,
                classSelector$1
              ],
              tl: /* [] */0
            }
          }
        }
      }
    });

var decode = node;

var Decoder = {
  point: point,
  loc: loc$2,
  decoders: decoders,
  node: node,
  styleSheet: styleSheet$1,
  rule: rule$1,
  selectorList: selectorList$1,
  selector: selector$1,
  classSelector: classSelector$1,
  unknown: unknown,
  decode: decode
};

function parse(_fileName, source) {
  var ast = CssTree.parse(source);
  return node(CssTree.toPlainObject(ast));
}

var Internal_1 = Internal;
var Decoder_1 = Decoder;
var parse_1 = parse;
/* css-tree Not a pure module */

var csstree_bs = {
	Internal: Internal_1,
	Decoder: Decoder_1,
	parse: parse_1
};

var Kind = {};

var Source = {};

var Internal$1 = {
  Kind: Kind,
  Source: Source
};

function source$3(json) {
  return {
          body: Json_decode_bs.field("body", Json_decode_bs.string, json),
          name: Json_decode_bs.field("name", Json_decode_bs.string, json)
        };
}

function loc$3(json) {
  return {
          start: Json_decode_bs.field("start", Json_decode_bs.$$int, json),
          end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
          source: Json_decode_bs.field("source", source$3, json)
        };
}

var decoders$1 = {};

function node$1(json) {
  var kind = Json_decode_bs.field("kind", Json_decode_bs.string, json);
  var decoder;
  try {
    decoder = list.assoc(kind, decoders$1);
  }
  catch (exn){
    decoder = unknown$1;
  }
  return curry._1(decoder, json);
}

function $$document(json) {
  return {
          TAG: /* Document */0,
          _0: {
            definitions: Json_decode_bs.field("definitions", (function (param) {
                    return Json_decode_bs.array(node$1, param);
                  }), json),
            loc: Json_decode_bs.field("loc", loc$3, json)
          }
        };
}

function objectTypeDefinition(json) {
  return {
          TAG: /* ObjectTypeDefinition */1,
          _0: {
            name: Json_decode_bs.field("name", node$1, json),
            interfaces: Json_decode_bs.field("interfaces", (function (param) {
                    return Json_decode_bs.array(node$1, param);
                  }), json),
            directives: Json_decode_bs.field("directives", (function (param) {
                    return Json_decode_bs.array(node$1, param);
                  }), json),
            fields: Json_decode_bs.field("fields", (function (param) {
                    return Json_decode_bs.array(node$1, param);
                  }), json),
            loc: Json_decode_bs.field("loc", loc$3, json)
          }
        };
}

function fieldDefinition(json) {
  return {
          TAG: /* FieldDefinition */2,
          _0: {
            name: Json_decode_bs.field("name", node$1, json),
            arguments: Json_decode_bs.field("arguments", (function (param) {
                    return Json_decode_bs.array(node$1, param);
                  }), json),
            type_: Json_decode_bs.field("type", node$1, json),
            directives: Json_decode_bs.field("directives", (function (param) {
                    return Json_decode_bs.array(node$1, param);
                  }), json),
            loc: Json_decode_bs.field("loc", loc$3, json)
          }
        };
}

function inputValueDefinition(json) {
  return {
          TAG: /* InputValueDefinition */3,
          _0: {
            name: Json_decode_bs.field("name", node$1, json),
            type_: Json_decode_bs.field("type", node$1, json),
            defaultValue: Json_decode_bs.optional((function (param) {
                    return Json_decode_bs.field("defaultValue", node$1, param);
                  }), json),
            directives: Json_decode_bs.field("directives", (function (param) {
                    return Json_decode_bs.array(node$1, param);
                  }), json),
            loc: Json_decode_bs.field("loc", loc$3, json)
          }
        };
}

function namedType(json) {
  return {
          TAG: /* NamedType */4,
          _0: {
            name: Json_decode_bs.field("name", node$1, json),
            loc: Json_decode_bs.field("loc", loc$3, json)
          }
        };
}

function nonNullType(json) {
  return {
          TAG: /* NonNullType */5,
          _0: {
            type_: Json_decode_bs.field("type", node$1, json),
            loc: Json_decode_bs.field("loc", loc$3, json)
          }
        };
}

function name(json) {
  return {
          TAG: /* Name */6,
          _0: {
            value: Json_decode_bs.field("value", Json_decode_bs.string, json),
            loc: Json_decode_bs.field("loc", loc$3, json)
          }
        };
}

function unknown$1(json) {
  var kind = Json_decode_bs.field("kind", Json_decode_bs.string, json);
  return {
          TAG: /* Unknown */7,
          _0: kind
        };
}

caml_obj.update_dummy(decoders$1, {
      hd: [
        Graphql.Kind.DOCUMENT,
        $$document
      ],
      tl: {
        hd: [
          Graphql.Kind.OBJECT_TYPE_DEFINITION,
          objectTypeDefinition
        ],
        tl: {
          hd: [
            Graphql.Kind.FIELD_DEFINITION,
            fieldDefinition
          ],
          tl: {
            hd: [
              Graphql.Kind.INPUT_VALUE_DEFINITION,
              inputValueDefinition
            ],
            tl: {
              hd: [
                Graphql.Kind.NAMED_TYPE,
                namedType
              ],
              tl: {
                hd: [
                  Graphql.Kind.NON_NULL_TYPE,
                  nonNullType
                ],
                tl: {
                  hd: [
                    Graphql.Kind.NAME,
                    name
                  ],
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    });

var decode$1 = node$1;

var Decoder$1 = {
  source: source$3,
  loc: loc$3,
  decoders: decoders$1,
  node: node$1,
  $$document: $$document,
  objectTypeDefinition: objectTypeDefinition,
  fieldDefinition: fieldDefinition,
  inputValueDefinition: inputValueDefinition,
  namedType: namedType,
  nonNullType: nonNullType,
  name: name,
  unknown: unknown$1,
  decode: decode$1
};

function parse$1(fileName, source) {
  var sourceFile = new Graphql.Source(source, fileName);
  return node$1(Graphql.parse(sourceFile));
}

var Internal_1$1 = Internal$1;
var Decoder_1$1 = Decoder$1;
var parse_1$1 = parse$1;
/* decoders Not a pure module */

var graphql_bs = {
	Internal: Internal_1$1,
	Decoder: Decoder_1$1,
	parse: parse_1$1
};

function format_obj_key(key) {
  if (string.contains(key, /* "-" */45)) {
    return "'" + (key + "'");
  } else {
    return key;
  }
}

function show_type(t) {
  if (typeof t === "number") {
    switch (t) {
      case /* Null */0 :
          return "null";
      case /* Number */1 :
          return "number";
      case /* Regex */2 :
          return "RegExp";
      case /* String */3 :
          return "string";
      case /* AnyFunction */4 :
          return "Function";
      case /* AnyObject */5 :
          return "Object";
      case /* Boolean */6 :
          return "boolean";
      case /* Unit */7 :
          return "void";
      case /* Any */8 :
          return "any";
      case /* Date */9 :
          return "Date";
      
    }
  } else {
    switch (t.TAG | 0) {
      case /* Function */0 :
          var match = t._0;
          var restParam = match.restParam;
          var typeParams = match.typeParams;
          var paramList = list.map((function (param) {
                  var type_of = param[1];
                  var name = param[0];
                  if (typeof type_of === "number") {
                    if (type_of === /* Unit */7) {
                      return "";
                    } else {
                      return name + (": " + show_type(type_of));
                    }
                  } else if (type_of.TAG === /* Optional */9) {
                    return name + ("?: " + show_type(type_of._0));
                  } else {
                    return name + (": " + show_type(type_of));
                  }
                }), match.formalParams);
          return (
                  list.length(typeParams) > 0 ? "<" : ""
                ) + (string.concat(", ", typeParams) + ((
                      list.length(typeParams) > 0 ? ">" : ""
                    ) + ("(" + (string.concat(", ", paramList) + ((
                            restParam !== undefined ? (
                                list.length(paramList) > 0 ? ", " : ""
                              ) + ("..." + (restParam[0] + (": " + show_type(restParam[1])))) : ""
                          ) + ("): " + show_type(match.returnType)))))));
      case /* Object */1 :
          return "{ " + (string.concat(", ", list.map((function (param) {
                              var prop = param[1];
                              var key = param[0];
                              if (key === "$$callProperty") {
                                return show_type(prop);
                              }
                              var tmp;
                              tmp = typeof prop === "number" || prop.TAG !== /* Function */0 ? ": " : "";
                              return format_obj_key(key) + ((
                                        param[2] ? "?" : ""
                                      ) + (tmp + show_type(prop)));
                            }), t._0)) + " }");
      case /* Class */2 :
          var $$extends = t._0;
          return (
                  $$extends !== undefined ? " extends " + show_type($$extends) : ""
                ) + ("{ " + (string.concat("; ", list.map((function (param) {
                                return param[0] + (": " + show_type(param[1]));
                              }), t._1)) + " }"));
      case /* Union */3 :
          return string.concat(" | ", list.map(show_type, t._0));
      case /* Array */4 :
          return show_type(t._0) + "[]";
      case /* Dict */5 :
          return "{ [key: string]: " + (show_type(t._0) + " }");
      case /* Tuple */6 :
          return "[" + (string.concat(", ", list.map(show_type, t._0)) + "]");
      case /* Typeof */7 :
          return "typeof " + show_type(t._0);
      case /* Named */8 :
          var type_params = t._0;
          return t._1 + (
                  list.length(type_params) > 0 ? "<" + (string.concat(", ", list.map(show_type, type_params)) + ">") : ""
                );
      case /* Optional */9 :
          return "?" + show_type(t._0);
      case /* StringLiteral */10 :
          return "\"" + (t._0 + "\"");
      case /* Promise */11 :
          return "Promise<" + (show_type(t._0) + ">");
      
    }
  }
}

function show_decl(s) {
  if (typeof s === "number") {
    return "";
  }
  switch (s.TAG | 0) {
    case /* VarDecl */0 :
        return "declare export var " + (s._0 + (": " + show_type(s._1)));
    case /* FuncDecl */1 :
        return "declare export function " + (s._0 + show_type(s._1));
    case /* ModuleDecl */2 :
        return "declare module " + (s._0 + (" {\n  " + (string.concat("\n  ", list.map(show_decl, s._1)) + "\n}")));
    case /* ExportsDecl */3 :
        return "declare module.exports: " + show_type(s._0);
    case /* TypeDecl */4 :
        return "declare type " + (s._0 + (" = " + show_type(s._2)));
    case /* ClassDecl */5 :
        var type_params = s._1;
        return "declare class " + (s._0 + (" " + ((
                      list.length(type_params) > 0 ? "<" : ""
                    ) + (string.concat(", ", type_params) + ((
                          list.length(type_params) > 0 ? ">" : ""
                        ) + show_type(s._2))))));
    case /* InterfaceDecl */6 :
        return "declare interface " + (s._0 + (" " + show_type(s._2)));
    case /* ImportDecl */7 :
        return "import type { " + (string.concat(", ", list.map((function (param) {
                            var local = param[1];
                            var remote = param[0];
                            if (remote === local) {
                              return remote;
                            } else {
                              return remote + (" as " + local);
                            }
                          }), s._0)) + (" } from '" + (s._1 + "'\n")));
    case /* ReactClass */8 :
        return "react class " + (s._0 + (" with prop type " + show_type(s._1)));
    case /* Ignore */9 :
        return "ignored: " + s._0;
    
  }
}

var format_obj_key_1 = format_obj_key;
var show_type_1 = show_type;
var show_decl_1 = show_decl;
/* No side effect */

var bsTypeFlow_bs = {
	format_obj_key: format_obj_key_1,
	show_type: show_type_1,
	show_decl: show_decl_1
};

function get$4(_key, table) {
  while(true) {
    var key = _key;
    var lookup;
    try {
      lookup = list.assoc(key, table);
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        lookup = /* NotFound */2;
      } else {
        throw exn;
      }
    }
    if (typeof lookup === "number") {
      return lookup;
    }
    if (lookup.TAG !== /* Variable */1) {
      return lookup;
    }
    _key = lookup._0;
    continue ;
  }}

function create$5(statements) {
  return list.filter(function (param) {
                return param[0] !== "";
              })(list.map((function (param) {
                    if (typeof param === "number") {
                      return [
                              "",
                              /* None */1
                            ];
                    }
                    switch (param.TAG | 0) {
                      case /* VarDecl */0 :
                          return [
                                  param._0,
                                  /* None */1
                                ];
                      case /* FuncDecl */1 :
                          return [
                                  param._0,
                                  {
                                    TAG: /* Type */0,
                                    _0: param._1
                                  }
                                ];
                      case /* TypeDecl */4 :
                          return [
                                  param._0,
                                  {
                                    TAG: /* Type */0,
                                    _0: param._2
                                  }
                                ];
                      case /* ClassDecl */5 :
                          return [
                                  param._0,
                                  /* Class */0
                                ];
                      default:
                        return [
                                "",
                                /* None */1
                              ];
                    }
                  }), statements));
}

function show(table) {
  list.iter((function (param) {
          var $$typeof = param[1];
          var tmp;
          if (typeof $$typeof === "number") {
            switch ($$typeof) {
              case /* Class */0 :
                  tmp = "Class";
                  break;
              case /* None */1 :
                  tmp = "None";
                  break;
              case /* NotFound */2 :
                  tmp = "NotFound";
                  break;
              
            }
          } else {
            tmp = $$typeof.TAG === /* Type */0 ? bsTypeFlow_bs.show_type($$typeof._0) : "typeof " + $$typeof._0;
          }
          console.log("typeof " + (param[0] + (" = " + tmp)));
          
        }), table);
  return pervasives.print_newline(undefined);
}

var get_1$4 = get$4;
var create_1$4 = create$5;
var show_1 = show;
/* No side effect */

var typetable_bs = {
	get: get_1$4,
	create: create_1$4,
	show: show_1
};

function unquote(str) {
  var has_start_quote = caml_string.get(str, 0) === /* "\"" */34 || caml_string.get(str, 0) === /* "'" */39;
  var has_end_quote = caml_string.get(str, str.length - 1 | 0) === /* "\"" */34 || caml_string.get(str, str.length - 1 | 0) === /* "'" */39;
  if (has_start_quote && has_end_quote) {
    return string.sub(str, 1, str.length - 2 | 0);
  } else {
    return str;
  }
}

function normalize_chars(param) {
  return string.map((function (ch) {
                if (ch === /* "-" */45 || ch === /* "$" */36) {
                  return /* "_" */95;
                } else {
                  return ch;
                }
              }), param);
}

function normalize_keywords(str) {
  switch (str) {
    case "end" :
        return "_end";
    case "to" :
        return "_to";
    case "type" :
        return "_type";
    default:
      return str;
  }
}

function normalize_name(name) {
  return normalize_keywords(normalize_chars(name));
}

function import_module_name(name) {
  return string.capitalize_ascii(normalize_keywords(normalize_chars(name)));
}

function to_module_name(str) {
  var name = unquote(str);
  return normalize_keywords(normalize_chars(name));
}

function to_type_param(str) {
  var name = "'" + string.uncapitalize_ascii(str);
  return normalize_keywords(normalize_chars(name));
}

function split$1(sep, _str, _acc) {
  while(true) {
    var acc = _acc;
    var str = _str;
    var len = str.length;
    var first_index;
    try {
      first_index = string.index(str, sep);
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        first_index = undefined;
      } else {
        throw exn;
      }
    }
    if (first_index === undefined) {
      return list.append(acc, {
                  hd: str,
                  tl: /* [] */0
                });
    }
    var beginning = caml_primitive.caml_int_min(len, first_index + 1 | 0);
    _acc = list.append(acc, {
          hd: string.sub(str, 0, caml_primitive.caml_int_max(0, beginning - 1 | 0)),
          tl: /* [] */0
        });
    _str = string.sub(str, beginning, len - beginning | 0);
    continue ;
  }}

function uniq(param) {
  if (!param) {
    return /* [] */0;
  }
  var h = param.hd;
  var no_dups = uniq(list.filter(function (x) {
              return caml_obj.caml_notequal(x, h);
            })(param.tl));
  return {
          hd: h,
          tl: no_dups
        };
}

function optional$1(type_of) {
  if (typeof type_of === "number" || type_of.TAG !== /* Optional */9) {
    return false;
  } else {
    return true;
  }
}

function type_param(params, t) {
  return list.exists((function (p) {
                return caml_obj.caml_equal(p, t);
              }), params);
}

function class_type(t, table) {
  var match = typetable_bs.get(t, table);
  if (typeof match === "number") {
    return match === 0;
  } else {
    return false;
  }
}

function string_union(param) {
  return list.for_all((function (param) {
                if (typeof param === "number" || param.TAG !== /* StringLiteral */10) {
                  return false;
                } else {
                  return true;
                }
              }), param);
}

function react_component(param) {
  if (typeof param === "number") {
    return false;
  }
  switch (param.TAG | 0) {
    case /* Function */0 :
        var match = param._0.returnType;
        if (typeof match === "number") {
          return false;
        }
        if (match.TAG !== /* Named */8) {
          return false;
        }
        switch (match._1) {
          case "Element" :
              var match$1 = match._2;
              if (match$1 === "React") {
                return true;
              } else {
                return false;
              }
          case "React$Element" :
              return match._2 === undefined;
          default:
            return false;
        }
    case /* Class */2 :
        var match$2 = param._0;
        if (match$2 === undefined) {
          return false;
        }
        if (typeof match$2 === "number") {
          return false;
        }
        if (match$2.TAG !== /* Named */8) {
          return false;
        }
        switch (match$2._1) {
          case "Component" :
              var match$3 = match$2._2;
              if (match$3 === "React") {
                return true;
              } else {
                return false;
              }
          case "React$Component" :
              return match$2._2 === undefined;
          default:
            return false;
        }
    case /* Named */8 :
        switch (param._1) {
          case "React$ComponentType" :
          case "React$StatelessFunctionalComponent" :
              return param._2 === undefined;
          case "ComponentType" :
          case "StatelessFunctionalComponent" :
              break;
          default:
            return false;
        }
        var match$4 = param._2;
        if (match$4 === "React") {
          return true;
        } else {
          return false;
        }
    default:
      return false;
  }
}

var Is = {
  optional: optional$1,
  type_param: type_param,
  class_type: class_type,
  string_union: string_union,
  react_component: react_component
};

function extract_component_type(component) {
  if (typeof component === "number") {
    return /* Unit */7;
  }
  switch (component.TAG | 0) {
    case /* Function */0 :
        var match = component._0;
        var match$1 = match.formalParams;
        if (!match$1) {
          return /* Unit */7;
        }
        var match$2 = match.returnType;
        if (typeof match$2 === "number") {
          return /* Unit */7;
        }
        if (match$2.TAG !== /* Named */8) {
          return /* Unit */7;
        }
        var props = match$1.hd[1];
        switch (match$2._1) {
          case "Element" :
              var match$3 = match$2._2;
              if (match$3 === "React") {
                return props;
              } else {
                return /* Unit */7;
              }
          case "React$Element" :
              if (match$2._2 !== undefined) {
                return /* Unit */7;
              } else {
                return props;
              }
          default:
            return /* Unit */7;
        }
    case /* Object */1 :
        return component;
    case /* Class */2 :
        var match$4 = component._0;
        if (match$4 === undefined) {
          return /* Unit */7;
        }
        if (typeof match$4 === "number") {
          return /* Unit */7;
        }
        if (match$4.TAG !== /* Named */8) {
          return /* Unit */7;
        }
        var match$5 = match$4._0;
        if (!match$5) {
          return /* Unit */7;
        }
        var props$1 = match$5.hd;
        switch (match$4._1) {
          case "Component" :
              var match$6 = match$4._2;
              if (match$6 === "React") {
                return props$1;
              } else {
                return /* Unit */7;
              }
          case "React$Component" :
              if (match$4._2 !== undefined) {
                return /* Unit */7;
              } else {
                return props$1;
              }
          default:
            return /* Unit */7;
        }
    case /* Named */8 :
        var match$7 = component._0;
        if (!match$7) {
          if (component._2 !== undefined) {
            return /* Unit */7;
          } else {
            return component;
          }
        }
        var props$2 = match$7.hd;
        switch (component._1) {
          case "React$ComponentType" :
          case "React$StatelessFunctionalComponent" :
              if (component._2 !== undefined) {
                return /* Unit */7;
              } else {
                return props$2;
              }
          case "ComponentType" :
          case "StatelessFunctionalComponent" :
              break;
          default:
            return /* Unit */7;
        }
        var match$8 = component._2;
        if (match$8 === "React") {
          return props$2;
        } else {
          return /* Unit */7;
        }
    default:
      return /* Unit */7;
  }
}

function extract_props(type_table, component) {
  var component_type = extract_component_type(component);
  if (typeof component_type === "number") {
    return component_type;
  }
  if (component_type.TAG !== /* Named */8) {
    return component_type;
  }
  var t = typetable_bs.get(component_type._1, type_table);
  if (typeof t === "number" || t.TAG !== /* Type */0) {
    return component_type;
  } else {
    return t._0;
  }
}

var React = {
  extract_component_type: extract_component_type,
  extract_props: extract_props
};

function walk(replacer) {
  var or_value = function (transform, t) {
    var result = curry._1(transform, t);
    if (result !== undefined) {
      return caml_option.valFromOption(result);
    } else {
      return t;
    }
  };
  var walk_type = function (_recurseOpt, _walkable) {
    while(true) {
      var recurseOpt = _recurseOpt;
      var walkable = _walkable;
      var recurse = recurseOpt !== undefined ? recurseOpt : true;
      if (typeof walkable === "number") {
        return or_value(replacer, walkable);
      }
      switch (walkable.TAG | 0) {
        case /* Function */0 :
            var func = walkable._0;
            var new_t = curry._1(replacer, walkable);
            if (new_t !== undefined && recurse) {
              _walkable = new_t;
              _recurseOpt = false;
              continue ;
            }
            var match = func.restParam;
            return {
                    TAG: /* Function */0,
                    _0: {
                      typeParams: func.typeParams,
                      formalParams: list.map((function (param) {
                              return [
                                      param[0],
                                      walk_type(undefined, param[1])
                                    ];
                            }), func.formalParams),
                      restParam: match !== undefined ? [
                          match[0],
                          walk_type(undefined, match[1])
                        ] : undefined,
                      returnType: walk_type(undefined, func.returnType)
                    }
                  };
        case /* Object */1 :
            var new_t$1 = curry._1(replacer, walkable);
            if (new_t$1 !== undefined && recurse) {
              _walkable = new_t$1;
              _recurseOpt = false;
              continue ;
            }
            return {
                    TAG: /* Object */1,
                    _0: list.map((function (param) {
                            return [
                                    param[0],
                                    walk_type(undefined, param[1]),
                                    param[2]
                                  ];
                          }), walkable._0)
                  };
        case /* Class */2 :
            var $$extends = walkable._0;
            var new_t$2 = curry._1(replacer, walkable);
            if (new_t$2 !== undefined && recurse) {
              _walkable = new_t$2;
              _recurseOpt = false;
              continue ;
            }
            return {
                    TAG: /* Class */2,
                    _0: $$extends !== undefined ? walk_type(undefined, $$extends) : undefined,
                    _1: list.map((function (param) {
                            return [
                                    param[0],
                                    walk_type(undefined, param[1])
                                  ];
                          }), walkable._1)
                  };
        case /* Union */3 :
            var new_t$3 = curry._1(replacer, walkable);
            if (new_t$3 !== undefined && recurse) {
              _walkable = new_t$3;
              _recurseOpt = false;
              continue ;
            }
            return {
                    TAG: /* Union */3,
                    _0: list.map((function (__x) {
                            return walk_type(undefined, __x);
                          }), walkable._0)
                  };
        case /* Array */4 :
            var t = walkable._0;
            var new_t$4 = curry._1(replacer, walkable);
            if (new_t$4 === undefined) {
              return {
                      TAG: /* Array */4,
                      _0: walk_type(undefined, t)
                    };
            }
            if (!recurse) {
              return {
                      TAG: /* Array */4,
                      _0: walk_type(undefined, t)
                    };
            }
            _walkable = new_t$4;
            _recurseOpt = false;
            continue ;
        case /* Dict */5 :
            var t$1 = walkable._0;
            var new_t$5 = curry._1(replacer, walkable);
            if (new_t$5 === undefined) {
              return {
                      TAG: /* Dict */5,
                      _0: walk_type(undefined, t$1)
                    };
            }
            if (!recurse) {
              return {
                      TAG: /* Dict */5,
                      _0: walk_type(undefined, t$1)
                    };
            }
            _walkable = new_t$5;
            _recurseOpt = false;
            continue ;
        case /* Tuple */6 :
            var new_t$6 = curry._1(replacer, walkable);
            if (new_t$6 !== undefined && recurse) {
              _walkable = new_t$6;
              _recurseOpt = false;
              continue ;
            }
            return {
                    TAG: /* Tuple */6,
                    _0: list.map((function (__x) {
                            return walk_type(undefined, __x);
                          }), walkable._0)
                  };
        case /* Typeof */7 :
            var t$2 = walkable._0;
            var new_t$7 = curry._1(replacer, walkable);
            if (new_t$7 === undefined) {
              return {
                      TAG: /* Typeof */7,
                      _0: walk_type(undefined, t$2)
                    };
            }
            if (!recurse) {
              return {
                      TAG: /* Typeof */7,
                      _0: walk_type(undefined, t$2)
                    };
            }
            _walkable = new_t$7;
            _recurseOpt = false;
            continue ;
        case /* Named */8 :
            var new_t$8 = curry._1(replacer, walkable);
            if (new_t$8 !== undefined && recurse) {
              _walkable = new_t$8;
              _recurseOpt = false;
              continue ;
            }
            return {
                    TAG: /* Named */8,
                    _0: list.map((function (__x) {
                            return walk_type(undefined, __x);
                          }), walkable._0),
                    _1: walkable._1,
                    _2: walkable._2
                  };
        case /* Optional */9 :
            var t$3 = walkable._0;
            var new_t$9 = curry._1(replacer, walkable);
            if (new_t$9 === undefined) {
              return {
                      TAG: /* Optional */9,
                      _0: walk_type(undefined, t$3)
                    };
            }
            if (!recurse) {
              return {
                      TAG: /* Optional */9,
                      _0: walk_type(undefined, t$3)
                    };
            }
            _walkable = new_t$9;
            _recurseOpt = false;
            continue ;
        case /* Promise */11 :
            var t$4 = walkable._0;
            var new_t$10 = curry._1(replacer, walkable);
            if (new_t$10 === undefined) {
              return {
                      TAG: /* Promise */11,
                      _0: walk_type(undefined, t$4)
                    };
            }
            if (!recurse) {
              return {
                      TAG: /* Promise */11,
                      _0: walk_type(undefined, t$4)
                    };
            }
            _walkable = new_t$10;
            _recurseOpt = false;
            continue ;
        default:
          return or_value(replacer, walkable);
      }
    }  };
  return function (s) {
    if (typeof s === "number") {
      return s;
    }
    switch (s.TAG | 0) {
      case /* VarDecl */0 :
          return {
                  TAG: /* VarDecl */0,
                  _0: s._0,
                  _1: walk_type(undefined, s._1)
                };
      case /* FuncDecl */1 :
          return {
                  TAG: /* FuncDecl */1,
                  _0: s._0,
                  _1: walk_type(undefined, s._1)
                };
      case /* TypeDecl */4 :
          return {
                  TAG: /* TypeDecl */4,
                  _0: s._0,
                  _1: s._1,
                  _2: walk_type(undefined, s._2)
                };
      case /* ClassDecl */5 :
          return {
                  TAG: /* ClassDecl */5,
                  _0: s._0,
                  _1: s._1,
                  _2: walk_type(undefined, s._2)
                };
      default:
        return s;
    }
  };
}

var unquote_1 = unquote;
var normalize_chars_1 = normalize_chars;
var normalize_keywords_1 = normalize_keywords;
var normalize_name_1 = normalize_name;
var import_module_name_1 = import_module_name;
var to_module_name_1 = to_module_name;
var to_type_param_1 = to_type_param;
var split_1$1 = split$1;
var uniq_1 = uniq;
var Is_1 = Is;
var React_1 = React;
var walk_1 = walk;
/* No side effect */

var genutils_bs = {
	unquote: unquote_1,
	normalize_chars: normalize_chars_1,
	normalize_keywords: normalize_keywords_1,
	normalize_name: normalize_name_1,
	import_module_name: import_module_name_1,
	to_module_name: to_module_name_1,
	to_type_param: to_type_param_1,
	split: split_1$1,
	uniq: uniq_1,
	Is: Is_1,
	React: React_1,
	walk: walk_1
};

function add$3(name, from, table) {
  return {
          hd: [
            name,
            from
          ],
          tl: table
        };
}

function get$5(key, table) {
  var lookup;
  try {
    lookup = list.assoc(key, table);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      lookup = [
        "NOT_FOUND",
        "NOT_FOUND"
      ];
    } else {
      throw exn;
    }
  }
  if (lookup[0] === "NOT_FOUND" && lookup[1] === "NOT_FOUND") {
    return ;
  } else {
    return lookup;
  }
}

function show$1(table) {
  list.iter((function (param) {
          var match = param[1];
          var remote_name = match[0];
          var local_name = param[0];
          console.log("import type { " + ((
                  remote_name === local_name ? remote_name : remote_name + (" as " + local_name)
                ) + (" } from '" + (match[1] + "'"))));
          
        }), table);
  return pervasives.print_newline(undefined);
}

var ImportTable = {
  add: add$3,
  get: get$5,
  show: show$1
};

function process_module(imports) {
  var partial_arg = genutils_bs.walk(function (_s) {
        if (typeof _s === "number") {
          return ;
        }
        if (_s.TAG !== /* Named */8) {
          return ;
        }
        var match = get$5(_s._1, imports);
        if (match !== undefined) {
          return {
                  TAG: /* Named */8,
                  _0: _s._0,
                  _1: match[0],
                  _2: genutils_bs.import_module_name(match[1])
                };
        }
        
      });
  return function (param) {
    return list.map(partial_arg, param);
  };
}

var partial_arg = {
  imports: /* [] */0,
  statements: /* [] */0
};

function linker(param) {
  return list.fold_left((function (param, statement) {
                var statements = param.statements;
                var imports = param.imports;
                if (typeof statement !== "number") {
                  switch (statement.TAG | 0) {
                    case /* ModuleDecl */2 :
                        return {
                                imports: imports,
                                statements: pervasives.$at(statements, {
                                      hd: {
                                        TAG: /* ModuleDecl */2,
                                        _0: statement._0,
                                        _1: process_module(imports)(statement._1)
                                      },
                                      tl: /* [] */0
                                    })
                              };
                    case /* ImportDecl */7 :
                        var source = statement._1;
                        return {
                                imports: pervasives.$at(imports, list.map((function (param) {
                                            return [
                                                    param[1],
                                                    [
                                                      param[0],
                                                      source
                                                    ]
                                                  ];
                                          }), statement._0)),
                                statements: pervasives.$at(statements, {
                                      hd: statement,
                                      tl: /* [] */0
                                    })
                              };
                      
                  }
                }
                return {
                        imports: imports,
                        statements: pervasives.$at(statements, {
                              hd: statement,
                              tl: /* [] */0
                            })
                      };
              }), partial_arg, param);
}

function show_imports(program) {
  var linked_program = linker(program);
  return show$1(linked_program.imports);
}

function link(program) {
  return linker(program).statements;
}

var ImportTable_1 = ImportTable;
var process_module_1 = process_module;
var linker_1 = linker;
var show_imports_1 = show_imports;
var link_1 = link;
/* No side effect */

var imports_bs = {
	ImportTable: ImportTable_1,
	process_module: process_module_1,
	linker: linker_1,
	show_imports: show_imports_1,
	link: link_1
};

function selectorChildrenToBsTypeAst(classSelector) {
  if (classSelector.TAG === /* ClassSelector */4) {
    return {
            hd: {
              TAG: /* VarDecl */0,
              _0: classSelector._0.name,
              _1: /* String */3
            },
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

function selectorToBsTypeAst(selector) {
  if (selector.TAG === /* Selector */3) {
    return list.flatten(list.map(selectorChildrenToBsTypeAst, array.to_list(selector._0.children)));
  } else {
    return /* [] */0;
  }
}

function selectorListToBsTypeAst(selectorList) {
  if (selectorList.TAG === /* SelectorList */2) {
    return list.flatten(list.map(selectorToBsTypeAst, array.to_list(selectorList._0.children)));
  } else {
    return /* [] */0;
  }
}

function ruleToBsTypeAst(rule) {
  if (rule.TAG === /* Rule */1) {
    return selectorListToBsTypeAst(rule._0.prelude);
  } else {
    return /* [] */0;
  }
}

function cssAstToBsTypeAst(fileName, sheet) {
  if (sheet.TAG === /* StyleSheet */0) {
    return {
            TAG: /* ModuleDecl */2,
            _0: fileName,
            _1: list.flatten(list.map(ruleToBsTypeAst, array.to_list(sheet._0.children)))
          };
  } else {
    return /* Noop */0;
  }
}

var selectorChildrenToBsTypeAst_1 = selectorChildrenToBsTypeAst;
var selectorToBsTypeAst_1 = selectorToBsTypeAst;
var selectorListToBsTypeAst_1 = selectorListToBsTypeAst;
var ruleToBsTypeAst_1 = ruleToBsTypeAst;
var cssAstToBsTypeAst_1 = cssAstToBsTypeAst;
/* No side effect */

var cssBsType_bs = {
	selectorChildrenToBsTypeAst: selectorChildrenToBsTypeAst_1,
	selectorToBsTypeAst: selectorToBsTypeAst_1,
	selectorListToBsTypeAst: selectorListToBsTypeAst_1,
	ruleToBsTypeAst: ruleToBsTypeAst_1,
	cssAstToBsTypeAst: cssAstToBsTypeAst_1
};

function inline_union_types(types) {
  return function (param) {
    return list.map((function (param) {
                  var t = param[1];
                  var name = param[0];
                  if (typeof t === "number") {
                    return [
                            name,
                            t
                          ];
                  }
                  if (t.TAG !== /* Named */8) {
                    return [
                            name,
                            t
                          ];
                  }
                  if (list.length(t._0) !== 0) {
                    return [
                            name,
                            t
                          ];
                  }
                  var inner_type = typetable_bs.get(t._1, types);
                  if (typeof inner_type === "number") {
                    return [
                            name,
                            t
                          ];
                  }
                  if (inner_type.TAG !== /* Type */0) {
                    return [
                            name,
                            t
                          ];
                  }
                  var inner_type$1 = inner_type._0;
                  if (typeof inner_type$1 === "number" || inner_type$1.TAG !== /* Union */3) {
                    return [
                            name,
                            t
                          ];
                  } else {
                    return [
                            name,
                            inner_type$1
                          ];
                  }
                }), param);
  };
}

function optimize_function(types, func) {
  if (typeof func === "number") {
    return func;
  }
  if (func.TAG !== /* Function */0) {
    return func;
  }
  var func$1 = func._0;
  var formalParams = inline_union_types(types)(func$1.formalParams);
  return {
          TAG: /* Function */0,
          _0: {
            typeParams: func$1.typeParams,
            formalParams: formalParams,
            restParam: func$1.restParam,
            returnType: func$1.returnType
          }
        };
}

function optimize_statements(types, statements) {
  return list.map((function (s) {
                if (typeof s === "number" || s.TAG !== /* FuncDecl */1) {
                  return s;
                } else {
                  return {
                          TAG: /* FuncDecl */1,
                          _0: s._0,
                          _1: optimize_function(types, s._1)
                        };
                }
              }), statements);
}

function optimize(types, program) {
  if (typeof program === "number" || program.TAG !== /* ModuleDecl */2) {
    return program;
  } else {
    return {
            TAG: /* ModuleDecl */2,
            _0: program._0,
            _1: optimize_statements(types, program._1)
          };
  }
}

var inline_union_types_1 = inline_union_types;
var optimize_function_1 = optimize_function;
var optimize_statements_1 = optimize_statements;
var optimize_1 = optimize;
/* No side effect */

var optimizer_bs = {
	inline_union_types: inline_union_types_1,
	optimize_function: optimize_function_1,
	optimize_statements: optimize_statements_1,
	optimize: optimize_1
};

var $$Error$b = caml_exceptions.create("Diagnostic-ReasonablyTyped.Error");

function diagnosticOfFlow(errors, source) {
  return array.of_list(list.map((function (param) {
                    var match = param[0].start;
                    return {
                            source: source,
                            line: match.line,
                            column: match.column
                          };
                  }), errors));
}

function computeColumnAndLine(_columnOpt, _lineOpt, _preOpt, _source, _pos) {
  while(true) {
    var columnOpt = _columnOpt;
    var lineOpt = _lineOpt;
    var preOpt = _preOpt;
    var pos = _pos;
    var source = _source;
    var column = columnOpt !== undefined ? columnOpt : 1;
    var line = lineOpt !== undefined ? lineOpt : 1;
    var pre = preOpt !== undefined ? preOpt : "";
    if (pos === 0) {
      return [
              column,
              line
            ];
    }
    var head = source[0];
    var tail = source.slice(1);
    _pos = pos - 1 | 0;
    _source = tail;
    _preOpt = head;
    _lineOpt = pre === "\n" ? line + 1 | 0 : line;
    _columnOpt = pre === "\n" ? 1 : column + 1 | 0;
    continue ;
  }}

function diagnosticOfTs(sourceFile) {
  var text = sourceFile.text;
  return array.map((function (d) {
                var match = computeColumnAndLine(undefined, undefined, undefined, text, d.start);
                return {
                        source: text,
                        line: match[1],
                        column: match[0]
                      };
              }), sourceFile.parseDiagnostics);
}

var $$Error_1$b = $$Error$b;
var diagnosticOfFlow_1 = diagnosticOfFlow;
var computeColumnAndLine_1 = computeColumnAndLine;
var diagnosticOfTs_1 = diagnosticOfTs;
/* No side effect */

var diagnostic_bs = {
	$$Error: $$Error_1$b,
	diagnosticOfFlow: diagnosticOfFlow_1,
	computeColumnAndLine: computeColumnAndLine_1,
	diagnosticOfTs: diagnosticOfTs_1
};

var intctx = {
  loc: loc_bs.none,
  is_params: false
};

var ModulegenDeclError = caml_exceptions.create("FlowBsType-ReasonablyTyped.ModulegenDeclError");

var ModulegenTypeError = caml_exceptions.create("FlowBsType-ReasonablyTyped.ModulegenTypeError");

var ModulegenStatementError = caml_exceptions.create("FlowBsType-ReasonablyTyped.ModulegenStatementError");

function loc_to_msg(param) {
  var _end = param._end;
  var start = param.start;
  var source = param.source;
  return (
          source !== undefined ? " [in " + (loc_bs.string_of_filename(source) + " ") : " ["
        ) + ("from " + (String(start.line) + (":" + (String(start.column) + (" to " + (String(_end.line) + (":" + (String(_end.column) + "]"))))))));
}

function not_supported($$interface, context) {
  return $$interface + (" is not currently supported" + loc_to_msg(context.loc));
}

function sanity_check(problem, context) {
  return problem + (" should not happen" + loc_to_msg(context.loc));
}

function string_of_id(param) {
  return param[1];
}

function string_of_key(key) {
  switch (key.TAG | 0) {
    case /* Literal */0 :
        var match = key._0;
        var value = match[1].value;
        if (typeof value !== "number" && value.TAG === /* String */0) {
          return value._0;
        }
        throw {
              RE_EXN_ID: ModulegenTypeError,
              _1: sanity_check("Non-string as object property", {
                    loc: match[0],
                    is_params: false
                  }),
              Error: new Error()
            };
    case /* Identifier */1 :
        return string_of_id(key._0);
    case /* Computed */2 :
        throw {
              RE_EXN_ID: ModulegenTypeError,
              _1: not_supported("Computed object properties", {
                    loc: key._0[0],
                    is_params: false
                  }),
              Error: new Error()
            };
    
  }
}

function extract_type_params(ctx, type_parameters) {
  var get_params = function (param) {
    var match = param[1];
    var loc = param[0];
    if (match.bound !== undefined) {
      throw {
            RE_EXN_ID: ModulegenTypeError,
            _1: not_supported("Type parameter bounds", {
                  loc: loc,
                  is_params: ctx.is_params
                }),
            Error: new Error()
          };
    }
    if (match.variance !== undefined) {
      throw {
            RE_EXN_ID: ModulegenTypeError,
            _1: not_supported("Type parameter variance", {
                  loc: loc,
                  is_params: ctx.is_params
                }),
            Error: new Error()
          };
    }
    if (match.default !== undefined) {
      throw {
            RE_EXN_ID: ModulegenTypeError,
            _1: not_supported("Type parameter defaults", {
                  loc: loc,
                  is_params: ctx.is_params
                }),
            Error: new Error()
          };
    }
    return match.name;
  };
  if (type_parameters !== undefined) {
    return list.map(get_params, type_parameters[1].params);
  } else {
    return /* [] */0;
  }
}

function type_to_bstype(ctx, o) {
  if (typeof o === "number") {
    switch (o) {
      case /* Any */0 :
      case /* Mixed */1 :
          return /* Any */8;
      case /* Empty */2 :
          throw {
                RE_EXN_ID: ModulegenTypeError,
                _1: not_supported("Empty type", ctx),
                Error: new Error()
              };
      case /* Void */3 :
          return /* Unit */7;
      case /* Null */4 :
          return /* Null */0;
      case /* Number */5 :
          return /* Number */1;
      case /* String */6 :
          return /* String */3;
      case /* Boolean */7 :
          return /* Boolean */6;
      case /* Exists */8 :
          throw {
                RE_EXN_ID: ModulegenTypeError,
                _1: not_supported("Exists type", ctx),
                Error: new Error()
              };
      
    }
  } else {
    switch (o.TAG | 0) {
      case /* Nullable */0 :
          var match = o._0;
          return {
                  TAG: /* Optional */9,
                  _0: type_to_bstype({
                        loc: match[0],
                        is_params: ctx.is_params
                      }, match[1])
                };
      case /* Function */1 :
          return function_type_to_bstype(ctx, o._0);
      case /* Object */2 :
          var o$1 = o._0;
          if (list.length(o$1.properties) === 0) {
            return {
                    TAG: /* Object */1,
                    _0: /* [] */0
                  };
          }
          var first_prop = list.hd(o$1.properties);
          if (first_prop.TAG === /* Indexer */2) {
            return {
                    TAG: /* Dict */5,
                    _0: type_to_bstype(ctx, first_prop._0[1].value[1])
                  };
          } else {
            return {
                    TAG: /* Object */1,
                    _0: object_type_to_bstype(o$1)
                  };
          }
      case /* Array */3 :
          var match$1 = o._0;
          return {
                  TAG: /* Array */4,
                  _0: type_to_bstype({
                        loc: match$1[0],
                        is_params: ctx.is_params
                      }, match$1[1])
                };
      case /* Generic */4 :
          return generic_type_to_bstype(ctx, o._0);
      case /* Union */5 :
          var match$2 = o._1;
          var match$3 = o._0;
          return {
                  TAG: /* Union */3,
                  _0: {
                    hd: type_to_bstype({
                          loc: match$3[0],
                          is_params: ctx.is_params
                        }, match$3[1]),
                    tl: {
                      hd: type_to_bstype({
                            loc: match$2[0],
                            is_params: ctx.is_params
                          }, match$2[1]),
                      tl: list.map((function (param) {
                              return type_to_bstype(ctx, param[1]);
                            }), o._2)
                    }
                  }
                };
      case /* Intersection */6 :
          throw {
                RE_EXN_ID: ModulegenTypeError,
                _1: not_supported("Intersection types", ctx),
                Error: new Error()
              };
      case /* Typeof */7 :
          var match$4 = o._0;
          return {
                  TAG: /* Typeof */7,
                  _0: type_to_bstype({
                        loc: match$4[0],
                        is_params: ctx.is_params
                      }, match$4[1])
                };
      case /* Tuple */8 :
          return {
                  TAG: /* Tuple */6,
                  _0: list.map((function (param) {
                          return type_to_bstype({
                                      loc: param[0],
                                      is_params: ctx.is_params
                                    }, param[1]);
                        }), o._0)
                };
      case /* StringLiteral */9 :
          return {
                  TAG: /* StringLiteral */10,
                  _0: o._0.value
                };
      case /* NumberLiteral */10 :
          return /* Number */1;
      case /* BooleanLiteral */11 :
          return /* Boolean */6;
      
    }
  }
}

function object_type_to_bstype(param) {
  return list.map((function (param) {
                switch (param.TAG | 0) {
                  case /* Property */0 :
                      var match = param._0[1];
                      return [
                              string_of_key(match.key),
                              value_to_bstype(match.value),
                              match.optional
                            ];
                  case /* SpreadProperty */1 :
                      throw {
                            RE_EXN_ID: ModulegenTypeError,
                            _1: not_supported("SpreadProperty on Object types", {
                                  loc: param._0[0],
                                  is_params: false
                                }),
                            Error: new Error()
                          };
                  case /* Indexer */2 :
                      throw {
                            RE_EXN_ID: ModulegenTypeError,
                            _1: not_supported("Indexer on Object types", {
                                  loc: param._0[0],
                                  is_params: false
                                }),
                            Error: new Error()
                          };
                  case /* CallProperty */3 :
                      var props = param._0[1];
                      var match$1 = props.value;
                      var loc = match$1[0];
                      if (props.static) {
                        throw {
                              RE_EXN_ID: ModulegenTypeError,
                              _1: not_supported("static CallProperty on Object types", {
                                    loc: loc,
                                    is_params: false
                                  }),
                              Error: new Error()
                            };
                      }
                      return [
                              "$$callProperty",
                              type_to_bstype({
                                    loc: loc,
                                    is_params: false
                                  }, {
                                    TAG: /* Function */1,
                                    _0: match$1[1]
                                  }),
                              false
                            ];
                  
                }
              }), param.properties);
}

function generic_type_to_bstype(ctx, g) {
  var id = g.id;
  if (id.TAG === /* Unqualified */0) {
    return named_to_bstype(ctx, g.typeParameters, id._0);
  } else {
    return {
            TAG: /* Named */8,
            _0: /* [] */0,
            _1: string_of_id(id._0[1].id),
            _2: undefined
          };
  }
}

function function_type_to_bstype(ctx, f) {
  var match = f.returnType;
  var match$1 = f.params;
  var rest = match$1[1];
  var type_params = extract_type_params(ctx, f.typeParameters);
  var arg_types = function (param) {
    var match = param[1];
    var match$1 = match.typeAnnotation;
    var t = match$1[1];
    var loc = match$1[0];
    var name = match.name;
    return [
            name !== undefined ? string_of_id(name) : "",
            match.optional ? ({
                  TAG: /* Optional */9,
                  _0: type_to_bstype({
                        loc: loc,
                        is_params: ctx.is_params
                      }, t)
                }) : type_to_bstype({
                    loc: loc,
                    is_params: ctx.is_params
                  }, t)
          ];
  };
  var formal_params = list.map(arg_types, match$1[0]);
  var rest_params;
  if (rest !== undefined) {
    var base_type = arg_types(rest[1].argument);
    var t = base_type[1];
    var tmp;
    tmp = typeof t === "number" || t.TAG !== /* Optional */9 ? base_type : [
        base_type[0],
        t._0
      ];
    rest_params = tmp;
  } else {
    rest_params = undefined;
  }
  var no_args = list.length(formal_params) === 0 && rest_params === undefined;
  var return_type = type_to_bstype({
        loc: match[0],
        is_params: ctx.is_params
      }, match[1]);
  return {
          TAG: /* Function */0,
          _0: {
            typeParams: type_params,
            formalParams: no_args ? ({
                  hd: [
                    "",
                    /* Unit */7
                  ],
                  tl: /* [] */0
                }) : formal_params,
            restParam: rest_params,
            returnType: return_type
          }
        };
}

function named_to_bstype(ctx, type_params, param) {
  var id = param[1];
  var loc = param[0];
  switch (id) {
    case "Array" :
        var params;
        if (type_params !== undefined) {
          var params$1 = type_params[1].params;
          if (params$1) {
            params = params$1;
          } else {
            throw {
                  RE_EXN_ID: ModulegenTypeError,
                  _1: not_supported("Array with no types", {
                        loc: loc,
                        is_params: ctx.is_params
                      }),
                  Error: new Error()
                };
          }
        } else {
          throw {
                RE_EXN_ID: ModulegenTypeError,
                _1: not_supported("Array with more than one type", {
                      loc: loc,
                      is_params: ctx.is_params
                    }),
                Error: new Error()
              };
        }
        var match = list.hd(params);
        return {
                TAG: /* Array */4,
                _0: type_to_bstype({
                      loc: match[0],
                      is_params: ctx.is_params
                    }, match[1])
              };
    case "Class" :
        var match$1;
        if (type_params !== undefined) {
          var params$2 = type_params[1].params;
          var exit = 0;
          if (params$2 && !params$2.tl) {
            match$1 = params$2.hd;
          } else {
            exit = 1;
          }
          if (exit === 1) {
            throw {
                  RE_EXN_ID: ModulegenTypeError,
                  _1: "Class must have exactly one type parameter. Got: " + String(list.length(params$2)),
                  Error: new Error()
                };
          }
          
        } else {
          throw {
                RE_EXN_ID: ModulegenTypeError,
                _1: "Class must have exactly one type parameter. Found none.",
                Error: new Error()
              };
        }
        return {
                TAG: /* Typeof */7,
                _0: type_to_bstype({
                      loc: match$1[0],
                      is_params: ctx.is_params
                    }, match$1[1])
              };
    case "Date" :
        return /* Date */9;
    case "Function" :
        return /* AnyFunction */4;
    case "Object" :
        return /* AnyObject */5;
    case "Promise" :
        var match$2;
        if (type_params !== undefined) {
          var params$3 = type_params[1].params;
          var exit$1 = 0;
          if (params$3 && !params$3.tl) {
            match$2 = params$3.hd;
          } else {
            exit$1 = 1;
          }
          if (exit$1 === 1) {
            throw {
                  RE_EXN_ID: ModulegenTypeError,
                  _1: "Promise must have exactly one type parameter. Got: " + String(list.length(params$3)),
                  Error: new Error()
                };
          }
          
        } else {
          throw {
                RE_EXN_ID: ModulegenTypeError,
                _1: "Promise must have exactly one type parameter. Found none.",
                Error: new Error()
              };
        }
        return {
                TAG: /* Promise */11,
                _0: type_to_bstype({
                      loc: match$2[0],
                      is_params: ctx.is_params
                    }, match$2[1])
              };
    case "RegExp" :
        return /* Regex */2;
    default:
      if (id.length !== 0 && caml_string.get(id, 0) === /* "$" */36 && string.sub(id, 0, 4) !== "$npm") {
        throw {
              RE_EXN_ID: ModulegenTypeError,
              _1: not_supported("Built-in type " + id, ctx),
              Error: new Error()
            };
      }
      var type_params$1 = type_params !== undefined ? list.map((function (param) {
                return type_to_bstype({
                            loc: param[0],
                            is_params: ctx.is_params
                          }, param[1]);
              }), type_params[1].params) : /* [] */0;
      return {
              TAG: /* Named */8,
              _0: type_params$1,
              _1: id,
              _2: undefined
            };
  }
}

function value_to_bstype(value) {
  switch (value.TAG | 0) {
    case /* Init */0 :
        var match = value._0;
        return type_to_bstype({
                    loc: match[0],
                    is_params: false
                  }, match[1]);
    
  }
  var match$1 = value._0;
  return function_type_to_bstype({
              loc: match$1[0],
              is_params: false
            }, match$1[1]);
}

function type_annotation_to_bstype(annotation) {
  if (annotation !== undefined) {
    return type_to_bstype({
                loc: annotation[0],
                is_params: false
              }, annotation[1][1]);
  }
  throw {
        RE_EXN_ID: ModulegenTypeError,
        _1: "Unknown type when parsing annotation",
        Error: new Error()
      };
}

function declare_class_to_jsdecl(loc, s) {
  var $$extends = s.extends;
  var inheritedClasses;
  if ($$extends) {
    if ($$extends.tl) {
      throw {
            RE_EXN_ID: ModulegenStatementError,
            _1: not_supported("Inheriting from multiple types", {
                  loc: loc,
                  is_params: false
                }),
            Error: new Error()
          };
    }
    var match = $$extends.hd;
    inheritedClasses = type_to_bstype({
          loc: match[0],
          is_params: false
        }, {
          TAG: /* Generic */4,
          _0: match[1]
        });
  } else {
    inheritedClasses = undefined;
  }
  var properties = object_type_to_bstype(s.body[1]);
  var properties$1 = list.map((function (param) {
          return [
                  param[0],
                  param[1]
                ];
        }), properties);
  return {
          TAG: /* ClassDecl */5,
          _0: string_of_id(s.id),
          _1: extract_type_params(intctx, s.typeParameters),
          _2: {
            TAG: /* Class */2,
            _0: inheritedClasses,
            _1: properties$1
          }
        };
}

function declaration_to_jsdecl(loc, param) {
  switch (param.TAG | 0) {
    case /* Variable */0 :
        var match = param._0[1];
        return {
                TAG: /* VarDecl */0,
                _0: string_of_id(match.id),
                _1: type_annotation_to_bstype(match.typeAnnotation)
              };
    case /* Function */1 :
        var match$1 = param._0[1];
        var bstype = type_annotation_to_bstype(match$1.typeAnnotation);
        return {
                TAG: /* FuncDecl */1,
                _0: string_of_id(match$1.id),
                _1: bstype
              };
    case /* Class */2 :
        var match$2 = param._0;
        return declare_class_to_jsdecl(match$2[0], match$2[1]);
    default:
      throw {
            RE_EXN_ID: ModulegenDeclError,
            _1: "Unknown declaration when converting a module property declaration" + loc_to_msg(loc),
            Error: new Error()
          };
  }
}

function declare_interface_to_jsdecl(_loc, s) {
  var $$extends = s.extends;
  var body = s.body;
  if ($$extends) {
    throw {
          RE_EXN_ID: ModulegenStatementError,
          _1: not_supported("Inheriting in interfaces", {
                loc: $$extends.hd[0],
                is_params: false
              }),
          Error: new Error()
        };
  }
  var body_type = {
    TAG: /* Object */2,
    _0: body[1]
  };
  return {
          TAG: /* InterfaceDecl */6,
          _0: string_of_id(s.id),
          _1: extract_type_params(intctx, s.typeParameters),
          _2: type_to_bstype({
                loc: body[0],
                is_params: false
              }, body_type)
        };
}

function import_decl_to_jsdecl(loc, s) {
  var s$1 = s.source[1].value;
  var imported_module;
  imported_module = typeof s$1 === "number" || s$1.TAG !== /* String */0 ? "" : s$1._0;
  switch (s.importKind) {
    case /* ImportType */0 :
        var import_names = list.map((function (param) {
                switch (param.TAG | 0) {
                  case /* ImportNamedSpecifier */0 :
                      var match = param._0;
                      var remote = match.remote;
                      var local = match.local;
                      return [
                              string_of_id(remote),
                              local !== undefined ? string_of_id(local) : string_of_id(remote)
                            ];
                  case /* ImportDefaultSpecifier */1 :
                  case /* ImportNamespaceSpecifier */2 :
                      return [
                              "",
                              ""
                            ];
                  
                }
              }), s.specifiers);
        return {
                TAG: /* ImportDecl */7,
                _0: import_names,
                _1: imported_module
              };
    case /* ImportTypeof */1 :
        throw {
              RE_EXN_ID: ModulegenStatementError,
              _1: not_supported("'import typeof'", {
                    loc: loc,
                    is_params: false
                  }),
              Error: new Error()
            };
    case /* ImportValue */2 :
        throw {
              RE_EXN_ID: ModulegenStatementError,
              _1: not_supported("Importing values", {
                    loc: loc,
                    is_params: false
                  }),
              Error: new Error()
            };
    
  }
}

function flowAstToBsTypeAst(param) {
  var s = param[1];
  var loc = param[0];
  if (typeof s === "number") {
    if (s === /* Empty */0) {
      return /* Noop */0;
    }
    
  } else {
    switch (s.TAG | 0) {
      case /* Expression */1 :
          return {
                  TAG: /* Ignore */9,
                  _0: "expression statement"
                };
      case /* TypeAlias */7 :
          var match = s._0;
          var match$1 = match.right;
          return {
                  TAG: /* TypeDecl */4,
                  _0: string_of_id(match.id),
                  _1: extract_type_params(intctx, match.typeParameters),
                  _2: type_to_bstype({
                        loc: match$1[0],
                        is_params: false
                      }, match$1[1])
                };
      case /* VariableDeclaration */18 :
          return {
                  TAG: /* Ignore */9,
                  _0: "variable declaration"
                };
      case /* ClassDeclaration */19 :
          var match$2 = s._0;
          var match$3 = match$2.id;
          var exit = 0;
          if (match$3 !== undefined) {
            var match$4 = match$2.superClass;
            if (match$4 !== undefined) {
              var match$5 = match$4[1];
              if (typeof match$5 === "number" || match$5.TAG !== /* Member */13) {
                exit = 2;
              } else {
                var match$6 = match$5._0;
                var oID = match$6._object[1];
                if (typeof oID === "number" || oID.TAG !== /* Identifier */17) {
                  exit = 2;
                } else {
                  var pID = match$6.property;
                  if (pID.TAG === /* PropertyIdentifier */0) {
                    var match$7 = match$2.superTypeParameters;
                    if (match$7 !== undefined) {
                      var match$8 = match$7[1].params;
                      if (match$8) {
                        var pID$1 = pID._0;
                        if (string_of_id(oID._0) === "React" && (string_of_id(pID$1) === "Component" || string_of_id(pID$1) === "PureComponent")) {
                          var propsType = type_to_bstype({
                                loc: loc,
                                is_params: false
                              }, match$8.hd[1]);
                          return {
                                  TAG: /* ReactClass */8,
                                  _0: match$3[1],
                                  _1: propsType
                                };
                        }
                        exit = 2;
                      } else {
                        exit = 2;
                      }
                    } else {
                      exit = 2;
                    }
                  } else {
                    exit = 2;
                  }
                }
              }
            } else {
              exit = 2;
            }
          } else {
            exit = 2;
          }
          if (exit === 2) {
            throw {
                  RE_EXN_ID: ModulegenStatementError,
                  _1: not_supported("Class declatations", {
                        loc: loc,
                        is_params: false
                      }),
                  Error: new Error()
                };
          }
          break;
      case /* InterfaceDeclaration */20 :
          return declare_interface_to_jsdecl(loc, s._0);
      case /* DeclareVariable */21 :
          var match$9 = s._0;
          var typeAnnotation = match$9.typeAnnotation;
          var id = match$9.id;
          if (string_of_id(id) === "exports") {
            return {
                    TAG: /* ExportsDecl */3,
                    _0: type_annotation_to_bstype(typeAnnotation)
                  };
          } else {
            return {
                    TAG: /* VarDecl */0,
                    _0: string_of_id(id),
                    _1: type_annotation_to_bstype(typeAnnotation)
                  };
          }
      case /* DeclareFunction */22 :
          return declaration_to_jsdecl(loc, {
                      TAG: /* Function */1,
                      _0: [
                        loc,
                        s._0
                      ]
                    });
      case /* DeclareClass */23 :
          return declare_class_to_jsdecl(loc, s._0);
      case /* DeclareModule */24 :
          return declare_module_to_jsdecl(loc, s._0);
      case /* DeclareModuleExports */25 :
          return {
                  TAG: /* ExportsDecl */3,
                  _0: type_annotation_to_bstype(s._0)
                };
      case /* DeclareExportDeclaration */26 :
          var declaration = s._0.declaration;
          if (declaration !== undefined) {
            return declaration_to_jsdecl(loc, declaration);
          }
          break;
      case /* ExportNamedDeclaration */27 :
          throw {
                RE_EXN_ID: ModulegenStatementError,
                _1: not_supported("ExportNamedDeclaration", {
                      loc: loc,
                      is_params: false
                    }),
                Error: new Error()
              };
      case /* ExportDefaultDeclaration */28 :
          throw {
                RE_EXN_ID: ModulegenStatementError,
                _1: not_supported("ExportDefaultDeclaration", {
                      loc: loc,
                      is_params: false
                    }),
                Error: new Error()
              };
      case /* ImportDeclaration */29 :
          return import_decl_to_jsdecl(loc, s._0);
        
    }
  }
  throw {
        RE_EXN_ID: ModulegenStatementError,
        _1: "Unknown statement type when parsing libdef" + loc_to_msg(loc),
        Error: new Error()
      };
}

function block_to_program(param) {
  return list.map(flowAstToBsTypeAst, param[1].body);
}

function declare_module_to_jsdecl(loc, s) {
  var id = s.id;
  if (id.TAG !== /* Identifier */0) {
    return {
            TAG: /* ModuleDecl */2,
            _0: id._0[1].raw,
            _1: block_to_program(s.body)
          };
  }
  throw {
        RE_EXN_ID: ModulegenDeclError,
        _1: "Unknown declaration type when converting a module declaration" + loc_to_msg(loc),
        Error: new Error()
      };
}

var Ast$9;

var Ast_1$9 = Ast$9;
var intctx_1 = intctx;
var ModulegenDeclError_1 = ModulegenDeclError;
var ModulegenTypeError_1 = ModulegenTypeError;
var ModulegenStatementError_1 = ModulegenStatementError;
var loc_to_msg_1 = loc_to_msg;
var not_supported_1 = not_supported;
var sanity_check_1 = sanity_check;
var string_of_id_1 = string_of_id;
var string_of_key_1 = string_of_key;
var extract_type_params_1 = extract_type_params;
var type_annotation_to_bstype_1 = type_annotation_to_bstype;
var type_to_bstype_1 = type_to_bstype;
var function_type_to_bstype_1 = function_type_to_bstype;
var value_to_bstype_1 = value_to_bstype;
var object_type_to_bstype_1 = object_type_to_bstype;
var generic_type_to_bstype_1 = generic_type_to_bstype;
var named_to_bstype_1 = named_to_bstype;
var declaration_to_jsdecl_1 = declaration_to_jsdecl;
var declare_interface_to_jsdecl_1 = declare_interface_to_jsdecl;
var declare_class_to_jsdecl_1 = declare_class_to_jsdecl;
var import_decl_to_jsdecl_1 = import_decl_to_jsdecl;
var flowAstToBsTypeAst_1 = flowAstToBsTypeAst;
var block_to_program_1 = block_to_program;
var declare_module_to_jsdecl_1 = declare_module_to_jsdecl;
/* Loc Not a pure module */

var flowBsType_bs = {
	Ast: Ast_1$9,
	intctx: intctx_1,
	ModulegenDeclError: ModulegenDeclError_1,
	ModulegenTypeError: ModulegenTypeError_1,
	ModulegenStatementError: ModulegenStatementError_1,
	loc_to_msg: loc_to_msg_1,
	not_supported: not_supported_1,
	sanity_check: sanity_check_1,
	string_of_id: string_of_id_1,
	string_of_key: string_of_key_1,
	extract_type_params: extract_type_params_1,
	type_annotation_to_bstype: type_annotation_to_bstype_1,
	type_to_bstype: type_to_bstype_1,
	function_type_to_bstype: function_type_to_bstype_1,
	value_to_bstype: value_to_bstype_1,
	object_type_to_bstype: object_type_to_bstype_1,
	generic_type_to_bstype: generic_type_to_bstype_1,
	named_to_bstype: named_to_bstype_1,
	declaration_to_jsdecl: declaration_to_jsdecl_1,
	declare_interface_to_jsdecl: declare_interface_to_jsdecl_1,
	declare_class_to_jsdecl: declare_class_to_jsdecl_1,
	import_decl_to_jsdecl: import_decl_to_jsdecl_1,
	flowAstToBsTypeAst: flowAstToBsTypeAst_1,
	block_to_program: block_to_program_1,
	declare_module_to_jsdecl: declare_module_to_jsdecl_1
};

var ScriptTarget = {};

var SyntaxKind = {};

var Internal$2 = {
  ScriptTarget: ScriptTarget,
  SyntaxKind: SyntaxKind
};

function parseDiagnostic(json) {
  return {
          start: Json_decode_bs.field("start", Json_decode_bs.$$int, json),
          messageText: Json_decode_bs.field("messageText", Json_decode_bs.string, json),
          category: Json_decode_bs.field("category", Json_decode_bs.$$int, json),
          length: Json_decode_bs.field("length", Json_decode_bs.$$int, json),
          code: Json_decode_bs.field("code", Json_decode_bs.$$int, json)
        };
}

var decoders$2 = {};

function node$2(json) {
  var syntaxKind = Json_decode_bs.field("kind", Json_decode_bs.$$int, json);
  var decoder;
  try {
    decoder = list.assoc(syntaxKind, decoders$2);
  }
  catch (exn){
    decoder = unknown$2;
  }
  return curry._1(decoder, json);
}

function declareKeyword(json) {
  return {
          TAG: /* DeclareKeyword */0,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json)
          }
        };
}

function exportKeyword(json) {
  return {
          TAG: /* ExportKeyword */1,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json)
          }
        };
}

function numberKeyword(json) {
  return {
          TAG: /* NumberKeyword */3,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json)
          }
        };
}

function stringKeyword(json) {
  return {
          TAG: /* StringKeyword */2,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json)
          }
        };
}

function identifier$1(json) {
  return {
          TAG: /* Identifier */4,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
            escapedText: Json_decode_bs.field("escapedText", Json_decode_bs.string, json),
            text: Json_decode_bs.field("text", Json_decode_bs.string, json)
          }
        };
}

function functionDeclaration(json) {
  return {
          TAG: /* FunctionDeclaration */5,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
            modifiers: Json_decode_bs.withDefault([], (function (param) {
                    return Json_decode_bs.field("modifiers", (function (param) {
                                  return Json_decode_bs.array(node$2, param);
                                }), param);
                  }), json),
            name: Json_decode_bs.field("name", node$2, json),
            typeParameters: Json_decode_bs.withDefault([], (function (param) {
                    return Json_decode_bs.field("typeParameters", (function (param) {
                                  return Json_decode_bs.array(node$2, param);
                                }), param);
                  }), json),
            parameters: Json_decode_bs.field("parameters", (function (param) {
                    return Json_decode_bs.array(node$2, param);
                  }), json),
            type_: Json_decode_bs.field("type", node$2, json)
          }
        };
}

function interfaceDeclaration(json) {
  return {
          TAG: /* InterfaceDeclaration */6,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
            modifiers: Json_decode_bs.withDefault([], (function (param) {
                    return Json_decode_bs.field("modifiers", (function (param) {
                                  return Json_decode_bs.array(node$2, param);
                                }), param);
                  }), json),
            name: Json_decode_bs.field("name", node$2, json),
            typeParameters: Json_decode_bs.withDefault([], (function (param) {
                    return Json_decode_bs.field("typeParameters", (function (param) {
                                  return Json_decode_bs.array(node$2, param);
                                }), param);
                  }), json),
            members: Json_decode_bs.field("members", (function (param) {
                    return Json_decode_bs.array(node$2, param);
                  }), json)
          }
        };
}

function propertySignature(json) {
  return {
          TAG: /* PropertySignature */7,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
            modifiers: Json_decode_bs.withDefault([], (function (param) {
                    return Json_decode_bs.field("modifiers", (function (param) {
                                  return Json_decode_bs.array(node$2, param);
                                }), param);
                  }), json),
            name: Json_decode_bs.field("name", node$2, json),
            questionToken: Json_decode_bs.optional((function (param) {
                    return Json_decode_bs.field("questionToken", node$2, param);
                  }), json),
            type_: Json_decode_bs.field("type", node$2, json)
          }
        };
}

function questionToken(json) {
  return {
          TAG: /* QuestionToken */8,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json)
          }
        };
}

function typeAliasDeclaration(json) {
  return {
          TAG: /* TypeAliasDeclaration */9,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
            name: Json_decode_bs.field("name", node$2, json),
            typeParameters: Json_decode_bs.withDefault([], (function (param) {
                    return Json_decode_bs.field("typeParameters", (function (param) {
                                  return Json_decode_bs.array(node$2, param);
                                }), param);
                  }), json),
            type_: Json_decode_bs.field("type", node$2, json)
          }
        };
}

function typeLiteral(json) {
  return {
          TAG: /* TypeLiteral */10,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
            members: Json_decode_bs.field("members", (function (param) {
                    return Json_decode_bs.array(node$2, param);
                  }), json)
          }
        };
}

function sourceFile(json) {
  return {
          TAG: /* SourceFile */11,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
            text: Json_decode_bs.field("text", Json_decode_bs.string, json),
            languageVersion: Json_decode_bs.field("languageVersion", Json_decode_bs.$$int, json),
            fileName: Json_decode_bs.field("fileName", Json_decode_bs.string, json),
            languageVariant: Json_decode_bs.field("languageVariant", Json_decode_bs.$$int, json),
            isDeclarationFile: Json_decode_bs.field("isDeclarationFile", Json_decode_bs.bool, json),
            statements: Json_decode_bs.field("statements", (function (param) {
                    return Json_decode_bs.array(node$2, param);
                  }), json),
            nodeCount: Json_decode_bs.field("nodeCount", Json_decode_bs.$$int, json),
            identifierCount: Json_decode_bs.field("identifierCount", Json_decode_bs.$$int, json),
            parseDiagnostics: Json_decode_bs.field("parseDiagnostics", (function (param) {
                    return Json_decode_bs.array(parseDiagnostic, param);
                  }), json)
          }
        };
}

function parameter(json) {
  return {
          TAG: /* Parameter */12,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
            dotDotDotToken: Json_decode_bs.optional((function (param) {
                    return Json_decode_bs.field("dotDotDotToken", node$2, param);
                  }), json),
            name: Json_decode_bs.field("name", node$2, json),
            questionToken: Json_decode_bs.optional((function (param) {
                    return Json_decode_bs.field("questionToken", node$2, param);
                  }), json),
            type_: Json_decode_bs.field("type", node$2, json)
          }
        };
}

function typeParameter(json) {
  return {
          TAG: /* TypeParameter */13,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
            name: Json_decode_bs.field("name", node$2, json)
          }
        };
}

function typeReference(json) {
  return {
          TAG: /* TypeReference */14,
          _0: {
            pos: Json_decode_bs.field("pos", Json_decode_bs.$$int, json),
            end_: Json_decode_bs.field("end", Json_decode_bs.$$int, json),
            typeName: Json_decode_bs.field("typeName", node$2, json)
          }
        };
}

function unknown$2(json) {
  var kind = Json_decode_bs.field("kind", Json_decode_bs.$$int, json);
  return {
          TAG: /* Unknown */15,
          _0: kind
        };
}

caml_obj.update_dummy(decoders$2, {
      hd: [
        Typescript.SyntaxKind.DeclareKeyword,
        declareKeyword
      ],
      tl: {
        hd: [
          Typescript.SyntaxKind.ExportKeyword,
          exportKeyword
        ],
        tl: {
          hd: [
            Typescript.SyntaxKind.NumberKeyword,
            numberKeyword
          ],
          tl: {
            hd: [
              Typescript.SyntaxKind.StringKeyword,
              stringKeyword
            ],
            tl: {
              hd: [
                Typescript.SyntaxKind.Identifier,
                identifier$1
              ],
              tl: {
                hd: [
                  Typescript.SyntaxKind.FunctionDeclaration,
                  functionDeclaration
                ],
                tl: {
                  hd: [
                    Typescript.SyntaxKind.InterfaceDeclaration,
                    interfaceDeclaration
                  ],
                  tl: {
                    hd: [
                      Typescript.SyntaxKind.TypeAliasDeclaration,
                      typeAliasDeclaration
                    ],
                    tl: {
                      hd: [
                        Typescript.SyntaxKind.TypeLiteral,
                        typeLiteral
                      ],
                      tl: {
                        hd: [
                          Typescript.SyntaxKind.PropertySignature,
                          propertySignature
                        ],
                        tl: {
                          hd: [
                            Typescript.SyntaxKind.QuestionToken,
                            questionToken
                          ],
                          tl: {
                            hd: [
                              Typescript.SyntaxKind.SourceFile,
                              sourceFile
                            ],
                            tl: {
                              hd: [
                                Typescript.SyntaxKind.Parameter,
                                parameter
                              ],
                              tl: {
                                hd: [
                                  Typescript.SyntaxKind.TypeParameter,
                                  typeParameter
                                ],
                                tl: {
                                  hd: [
                                    Typescript.SyntaxKind.TypeReference,
                                    typeReference
                                  ],
                                  tl: /* [] */0
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

var decode$2 = node$2;

var Decoder$2 = {
  parseDiagnostic: parseDiagnostic,
  decoders: decoders$2,
  node: node$2,
  declareKeyword: declareKeyword,
  exportKeyword: exportKeyword,
  numberKeyword: numberKeyword,
  stringKeyword: stringKeyword,
  identifier: identifier$1,
  functionDeclaration: functionDeclaration,
  interfaceDeclaration: interfaceDeclaration,
  propertySignature: propertySignature,
  questionToken: questionToken,
  typeAliasDeclaration: typeAliasDeclaration,
  typeLiteral: typeLiteral,
  sourceFile: sourceFile,
  parameter: parameter,
  typeParameter: typeParameter,
  typeReference: typeReference,
  unknown: unknown$2,
  decode: decode$2
};

function parse$2(fileName, source) {
  return node$2(Typescript.createSourceFile(fileName, source, Typescript.ScriptTarget.ES2015, false));
}

var Internal_1$2 = Internal$2;
var Decoder_1$2 = Decoder$2;
var parse_1$2 = parse$2;
/* decoders Not a pure module */

var typescript_bs = {
	Internal: Internal_1$2,
	Decoder: Decoder_1$2,
	parse: parse_1$2
};

function wrapParens(l) {
  if (l === /* [] */0) {
    return "";
  } else {
    return "(" + (string.concat(", ", l) + ")");
  }
}

function applyArgs(name, l) {
  return name + wrapParens(l);
}

function lambda(l, body) {
  var arg = function (a) {
    if (a.TAG === /* Labelled */0) {
      return "~" + (a._0 + (
                a._1 ? "=?" : ""
              ));
    } else {
      return a._0;
    }
  };
  return wrapParens(list.map(arg, l)) + (" => " + body);
}

function quote$3(x) {
  return "\"" + (x + "\"");
}

function bsModule(name) {
  var quotedName = name === "" ? name : " " + quote$3(name);
  return "[@bs.module" + (quotedName + "]");
}

function jsObject(l) {
  return "{" + (string.concat(", ", list.map((function (param) {
                      return quote$3(param[0]) + (": " + param[1]);
                    }), l)) + "}");
}

function variableDeclaration(name, module_id, type_of, is_exportsOpt, spliceOpt, codeOpt, param) {
  var is_exports = is_exportsOpt !== undefined ? is_exportsOpt : false;
  var splice = spliceOpt !== undefined ? spliceOpt : false;
  var code = codeOpt !== undefined ? codeOpt : "";
  if (is_exports) {
    return bsModule("") + (" external " + (name + (" : " + (type_of + (" = \"" + (module_id + "\" ;\n"))))));
  } else {
    return bsModule(module_id) + ((
              splice ? " [@bs.splice]" : ""
            ) + (" external " + (name + (" : " + (type_of + (" = \"" + (code + "\";\n")))))));
  }
}

function moduleDeclaration(name, statements, param) {
  return "module " + (name + (" = {\n" + (string.concat("\n  ", statements) + "\n};")));
}

function classDeclaration(name, exported_as, module_id, class_type, ctor_type, type_params, param) {
  return "module " + (name + (" = {\n  type " + ("t" + wrapParens(type_params) + (" = " + (class_type + (";\n  [@bs.new] " + (bsModule(module_id) + (" external make : " + (ctor_type + (" = \"" + (exported_as + "\";\n};")))))))))));
}

function typeDeclaration(name, type_of, type_params, param) {
  return "type " + (name + wrapParens(type_params) + (" = " + (type_of + ";")));
}

function objectType(statements, param) {
  return "{. " + (string.concat(", ", list.map((function (param) {
                      var type_of = param[1];
                      return "\"" + (param[0] + ("\": " + (
                                  param[2] ? "Js.Nullable.t(" + (type_of + ")") : type_of
                                )));
                    }), list.filter(function (param) {
                          return param[0] !== "__callProperty";
                        })(statements))) + " }");
}

function functionType(formal_params, rest_param, has_optional, return_type, param) {
  var print = function (param) {
    var param_type = param[1];
    var name = param[0];
    if (name !== "") {
      return "(~" + (name + (":" + (param_type + ")")));
    } else {
      return param_type;
    }
  };
  var it = string.concat(" => ", list.map(print, formal_params));
  var formalCode = it === "" ? "" : it + " => ";
  var optUnit = has_optional ? "unit => " : "";
  var restCode = rest_param !== undefined ? print(rest_param) + " => " : "";
  return formalCode + (optUnit + (restCode + return_type));
}

function tupleType(types, param) {
  return "(" + (string.concat(", ", types) + ")");
}

function unionTypeStrings(types, param) {
  return curry._1(printf_1.sprintf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "([",
                    _1: {
                      TAG: /* Formatting_lit */17,
                      _0: {
                        TAG: /* Scan_indic */2,
                        _0: /* "b" */98
                      },
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "s.string] [",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "])",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "([@bs.string] [%s])"
                }), string.concat(" | ", list.map(printf_1.sprintf(/* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* "`" */96,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "`%s"
                        }), types)));
}

function unionType(name, types, param) {
  return "type union_of_" + (name + (" = " + (string.concat("", list.map((function (param) {
                          return "\n| " + (param[0] + (" (" + (param[1] + ")")));
                        }), types)) + (";\n\ntype " + (name + (";\n\nexternal " + (name + (" : union_of_" + (name + (" => " + (name + " = \"Array.prototype.shift.call\" [@@bs.val];\n")))))))))));
}

function inlineUnion(types, param) {
  return "([@bs.unwrap] [" + (string.concat(" | ", list.map((function (param) {
                      return "`" + (param[0] + ("(" + (param[1] + ")")));
                    }), types)) + "])");
}

function classType(types, param) {
  return "{. " + (string.concat(", ", list.map((function (param) {
                      var type_params = param[1];
                      return "\"" + (param[0] + ("\": " + ((
                                    type_params ? string.concat(" ", type_params) + " . " : ""
                                  ) + ((
                                      param[3] ? "[@bs.meth]" : ""
                                    ) + ("(" + (param[2] + ")"))))));
                    }), list.filter(function (param) {
                          return param[0] !== "constructor";
                        })(types))) + "}");
}

function alias(name, value) {
  return "let " + (name + (" = " + (value + ";\n")));
}

function react_component$1(define_module, module_name, component_name, js_name, props, props_type_string) {
  var wrapArg = function (optional, is_bool, x) {
    if (!optional) {
      if (is_bool) {
        return "Js.Boolean.to_js_boolean" + wrapParens({
                    hd: x,
                    tl: /* [] */0
                  });
      } else {
        return x;
      }
    }
    if (!is_bool) {
      return "Js.Nullable.from_opt" + wrapParens({
                  hd: x,
                  tl: /* [] */0
                });
    }
    var v = "Js.Nullable.from_opt" + wrapParens({
          hd: x,
          tl: /* [] */0
        });
    var f = "Js.Boolean.to_js_boolean";
    var l_1 = {
      hd: "[@bs]" + lambda({
            hd: {
              TAG: /* Unlabelled */1,
              _0: "x"
            },
            tl: /* [] */0
          }, f + wrapParens({
                hd: "x",
                tl: /* [] */0
              })),
      tl: /* [] */0
    };
    var l = {
      hd: v,
      tl: l_1
    };
    return "Js.Nullable.bind" + wrapParens(l);
  };
  var l_0 = "~reactClass=" + string.uncapitalize_ascii(component_name);
  var l_1 = {
    hd: "~props",
    tl: {
      hd: "children",
      tl: /* [] */0
    }
  };
  var l = {
    hd: l_0,
    tl: l_1
  };
  return (
          define_module ? "\nmodule " + (component_name + " = {\n") : "\n"
        ) + ("  " + (bsModule(module_name) + ("\n  external " + (string.uncapitalize_ascii(component_name) + (" : ReasonReact.reactClass = \"" + (js_name + ("\";\n  let make = " + (lambda(pervasives.$at(list.map((function (param) {
                                        return {
                                                TAG: /* Labelled */0,
                                                _0: param[0],
                                                _1: param[3]
                                              };
                                      }), props), {
                                  hd: {
                                    TAG: /* Unlabelled */1,
                                    _0: "children"
                                  },
                                  tl: /* [] */0
                                }), "{\n    let props: " + (props_type_string + (" = " + (jsObject(list.map((function (param) {
                                              return [
                                                      param[1],
                                                      wrapArg(param[3], param[4], param[0])
                                                    ];
                                            }), props)) + (";\n    " + ("ReasonReact.wrapJsForReason" + wrapParens(l) + ";\n  };")))))) + (
                          define_module ? "\n};" : ""
                        )))))))));
}

var wrapParens_1 = wrapParens;
var applyArgs_1 = applyArgs;
var lambda_1 = lambda;
var quote_1$1 = quote$3;
var bsModule_1 = bsModule;
var jsObject_1 = jsObject;
var variableDeclaration_1 = variableDeclaration;
var moduleDeclaration_1 = moduleDeclaration;
var classDeclaration_1 = classDeclaration;
var typeDeclaration_1 = typeDeclaration;
var objectType_1 = objectType;
var functionType_1 = functionType;
var tupleType_1 = tupleType;
var unionTypeStrings_1 = unionTypeStrings;
var unionType_1 = unionType;
var inlineUnion_1 = inlineUnion;
var classType_1 = classType;
var alias_1 = alias;
var react_component_1 = react_component$1;
/* No side effect */

var render_bs = {
	wrapParens: wrapParens_1,
	applyArgs: applyArgs_1,
	lambda: lambda_1,
	quote: quote_1$1,
	bsModule: bsModule_1,
	jsObject: jsObject_1,
	variableDeclaration: variableDeclaration_1,
	moduleDeclaration: moduleDeclaration_1,
	classDeclaration: classDeclaration_1,
	typeDeclaration: typeDeclaration_1,
	objectType: objectType_1,
	functionType: functionType_1,
	tupleType: tupleType_1,
	unionTypeStrings: unionTypeStrings_1,
	unionType: unionType_1,
	inlineUnion: inlineUnion_1,
	classType: classType_1,
	alias: alias_1,
	react_component: react_component_1
};

var CodegenTypeError = caml_exceptions.create("BsTypeReason-ReasonablyTyped.CodegenTypeError");

var CodegenConstructorError = caml_exceptions.create("BsTypeReason-ReasonablyTyped.CodegenConstructorError");

function module_prefix(s) {
  if (s !== undefined) {
    return s + ".";
  } else {
    return "";
  }
}

function bstype_name(t) {
  if (typeof t === "number") {
    switch (t) {
      case /* Null */0 :
          return "null";
      case /* Number */1 :
          return "number";
      case /* Regex */2 :
          return "regex";
      case /* String */3 :
          return "string";
      case /* AnyFunction */4 :
          return "function";
      case /* AnyObject */5 :
          return "object";
      case /* Boolean */6 :
          return "bool";
      case /* Unit */7 :
          return "unit";
      case /* Any */8 :
          return "any";
      case /* Date */9 :
          return "date";
      
    }
  } else {
    switch (t.TAG | 0) {
      case /* Function */0 :
          return "func";
      case /* Object */1 :
          return "object";
      case /* Class */2 :
          throw {
                RE_EXN_ID: CodegenTypeError,
                _1: "Unable to translate class into type name",
                Error: new Error()
              };
      case /* Union */3 :
          return union_types_to_name(t._0);
      case /* Array */4 :
          return "array_" + bstype_name(t._0);
      case /* Dict */5 :
          return "dict_" + bstype_name(t._0);
      case /* Tuple */6 :
          return "tuple_of_" + string.concat("_", list.map(bstype_name, t._0));
      case /* Typeof */7 :
          return "typeof_" + bstype_name(t._0);
      case /* Named */8 :
          return module_prefix(t._2) + genutils_bs.normalize_name(string.uncapitalize_ascii(t._1));
      case /* Optional */9 :
          return "option " + bstype_name(t._0);
      case /* StringLiteral */10 :
          throw {
                RE_EXN_ID: CodegenTypeError,
                _1: "Cannot use string literal outside the context of a union type",
                Error: new Error()
              };
      case /* Promise */11 :
          return "promise_" + bstype_name(t._0);
      
    }
  }
}

function union_types_to_name(types) {
  var is_string_union = list.for_all((function (param) {
          if (typeof param === "number" || param.TAG !== /* StringLiteral */10) {
            return false;
          } else {
            return true;
          }
        }), types);
  if (is_string_union) {
    var type_names = list.map((function (s) {
            if (typeof s === "number") {
              throw {
                    RE_EXN_ID: CodegenTypeError,
                    _1: "Expected a StringLiteral when converting to union type",
                    Error: new Error()
                  };
            }
            if (s.TAG === /* StringLiteral */10) {
              return s._0;
            }
            throw {
                  RE_EXN_ID: CodegenTypeError,
                  _1: "Expected a StringLiteral when converting to union type",
                  Error: new Error()
                };
          }), types);
    return render_bs.unionTypeStrings(type_names, undefined);
  }
  var type_names$1 = list.map(bstype_name, types);
  return string.concat("_or_", type_names$1);
}

var intctx$1 = {
  type_params: /* [] */0,
  type_table: /* [] */0
};

function bstype_to_code(_$staropt$star, _t) {
  while(true) {
    var t = _t;
    var $staropt$star = _$staropt$star;
    var ctx = $staropt$star !== undefined ? $staropt$star : intctx$1;
    if (typeof t === "number") {
      switch (t) {
        case /* Null */0 :
            return "null";
        case /* Number */1 :
            return "float";
        case /* Regex */2 :
            return "Js.Re.t";
        case /* String */3 :
            return "string";
        case /* Boolean */6 :
            return "Js.boolean";
        case /* Unit */7 :
            return "unit";
        case /* AnyFunction */4 :
        case /* AnyObject */5 :
        case /* Any */8 :
            return "'any";
        case /* Date */9 :
            return "Js.Date.t";
        
      }
    } else {
      switch (t.TAG | 0) {
        case /* Function */0 :
            var match = t._0;
            var rest_param = match.restParam;
            var params = match.formalParams;
            var ctx_type_params = pervasives.$at(match.typeParams, ctx.type_params);
            var ctx_type_table = ctx.type_table;
            var ctx$1 = {
              type_params: ctx_type_params,
              type_table: ctx_type_table
            };
            var print = (function(ctx$1){
            return function print(param) {
              var param$1 = param[1];
              var tmp;
              var exit = 0;
              if (typeof param$1 === "number" || param$1.TAG !== /* Union */3) {
                exit = 1;
              } else {
                var types = param$1._0;
                tmp = genutils_bs.Is.string_union(types) ? render_bs.unionTypeStrings(list.map((function (s) {
                              if (typeof s === "number" || s.TAG !== /* StringLiteral */10) {
                                return "";
                              } else {
                                return s._0;
                              }
                            }), types), undefined) : render_bs.inlineUnion(list.map((function (t) {
                              return [
                                      string.capitalize_ascii(bstype_name(t)),
                                      bstype_to_code(undefined, t)
                                    ];
                            }), types), undefined);
              }
              if (exit === 1) {
                tmp = bstype_to_code(ctx$1, param$1) + (
                  genutils_bs.Is.optional(param$1) ? "=?" : ""
                );
              }
              return [
                      param[0],
                      tmp
                    ];
            }
            }(ctx$1));
            return render_bs.functionType(list.map(print, params), rest_param !== undefined ? print(rest_param) : undefined, list.exists((function (param) {
                              return genutils_bs.Is.optional(param[1]);
                            }), params), bstype_to_code(ctx$1, match.returnType), undefined);
        case /* Object */1 :
            return render_bs.objectType(list.map((function(ctx){
                          return function (param) {
                            return [
                                    genutils_bs.normalize_name(param[0]),
                                    bstype_to_code(ctx, param[1]),
                                    param[2]
                                  ];
                          }
                          }(ctx)), t._0), undefined);
        case /* Class */2 :
            if (t._0 !== undefined) {
              throw {
                    RE_EXN_ID: CodegenTypeError,
                    _1: "Class inheritence is not supported",
                    Error: new Error()
                  };
            }
            var class_types = list.map((function(ctx){
                return function (param) {
                  var type_of = param[1];
                  var is_meth;
                  is_meth = typeof type_of === "number" || type_of.TAG !== /* Function */0 ? false : true;
                  var type_of$1;
                  if (typeof type_of === "number" || type_of.TAG !== /* Function */0) {
                    type_of$1 = type_of;
                  } else {
                    var func = type_of._0;
                    var formalParams = list.map((function (param) {
                            return [
                                    "",
                                    param[1]
                                  ];
                          }), func.formalParams);
                    type_of$1 = {
                      TAG: /* Function */0,
                      _0: {
                        typeParams: func.typeParams,
                        formalParams: formalParams,
                        restParam: func.restParam,
                        returnType: func.returnType
                      }
                    };
                  }
                  var method_type_params;
                  method_type_params = typeof type_of$1 === "number" || type_of$1.TAG !== /* Function */0 ? /* [] */0 : list.map(genutils_bs.to_type_param, type_of$1._0.typeParams);
                  return [
                          param[0],
                          method_type_params,
                          bstype_to_code(ctx, type_of$1),
                          is_meth
                        ];
                }
                }(ctx)), t._1);
            return render_bs.classType(class_types, undefined);
        case /* Union */3 :
            return union_types_to_name(t._0);
        case /* Array */4 :
            return "array (" + (bstype_to_code(ctx, t._0) + ")");
        case /* Dict */5 :
            return "Js.Dict.t (" + (bstype_to_code(ctx, t._0) + ")");
        case /* Tuple */6 :
            var partial_arg = ctx;
            return render_bs.tupleType(list.map((function(partial_arg){
                          return function (param) {
                            return bstype_to_code(partial_arg, param);
                          }
                          }(partial_arg)), t._0), undefined);
        case /* Typeof */7 :
            throw {
                  RE_EXN_ID: CodegenTypeError,
                  _1: "Typeof can only operate on variable declarations",
                  Error: new Error()
                };
        case /* Named */8 :
            var s = t._1;
            var partial_arg$1 = ctx;
            return render_bs.applyArgs(module_prefix(t._2) + (
                        genutils_bs.Is.type_param(ctx.type_params, s) ? "'" + genutils_bs.normalize_name(string.uncapitalize_ascii(s)) : (
                            genutils_bs.Is.class_type(s, ctx.type_table) ? s + ".t" : genutils_bs.normalize_name(string.uncapitalize_ascii(s))
                          )
                      ), list.map((function(partial_arg$1){
                          return function (param) {
                            return bstype_to_code(partial_arg$1, param);
                          }
                          }(partial_arg$1)), t._0));
        case /* Optional */9 :
            _t = t._0;
            _$staropt$star = ctx;
            continue ;
        case /* StringLiteral */10 :
            throw {
                  RE_EXN_ID: CodegenTypeError,
                  _1: "Cannot use string literal outside the context of a union type",
                  Error: new Error()
                };
        case /* Promise */11 :
            return render_bs.applyArgs("Js_promise.t", {
                        hd: bstype_to_code(ctx, t._0),
                        tl: /* [] */0
                      });
        
      }
    }
  }}

function bstype_precode(_def) {
  while(true) {
    var def = _def;
    if (typeof def === "number") {
      return {
              hd: "",
              tl: /* [] */0
            };
    }
    switch (def.TAG | 0) {
      case /* Function */0 :
          var match = def._0;
          var restParam = match.restParam;
          return list.flatten(list.append(restParam !== undefined ? ({
                              hd: bstype_precode(restParam[1]),
                              tl: /* [] */0
                            }) : /* [] */0, list.map((function (param) {
                                var t = param[1];
                                if (typeof t === "number" || t.TAG !== /* Union */3) {
                                  return bstype_precode(t);
                                } else {
                                  return /* [] */0;
                                }
                              }), match.formalParams)));
      case /* Object */1 :
          return list.flatten(list.map((function (param) {
                            return bstype_precode(param[1]);
                          }), def._0));
      case /* Class */2 :
          return list.flatten(list.map((function (param) {
                            return bstype_precode(param[1]);
                          }), def._1));
      case /* Union */3 :
          var types = def._0;
          var types_precode = list.flatten(list.map(bstype_precode, types));
          return pervasives.$at(types_precode, {
                      hd: string_of_union_types(def, types),
                      tl: /* [] */0
                    });
      case /* Array */4 :
      case /* Dict */5 :
      case /* Optional */9 :
          _def = def._0;
          continue ;
      default:
        return {
                hd: "",
                tl: /* [] */0
              };
    }
  }}

function string_of_union_types(t, types) {
  if (genutils_bs.Is.string_union(types)) {
    return "";
  }
  var union_name = bstype_name(t);
  var union_types = list.map((function (type_of) {
          return [
                  string.capitalize_ascii(bstype_name(type_of)),
                  bstype_to_code(undefined, type_of)
                ];
        }), types);
  return render_bs.unionType(union_name, union_types, undefined);
}

function call_property_precode(module_id, var_name, statements) {
  return list.flatten(list.map((function (param) {
                    var type_of = param[1];
                    return pervasives.$at(bstype_precode(type_of), {
                                hd: render_bs.variableDeclaration((
                                      var_name === "" ? genutils_bs.to_module_name(module_id) : var_name
                                    ) + "_apply", genutils_bs.to_module_name(module_id), bstype_to_code(undefined, type_of), undefined, undefined, var_name, undefined),
                                tl: /* [] */0
                              });
                  }), list.filter(function (param) {
                        return param[0] === "$$callProperty";
                      })(statements)));
}

function decl_to_precode(module_id, type_of) {
  if (typeof type_of === "number") {
    return /* [] */0;
  }
  switch (type_of.TAG | 0) {
    case /* VarDecl */0 :
        var type_of$1 = type_of._1;
        var tmp;
        tmp = typeof type_of$1 === "number" || type_of$1.TAG !== /* Object */1 ? /* [] */0 : call_property_precode(module_id, type_of._0, type_of$1._0);
        return pervasives.$at(bstype_precode(type_of$1), tmp);
    case /* FuncDecl */1 :
        return bstype_precode(type_of._1);
    case /* ExportsDecl */3 :
        var type_of$2 = type_of._0;
        var tmp$1;
        tmp$1 = typeof type_of$2 === "number" || type_of$2.TAG !== /* Object */1 ? /* [] */0 : call_property_precode(module_id, "", type_of$2._0);
        return pervasives.$at(bstype_precode(type_of$2), tmp$1);
    case /* TypeDecl */4 :
        var type_of$3 = type_of._2;
        var type_params = type_of._1;
        var precode = bstype_precode(type_of$3);
        var type_param_names = list.map(genutils_bs.to_type_param, type_params);
        var type_decl = render_bs.typeDeclaration(string.uncapitalize_ascii(type_of._0), bstype_to_code({
                  type_params: type_params,
                  type_table: /* [] */0
                }, type_of$3), type_param_names, undefined);
        return list.append(precode, {
                    hd: type_decl,
                    tl: /* [] */0
                  });
    case /* ClassDecl */5 :
    case /* InterfaceDecl */6 :
        return bstype_precode(type_of._2);
    default:
      return {
              hd: "",
              tl: /* [] */0
            };
  }
}

function from_program(program) {
  if (typeof program === "number") {
    return "";
  }
  switch (program.TAG | 0) {
    case /* ModuleDecl */2 :
        var id = program._0;
        return string.concat("\n", genutils_bs.uniq(list.flatten(list.map((function (param) {
                                  return decl_to_precode(id, param);
                                }), program._1))));
    case /* TypeDecl */4 :
        return string.concat("\n", decl_to_precode("", program));
    default:
      return "";
  }
}

var Precode = {
  bstype_precode: bstype_precode,
  string_of_union_types: string_of_union_types,
  call_property_precode: call_property_precode,
  decl_to_precode: decl_to_precode,
  from_program: from_program
};

function constructor_type(type_table, param) {
  if (typeof param === "number") {
    throw {
          RE_EXN_ID: CodegenConstructorError,
          _1: "Type has no constructor",
          Error: new Error()
        };
  }
  if (param.TAG === /* Class */2) {
    var constructors = list.find_all(function (param) {
            return param[0] === "constructor";
          })(param._1);
    if (list.length(constructors) === 0) {
      return bstype_to_code({
                  type_params: /* [] */0,
                  type_table: type_table
                }, {
                  TAG: /* Function */0,
                  _0: {
                    typeParams: /* [] */0,
                    formalParams: {
                      hd: [
                        "_",
                        /* Unit */7
                      ],
                      tl: /* [] */0
                    },
                    restParam: undefined,
                    returnType: {
                      TAG: /* Named */8,
                      _0: /* [] */0,
                      _1: "t",
                      _2: undefined
                    }
                  }
                });
    }
    var match = list.hd(constructors);
    var cons_type = match[1];
    var cons_type$1;
    if (typeof cons_type === "number" || cons_type.TAG !== /* Function */0) {
      cons_type$1 = cons_type;
    } else {
      var func = cons_type._0;
      var formalParams = list.map((function (param) {
              return [
                      "",
                      param[1]
                    ];
            }), func.formalParams);
      var cons_type_params = list.map((function (name) {
              return {
                      TAG: /* Named */8,
                      _0: /* [] */0,
                      _1: name,
                      _2: undefined
                    };
            }), func.typeParams);
      cons_type$1 = {
        TAG: /* Function */0,
        _0: {
          typeParams: func.typeParams,
          formalParams: formalParams,
          restParam: func.restParam,
          returnType: {
            TAG: /* Named */8,
            _0: cons_type_params,
            _1: "t",
            _2: undefined
          }
        }
      };
    }
    return bstype_to_code({
                type_params: /* [] */0,
                type_table: type_table
              }, cons_type$1);
  }
  throw {
        RE_EXN_ID: CodegenConstructorError,
        _1: "Type has no constructor",
        Error: new Error()
      };
}

function get_prop_types(type_table, t) {
  var o = genutils_bs.React.extract_props(type_table, t);
  var tmp;
  tmp = typeof o === "number" || o.TAG !== /* Object */1 ? /* [] */0 : o._0;
  return list.map((function (param) {
                var t = param[1];
                var name = param[0];
                var prop_name = genutils_bs.normalize_name(name);
                var match;
                if (typeof t === "number") {
                  match = t === /* Boolean */6 ? [
                      /* Boolean */6,
                      false,
                      true
                    ] : [
                      t,
                      false,
                      false
                    ];
                } else if (t.TAG === /* Optional */9) {
                  var t$1 = t._0;
                  match = typeof t$1 === "number" && t$1 === 6 ? [
                      /* Boolean */6,
                      true,
                      true
                    ] : [
                      t$1,
                      true,
                      false
                    ];
                } else {
                  match = [
                    t,
                    false,
                    false
                  ];
                }
                var code = bstype_to_code({
                      type_params: /* [] */0,
                      type_table: type_table
                    }, match[0]);
                return [
                        prop_name,
                        name,
                        code,
                        match[1] || param[2],
                        match[2]
                      ];
              }), tmp);
}

function render_react_component(module_id, name, type_table, propsType) {
  var props = get_prop_types(type_table, propsType);
  var module_name = genutils_bs.unquote(module_id);
  var component_name = string.capitalize_ascii(genutils_bs.normalize_name(name));
  var props_type_string = bstype_to_code({
        type_params: /* [] */0,
        type_table: type_table
      }, genutils_bs.React.extract_component_type(propsType));
  return render_bs.react_component(true, module_name, component_name, name, props, props_type_string);
}

function render_react_class(className, type_table, propsType) {
  var props = get_prop_types(type_table, propsType);
  var js_name = className + ".react";
  var props_type_string = bstype_to_code({
        type_params: /* [] */0,
        type_table: type_table
      }, propsType);
  return render_bs.react_component(false, "", className, js_name, props, props_type_string);
}

function declaration_to_code(module_id, type_table, type_of) {
  if (typeof type_of === "number") {
    return "";
  }
  switch (type_of.TAG | 0) {
    case /* VarDecl */0 :
        var component = type_of._1;
        var id = type_of._0;
        if (genutils_bs.Is.react_component(component)) {
          return render_react_component(module_id, id, type_table, component);
        } else {
          return render_bs.variableDeclaration(genutils_bs.normalize_name(id), genutils_bs.unquote(module_id), bstype_to_code({
                          type_params: /* [] */0,
                          type_table: type_table
                        }, component), undefined, undefined, undefined, undefined);
        }
    case /* FuncDecl */1 :
        var component$1 = type_of._1;
        var id$1 = type_of._0;
        if (genutils_bs.Is.react_component(component$1)) {
          return render_react_component(module_id, id$1, type_table, component$1);
        }
        var tmp;
        tmp = typeof component$1 === "number" || component$1.TAG !== /* Function */0 ? false : component$1._0.restParam !== undefined;
        return render_bs.variableDeclaration(genutils_bs.normalize_name(id$1), genutils_bs.unquote(module_id), bstype_to_code({
                        type_params: /* [] */0,
                        type_table: type_table
                      }, component$1), undefined, tmp, undefined, undefined);
    case /* ModuleDecl */2 :
        var id$2 = type_of._0;
        return render_bs.moduleDeclaration(id$2, list.map((function (param) {
                          return declaration_to_code(id$2, type_table, param);
                        }), type_of._1), undefined);
    case /* ExportsDecl */3 :
        var type_of$1 = type_of._0;
        if (typeof type_of$1 !== "number" && type_of$1.TAG === /* Typeof */7) {
          var match = type_of$1._0;
          if (typeof match !== "number" && match.TAG === /* Named */8) {
            var t = match._1;
            var s = typetable_bs.get(t, type_table);
            if (typeof s === "number") {
              switch (s) {
                case /* Class */0 :
                    return render_bs.alias(genutils_bs.to_module_name(module_id), t + ".make");
                case /* None */1 :
                    throw {
                          RE_EXN_ID: CodegenTypeError,
                          _1: "typeof can only operate on classes",
                          Error: new Error()
                        };
                case /* NotFound */2 :
                    throw {
                          RE_EXN_ID: CodegenTypeError,
                          _1: "Unknown identifier: " + t,
                          Error: new Error()
                        };
                
              }
            } else {
              if (s.TAG === /* Type */0) {
                throw {
                      RE_EXN_ID: CodegenTypeError,
                      _1: "Invalid type from table being rendered",
                      Error: new Error()
                    };
              }
              throw {
                    RE_EXN_ID: CodegenTypeError,
                    _1: "Cannot use typeof with variable: " + s._0,
                    Error: new Error()
                  };
            }
          }
          
        }
        return render_bs.variableDeclaration(genutils_bs.to_module_name(module_id), genutils_bs.unquote(module_id), bstype_to_code({
                        type_params: /* [] */0,
                        type_table: type_table
                      }, type_of$1), true, undefined, undefined, undefined);
    case /* ClassDecl */5 :
        var component$2 = type_of._2;
        var _type_params = type_of._1;
        var id$3 = type_of._0;
        if (genutils_bs.Is.react_component(component$2)) {
          return render_react_component(module_id, id$3, type_table, component$2);
        }
        var type_param_names = list.map(genutils_bs.to_type_param, _type_params);
        var ctor_type = constructor_type(type_table, component$2);
        var class_type = bstype_to_code({
              type_params: _type_params,
              type_table: type_table
            }, component$2);
        return render_bs.classDeclaration(id$3, id$3, genutils_bs.unquote(module_id), class_type, ctor_type, type_param_names, undefined);
    case /* InterfaceDecl */6 :
        var type_params = type_of._1;
        var type_param_names$1 = list.map(genutils_bs.to_type_param, type_params);
        return render_bs.typeDeclaration(string.uncapitalize_ascii(type_of._0), bstype_to_code({
                        type_params: type_params,
                        type_table: type_table
                      }, type_of._2), type_param_names$1, undefined);
    case /* ReactClass */8 :
        return render_react_class(type_of._0, type_table, type_of._1);
    case /* TypeDecl */4 :
    case /* ImportDecl */7 :
    case /* Ignore */9 :
        return "";
    
  }
}

function program_to_code(program, type_table) {
  if (typeof program === "number") {
    return ;
  }
  switch (program.TAG | 0) {
    case /* ModuleDecl */2 :
        var id = program._0;
        var match = genutils_bs.split(/* "/" */47, id, /* [] */0);
        var inner_module_name;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var s = string.concat("", list.map(string.capitalize_ascii, {
                      hd: match$1.hd,
                      tl: match$1.tl
                    }));
            var module_name = string.sub(s, 0, s.length - 1 | 0);
            inner_module_name = "module " + (module_name + " = {\n");
          } else {
            inner_module_name = undefined;
          }
        } else {
          inner_module_name = undefined;
        }
        var match$2 = inner_module_name !== undefined ? [
            inner_module_name,
            "\n};\n"
          ] : [
            "",
            ""
          ];
        return [
                genutils_bs.to_module_name(id),
                match$2[0] + (from_program(program) + (string.concat("\n", list.map((function (param) {
                                return declaration_to_code(id, type_table, param);
                              }), program._1)) + match$2[1]))
              ];
    case /* TypeDecl */4 :
        return [
                "",
                from_program(program) + declaration_to_code("", /* [] */0, program)
              ];
    case /* ReactClass */8 :
        return [
                "",
                render_react_class(program._0, type_table, program._1)
              ];
    default:
      return ;
  }
}

var CodegenTypeError_1 = CodegenTypeError;
var CodegenConstructorError_1 = CodegenConstructorError;
var module_prefix_1 = module_prefix;
var bstype_name_1 = bstype_name;
var union_types_to_name_1 = union_types_to_name;
var intctx_1$1 = intctx$1;
var bstype_to_code_1 = bstype_to_code;
var Precode_1 = Precode;
var constructor_type_1 = constructor_type;
var get_prop_types_1 = get_prop_types;
var render_react_component_1 = render_react_component;
var render_react_class_1 = render_react_class;
var declaration_to_code_1 = declaration_to_code;
var program_to_code_1 = program_to_code;
/* No side effect */

var bsTypeReason_bs = {
	CodegenTypeError: CodegenTypeError_1,
	CodegenConstructorError: CodegenConstructorError_1,
	module_prefix: module_prefix_1,
	bstype_name: bstype_name_1,
	union_types_to_name: union_types_to_name_1,
	intctx: intctx_1$1,
	bstype_to_code: bstype_to_code_1,
	Precode: Precode_1,
	constructor_type: constructor_type_1,
	get_prop_types: get_prop_types_1,
	render_react_component: render_react_component_1,
	render_react_class: render_react_class_1,
	declaration_to_code: declaration_to_code_1,
	program_to_code: program_to_code_1
};

var CannotExtractName = caml_exceptions.create("GraphqlBsType-ReasonablyTyped.CannotExtractName");

function getName(param) {
  if (param.TAG === /* Name */6) {
    return param._0.value;
  }
  throw {
        RE_EXN_ID: CannotExtractName,
        Error: new Error()
      };
}

function graphqlAstToBsType(param) {
  if (param.TAG !== /* NamedType */4) {
    return /* Any */8;
  }
  var name = param._0.name;
  if (getName(name) === "string" || getName(name) === "ID") {
    return /* String */3;
  } else {
    return {
            TAG: /* Named */8,
            _0: /* [] */0,
            _1: getName(name),
            _2: undefined
          };
  }
}

function fieldToObjectProperty(field) {
  if (field.TAG === /* FieldDefinition */2) {
    var field$1 = field._0;
    return [
            getName(field$1.name),
            field$1.arguments.length === 0 ? graphqlAstToBsType(field$1.type_) : ({
                  TAG: /* Function */0,
                  _0: {
                    typeParams: /* [] */0,
                    formalParams: list.map((function (input) {
                            if (input.TAG === /* InputValueDefinition */3) {
                              var input$1 = input._0;
                              return [
                                      getName(input$1.name),
                                      graphqlAstToBsType(input$1.type_)
                                    ];
                            }
                            throw {
                                  RE_EXN_ID: "Not_found",
                                  Error: new Error()
                                };
                          }), array.to_list(field$1.arguments)),
                    restParam: undefined,
                    returnType: graphqlAstToBsType(field$1.type_)
                  }
                }),
            field$1.arguments.length === 0
          ];
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function graphqlAstToBsTypeAst(doc) {
  switch (doc.TAG | 0) {
    case /* Document */0 :
        var doc$1 = doc._0;
        return {
                TAG: /* ModuleDecl */2,
                _0: "\"" + (genutils_bs.normalize_name(doc$1.loc.source.name) + "\""),
                _1: list.map(graphqlAstToBsTypeAst, array.to_list(doc$1.definitions))
              };
    case /* ObjectTypeDefinition */1 :
        var def = doc._0;
        return {
                TAG: /* InterfaceDecl */6,
                _0: getName(def.name),
                _1: /* [] */0,
                _2: {
                  TAG: /* Object */1,
                  _0: list.map(fieldToObjectProperty, array.to_list(def.fields))
                }
              };
    default:
      return /* Noop */0;
  }
}

var CannotExtractName_1 = CannotExtractName;
var getName_1 = getName;
var fieldToObjectProperty_1 = fieldToObjectProperty;
var graphqlAstToBsType_1 = graphqlAstToBsType;
var graphqlAstToBsTypeAst_1 = graphqlAstToBsTypeAst;
/* No side effect */

var graphqlBsType_bs = {
	CannotExtractName: CannotExtractName_1,
	getName: getName_1,
	fieldToObjectProperty: fieldToObjectProperty_1,
	graphqlAstToBsType: graphqlAstToBsType_1,
	graphqlAstToBsTypeAst: graphqlAstToBsTypeAst_1
};

var CannotExtractName$1 = caml_exceptions.create("TypescriptBsType-ReasonablyTyped.CannotExtractName");

function getName$1(param) {
  switch (param.TAG | 0) {
    case /* Identifier */4 :
        return param._0.text;
    case /* FunctionDeclaration */5 :
        var match = param._0.name;
        if (match.TAG === /* Identifier */4) {
          return match._0.text;
        }
        throw {
              RE_EXN_ID: CannotExtractName$1,
              Error: new Error()
            };
    case /* InterfaceDeclaration */6 :
        var match$1 = param._0.name;
        if (match$1.TAG === /* Identifier */4) {
          return match$1._0.text;
        }
        throw {
              RE_EXN_ID: CannotExtractName$1,
              Error: new Error()
            };
    case /* Parameter */12 :
        var match$2 = param._0.name;
        if (match$2.TAG === /* Identifier */4) {
          return match$2._0.text;
        }
        throw {
              RE_EXN_ID: CannotExtractName$1,
              Error: new Error()
            };
    case /* TypeParameter */13 :
        var match$3 = param._0.name;
        if (match$3.TAG === /* Identifier */4) {
          return match$3._0.text;
        }
        throw {
              RE_EXN_ID: CannotExtractName$1,
              Error: new Error()
            };
    default:
      throw {
            RE_EXN_ID: CannotExtractName$1,
            Error: new Error()
          };
  }
}

function getNamesOfArray(names) {
  return list.map(getName$1, array.to_list(names));
}

function memberToObjectProperty(prop) {
  if (prop.TAG === /* PropertySignature */7) {
    var prop$1 = prop._0;
    return [
            getName$1(prop$1.name),
            typescriptAstToBsType(prop$1.type_),
            prop$1.questionToken !== undefined
          ];
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function typescriptAstToBsType(_parameter) {
  while(true) {
    var parameter = _parameter;
    switch (parameter.TAG | 0) {
      case /* StringKeyword */2 :
          return /* String */3;
      case /* NumberKeyword */3 :
          return /* Number */1;
      case /* TypeLiteral */10 :
          return {
                  TAG: /* Object */1,
                  _0: list.map(memberToObjectProperty, array.to_list(parameter._0.members))
                };
      case /* Parameter */12 :
          _parameter = parameter._0.type_;
          continue ;
      case /* TypeReference */14 :
          return {
                  TAG: /* Named */8,
                  _0: /* [] */0,
                  _1: getName$1(parameter._0.typeName),
                  _2: undefined
                };
      default:
        return /* Any */8;
    }
  }}

function typescriptAstToBsTypeAst(sourceFile) {
  switch (sourceFile.TAG | 0) {
    case /* FunctionDeclaration */5 :
        var func = sourceFile._0;
        return {
                TAG: /* FuncDecl */1,
                _0: getName$1(func.name),
                _1: {
                  TAG: /* Function */0,
                  _0: {
                    typeParams: list.map(getName$1, array.to_list(func.typeParameters)),
                    formalParams: list.map((function (param) {
                            return [
                                    getName$1(param),
                                    typescriptAstToBsType(param)
                                  ];
                          }), array.to_list(func.parameters)),
                    restParam: undefined,
                    returnType: typescriptAstToBsType(func.type_)
                  }
                }
              };
    case /* InterfaceDeclaration */6 :
        var $$interface = sourceFile._0;
        return {
                TAG: /* InterfaceDecl */6,
                _0: getName$1($$interface.name),
                _1: list.map(getName$1, array.to_list($$interface.typeParameters)),
                _2: {
                  TAG: /* Object */1,
                  _0: list.map(memberToObjectProperty, array.to_list($$interface.members))
                }
              };
    case /* TypeAliasDeclaration */9 :
        var decl = sourceFile._0;
        return {
                TAG: /* TypeDecl */4,
                _0: getName$1(decl.name),
                _1: list.map(getName$1, array.to_list(decl.typeParameters)),
                _2: typescriptAstToBsType(decl.type_)
              };
    case /* SourceFile */11 :
        var sourceFile$1 = sourceFile._0;
        if (sourceFile$1.parseDiagnostics.length !== 0) {
          throw {
                RE_EXN_ID: diagnostic_bs.$$Error,
                _1: diagnostic_bs.diagnosticOfTs(sourceFile$1),
                Error: new Error()
              };
        }
        return {
                TAG: /* ModuleDecl */2,
                _0: "\"" + (genutils_bs.normalize_name(sourceFile$1.fileName) + "\""),
                _1: list.map(typescriptAstToBsTypeAst, array.to_list(sourceFile$1.statements))
              };
    default:
      return /* Noop */0;
  }
}

var CannotExtractName_1$1 = CannotExtractName$1;
var getName_1$1 = getName$1;
var getNamesOfArray_1 = getNamesOfArray;
var memberToObjectProperty_1 = memberToObjectProperty;
var typescriptAstToBsType_1 = typescriptAstToBsType;
var typescriptAstToBsTypeAst_1 = typescriptAstToBsTypeAst;
/* No side effect */

var typescriptBsType_bs = {
	CannotExtractName: CannotExtractName_1$1,
	getName: getName_1$1,
	getNamesOfArray: getNamesOfArray_1,
	memberToObjectProperty: memberToObjectProperty_1,
	typescriptAstToBsType: typescriptAstToBsType_1,
	typescriptAstToBsTypeAst: typescriptAstToBsTypeAst_1
};

function parseSource(name, source) {
  var parseFlowSource = function (_name, source) {
    var match = parser_flow_bs.program_file(undefined, undefined, undefined, source, {
          TAG: /* SourceFile */1,
          _0: name
        });
    return match[0][1];
  };
  var parseTypescriptSource = function (filename, source) {
    var isDts = string.sub(filename, filename.length - 5 | 0, 5) === ".d.ts";
    var module_name = isDts ? string.sub(filename, 0, filename.length - 5 | 0) : string.sub(filename, 0, filename.length - 3 | 0);
    return typescript_bs.parse(module_name, source);
  };
  var parts = name.split(".");
  var extension = caml_array.get(parts, parts.length - 1 | 0);
  switch (extension) {
    case "css" :
        return {
                hd: cssBsType_bs.cssAstToBsTypeAst(name, csstree_bs.parse(name, source)),
                tl: /* [] */0
              };
    case "graphql" :
        return {
                hd: graphqlBsType_bs.graphqlAstToBsTypeAst(graphql_bs.parse(name, source)),
                tl: /* [] */0
              };
    case "js" :
        return list.map(flowBsType_bs.flowAstToBsTypeAst, parseFlowSource(name, source));
    case "ts" :
        return {
                hd: typescriptBsType_bs.typescriptAstToBsTypeAst(parseTypescriptSource(name, source)),
                tl: /* [] */0
              };
    default:
      return /* [] */0;
  }
}

function make_module_typetable(param) {
  if (typeof param === "number" || param.TAG !== /* ModuleDecl */2) {
    return /* [] */0;
  } else {
    return typetable_bs.create(param._1);
  }
}

function optimizeAst(program) {
  return optimizer_bs.optimize(make_module_typetable(program), program);
}

function renderAst(programs) {
  var globalTypeTable = typetable_bs.create(programs);
  return list.map((function (program) {
                return bsTypeReason_bs.program_to_code(program, pervasives.$at(make_module_typetable(program), globalTypeTable));
              }), programs);
}

var partial_arg$1 = [
  "Unknown ID",
  ""
];

function combineAst(param) {
  return list.fold_left((function (param, result) {
                var all_code = param[1];
                var current_id = param[0];
                if (result === undefined) {
                  return [
                          current_id,
                          all_code
                        ];
                }
                var program_code = result[1];
                var program_id = result[0];
                if (program_id !== "") {
                  return [
                          program_id,
                          all_code + ("\n" + program_code)
                        ];
                } else {
                  return [
                          current_id,
                          all_code + ("\n" + program_code)
                        ];
                }
              }), partial_arg$1, param);
}

function showSource(fileName, source) {
  console.log("\x1b[1;36m=== Source ===\x1b[0m");
  console.log("\x1b[1;30m/* " + (fileName + " */\x1b[0m"));
  console.log(source);
  
}

function showImports(programs) {
  console.log("\x1b[1;36m=== Imports ===\x1b[0m");
  return imports_bs.show_imports(programs);
}

function showTypes(programs) {
  console.log("\x1b[1;36m=== Types ===\x1b[0m");
  typetable_bs.show(typetable_bs.create(programs));
  return list.iter((function (md) {
                if (typeof md === "number" || md.TAG !== /* ModuleDecl */2) {
                  return ;
                } else {
                  return typetable_bs.show(make_module_typetable(md));
                }
              }), programs);
}

function showFlow(programs) {
  var flow_code = string.concat("\n", list.map(bsTypeFlow_bs.show_decl, programs));
  console.log("\x1b[1;36m=== Flow Definition ===\x1b[0m");
  console.log(flow_code);
  return pervasives.print_newline(undefined);
}

function showCode(result) {
  console.log("\x1b[1;36m=== Bucklescript Definition ===\x1b[0m");
  console.log("\x1b[1;30m/* Module " + (result[0] + " */\x1b[0m"));
  console.log(result[1]);
  
}

var Debug = {
  showSource: showSource,
  showImports: showImports,
  showTypes: showTypes,
  showFlow: showFlow,
  showCode: showCode
};

var Stage = {
  parseSource: parseSource,
  make_module_typetable: make_module_typetable,
  optimizeAst: optimizeAst,
  renderAst: renderAst,
  combineAst: combineAst,
  Debug: Debug
};

var ReportableError = caml_exceptions.create("Compiler-ReasonablyTyped.ReportableError");

function compile(moduleName, moduleSource, debug) {
  var result;
  try {
    var param = curry._1(combineAst, renderAst(list.map(optimizeAst, imports_bs.link(parseSource(moduleName, moduleSource)))));
    result = [
      param[0],
      param[1],
      []
    ];
  }
  catch (raw_xs){
    var xs = caml_js_exceptions.internalToOCamlException(raw_xs);
    if (xs.RE_EXN_ID === parse_error_bs.$$Error) {
      result = [
        "Unknown ID",
        "",
        diagnostic_bs.diagnosticOfFlow(xs._1, moduleSource)
      ];
    } else if (xs.RE_EXN_ID === diagnostic_bs.$$Error) {
      result = [
        "Unknown ID",
        "",
        xs._1
      ];
    } else {
      throw xs;
    }
  }
  if (debug) {
    var debugAsts = parseSource(moduleName, moduleSource);
    showSource(moduleName, moduleSource);
    showImports(debugAsts);
    showTypes(debugAsts);
    showFlow(debugAsts);
    showCode(result);
  }
  return result;
}

var Stage_1 = Stage;
var ReportableError_1 = ReportableError;
var compile_1 = compile;
/* Parser_flow Not a pure module */

var compiler_bs = {
	Stage: Stage_1,
	ReportableError: ReportableError_1,
	compile: compile_1
};

/**
 * Runs `refmt` on a string of Reason code
 *
 * @param {string} source Reason source code
 * @return {string} Formatted Reason code
 */
function format(source) {
  var fmtedCode = 'NotInitialized';
  try {
    fmtedCode = reason.printRE(reason.parseRE(source));
  } catch (e) {
    fmtedCode =
      'line ' +
      e.location.startLine +
      ', characters ' +
      e.location.startLineStartChar +
      '-' +
      e.location.endLineEndChar +
      ', ' +
      e.message +
      '\n' +
      source;
  }

  return fmtedCode
}

/**
 * Compiles a Flow libdef to a Reason interface, formatted and error handled
 *
 * @param {string} source Flow libdef to compile
 * @param {string} [filename] Name of file being compiled for better error messages
 * @return {string} Reason interface
 */
function compile$1(
  source,
  filename = '',
  includeModule = false,
  debugMode = false,
) {
  let res;
  let resName;
  let errors;

  try {
    const [moduleName, bsCode, diagnosticErrors] = compiler_bs.compile(filename, source, debugMode);
    const fmtCode = format(bsCode);
    res = fmtCode;
    resName = moduleName;
    errors = diagnosticErrors;
  } catch (e) {
    console.error(e);
    throw new Error(`${e[0][0]}`)
  }

  if (res.includes('SYNTAX ERROR>')) {
    throw new Error(res)
  }

  if (!includeModule) {
    return res
  } else {
    return {
      moduleName: resName,
      bsCode: res,
      diagnosticErrors: errors
    }
  }
}

var lib = {
  format,
  compile: compile$1
};

exports.default = lib;
